<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>正则表达式转化为DFA状态图</title>
      <link href="/2019/11/02/zheng-ze-biao-da-shi-zhuan-hua-wei-dfa-zhuang-tai-tu/"/>
      <url>/2019/11/02/zheng-ze-biao-da-shi-zhuan-hua-wei-dfa-zhuang-tai-tu/</url>
      
        <content type="html"><![CDATA[<p>话不多说, 这是一个将正则表达式转化为DFA状态图的小工具, 是在做编译原理实验的时候在基础实验之上进行扩展的.</p><p>demo: </p><p>./main -r “(a|b)*a” -o test.png</p><p><img src="/images/test_mindfa.png" alt></p><p>下面是文档和链接, 欢迎 star哦.</p><hr><h2 id="在线文档"><a href="#在线文档" class="headerlink" title="在线文档"></a>在线文档</h2><p><a href="https://blog.csdn.net/wjh2622075127" target="_blank" rel="noopener">@author 姬小野</a></p><p><a href="https://fiveplus.top/re2graph">点击查看文档与Demo</a></p><p><a href="https://github.com/JameyWoo/re2graph" target="_blank" rel="noopener">Github地址</a></p><h2 id="项目依赖"><a href="#项目依赖" class="headerlink" title="项目依赖"></a>项目依赖</h2><p>此项目的图片生成部分依赖于项目 graphviz, <a href="https://www.graphviz.org/" target="_blank" rel="noopener">这是他们的主页</a> </p><p>致谢~</p><p>如何安装 graphviz 可以参考<a href="https://www.cnblogs.com/onemorepoint/p/8310996.html" target="_blank" rel="noopener">这篇文章</a></p><p>致谢~</p><p><strong>请安装好graphviz并配置好环境变量之后再使用本程序的画图功能. 字符串匹配功能不受影响</strong></p><p>配置好环境的标志是终端命令<br><code>dot --version</code> 或者 <code>circo --version</code> 能正确执行.<br>确认操作无误可重启电脑再尝试</p><h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>在工程根目录下, 执行 <code>make</code> 编译程序, 可得到目标文件 <code>main.exe</code></p><p>tmp 文件夹为临时文件, 保存了中间过程产生的nfa, dfa以及dot文件. </p><p>image 文件夹为图片文件夹, 保存了生成的图片</p><p>如果出现make时无法识别<code>.o</code>文件的情况, 可以尝试<code>make -f Makefile-win</code></p><h2 id="正则表达式支持"><a href="#正则表达式支持" class="headerlink" title="正则表达式支持"></a>正则表达式支持</h2><p>支持以下简单规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">( )</span><br><span class="line">*</span><br><span class="line">+</span><br><span class="line">[]</span><br><span class="line">a-z</span><br><span class="line">|</span><br></pre></td></tr></table></figure><p>如 <code>[0-9a-zA-Z]+@(gmail|qq|163).com</code></p><p>注意: <strong>输入字符过多时</strong>比如上面的re请不要开启 -g 的 d 参数. 因为边和点太多无法绘制出来. 注意, 默认不适用-g是会绘制三种图片的. <strong>所以这种情况需要指定-g m 或者 -g nm才会正确执行程序. 不然会一直尝试绘制nfa图</strong></p><h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p>执行 make 得到目标程序</p><p>输入 <code>./main -h</code> 得到参数提示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Usage: ./main [options hir:s:o:p:g:] [:argument]</span><br><span class="line">options:</span><br><span class="line">  -h</span><br><span class="line">    说明: 打印提示信息并退出程序</span><br><span class="line">  -i</span><br><span class="line">    说明: 手动输入正则表达式 和 待匹配字符串</span><br><span class="line">  -r &lt;re_exp&gt;</span><br><span class="line">    说明: 作为模式的正则表达式</span><br><span class="line">  -s &lt;<span class="built_in">string</span>&gt;</span><br><span class="line">    说明: 待匹配的字符串</span><br><span class="line">  -o &lt;png_file&gt;</span><br><span class="line">    说明: 要输出的png文件路径</span><br><span class="line">  -p &lt;pattern_name&gt;</span><br><span class="line">    说明: 输出的状态图要布局的模式: circo | dot | neato | twopi | fdp | patchwork</span><br><span class="line">  -g &lt;graph_type&gt;</span><br><span class="line">    说明: 要画的状态图的类型, 默认为三个类型: n | d | m, 可连起来写成字符串如 nm. 他们分别为 nfa | dfa | mindfa</span><br><span class="line">demos:</span><br><span class="line">  ./main -i</span><br><span class="line">    说明: 手动输入正则表达式 和 待匹配字符串, 程序打印匹配结果</span><br><span class="line">  ./main -r <span class="string">"(ab*|b)*ca*"</span> -s aabbacaa</span><br><span class="line">    说明: 用正则表达式 (ab*|b)*ca* 去匹配字符串 aabbacaa</span><br><span class="line">  ./main -r <span class="string">"(ab*|b)*ca*"</span> -o test.png</span><br><span class="line">    说明: 将 正则表达式 (ab*|b)*ca* 转化到 test_nfa.png, test_dfa.png, test_mindfa.png 系列图片</span><br><span class="line">  ./main -r <span class="string">"(ab*|b)*ca*"</span> -o test.png -p dot</span><br><span class="line">    说明: 用 dot模式 生成状态图</span><br><span class="line">  ./main -r <span class="string">"(ab*|b)*ca*"</span> -o test.png -p dot -g nm</span><br><span class="line">    说明: 指定生成 nfa 和 mindfa 状态图</span><br><span class="line"></span><br><span class="line">good luck!</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自编码器AutoEncoder</title>
      <link href="/2019/08/14/zi-bian-ma-qi-autoencoder/"/>
      <url>/2019/08/14/zi-bian-ma-qi-autoencoder/</url>
      
        <content type="html"><![CDATA[<h2 id="一-什么是自编码器"><a href="#一-什么是自编码器" class="headerlink" title="一. 什么是自编码器"></a>一. 什么是自编码器</h2><p>自动编码器 autoencoder, 简单表现编码器为将一组数据进行压缩编码(降维), 解码器将这组数据恢复成高维的数据. 这种编码和解码的过程不是无损的, 因此最终的输出和输入是有一些差异的, 且非常依赖于训练的数据集.</p><p>如图所示<br><img src="/images/20190814_1.png" alt></p><p>如上面这张图所示, 对于一个简单的三层线性神经网络组成的自编码器, 我们在进行神经网络的搭建过程中, 将(input, hidden) 这个过程叫做编码器, 将(hidden, output) 这个过程叫做解码器. 对于mnist数据集而言, 它的维度变化是 784 -&gt; x -&gt; 784, 其中, x &lt; 784, 是编码的维度.</p><hr><h2 id="二-有什么作用"><a href="#二-有什么作用" class="headerlink" title="二. 有什么作用"></a>二. 有什么作用</h2><h3 id="1-图像去噪"><a href="#1-图像去噪" class="headerlink" title="1) 图像去噪"></a>1) 图像去噪</h3><p>看上去很强啊<br><img src="/images/20190814_2.png" alt></p><h3 id="2-可视化降维"><a href="#2-可视化降维" class="headerlink" title="2) 可视化降维"></a>2) 可视化降维</h3><hr><h2 id="三-如何实现"><a href="#三-如何实现" class="headerlink" title="三. 如何实现"></a>三. 如何实现</h2><p>训练神经网络需要定义损失函数, 那么这个自编码器的损失衡量值是什么? </p><p>衡量损失的值是由网络的输出结果和输入决定的. 也就是说, 是由这两个784维数据的差别决定的.</p><h3 id="1-全连接层实现"><a href="#1-全连接层实现" class="headerlink" title="1) 全连接层实现"></a>1) 全连接层实现</h3><p>首先定义一个神经网络</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Autoencoder</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, encoding_dim)</span>:</span></span><br><span class="line">        super(Autoencoder, self).__init__()</span><br><span class="line">        <span class="comment">## encoder ##</span></span><br><span class="line">        self.encoder = nn.Linear(<span class="number">784</span>, encoding_dim)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">## decoder ##</span></span><br><span class="line">        self.decoder = nn.Linear(encoding_dim, <span class="number">784</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># define feedforward behavior </span></span><br><span class="line">        <span class="comment"># and scale the *output* layer with a sigmoid activation function</span></span><br><span class="line"><span class="comment">#         print(x.shape)</span></span><br><span class="line">        x = x.view(<span class="number">-1</span>, <span class="number">784</span>)</span><br><span class="line">        x = F.relu(self.encoder(x))</span><br><span class="line">        x = torch.sigmoid(self.decoder(x))</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize the NN</span></span><br><span class="line">encoding_dim = <span class="number">128</span></span><br><span class="line">model = Autoencoder(encoding_dim)</span><br></pre></td></tr></table></figure><p>定义损失函数和优化器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># specify loss function</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line"># specify loss function</span><br><span class="line">optimizer = torch.optim.Adam(model.parameters(), lr=<span class="number">0.001</span>)</span><br></pre></td></tr></table></figure><p>训练过程, 一共20个epochs, 话说pytorch还真慢, 这么简单的网络都要训练好一会</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># number of epochs to train the model</span></span><br><span class="line">n_epochs = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">1</span>, n_epochs+<span class="number">1</span>):</span><br><span class="line">    <span class="comment"># monitor training loss</span></span><br><span class="line">    train_loss = <span class="number">0.0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">###################</span></span><br><span class="line">    <span class="comment"># train the model #</span></span><br><span class="line">    <span class="comment">###################</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> train_loader:</span><br><span class="line">        <span class="comment"># _ stands in for labels, here</span></span><br><span class="line">        images, _ = data</span><br><span class="line">        <span class="comment"># flatten images</span></span><br><span class="line">        images = images.view(images.size(<span class="number">0</span>), <span class="number">-1</span>)</span><br><span class="line">        <span class="comment"># clear the gradients of all optimized variables</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        <span class="comment"># forward pass: compute predicted outputs by passing inputs to the model</span></span><br><span class="line"><span class="comment">#         print(images.shape)</span></span><br><span class="line">        outputs = model(images)</span><br><span class="line">        <span class="comment"># calculate the loss</span></span><br><span class="line">        loss = criterion(outputs, images)</span><br><span class="line">        <span class="comment"># backward pass: compute gradient of the loss with respect to model parameters</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        <span class="comment"># perform a single optimization step (parameter update)</span></span><br><span class="line">        optimizer.step()</span><br><span class="line">        <span class="comment"># update running training loss</span></span><br><span class="line">        train_loss += loss.item()*images.size(<span class="number">0</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="comment"># print avg training statistics </span></span><br><span class="line">    train_loss = train_loss/len(train_loader)</span><br><span class="line">    print(<span class="string">'Epoch: &#123;&#125; \tTraining Loss: &#123;:.6f&#125;'</span>.format(</span><br><span class="line">        epoch, </span><br><span class="line">        train_loss</span><br><span class="line">        ))</span><br></pre></td></tr></table></figure><p>训练过程的损失变化</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Epoch: <span class="number">1</span> Training Loss: <span class="number">0.342308</span></span><br><span class="line">Epoch: <span class="number">2</span> Training Loss: <span class="number">0.081272</span></span><br><span class="line">Epoch: <span class="number">3</span> Training Loss: <span class="number">0.058724</span></span><br><span class="line">Epoch: <span class="number">4</span> Training Loss: <span class="number">0.051274</span></span><br><span class="line">Epoch: <span class="number">5</span> Training Loss: <span class="number">0.047382</span></span><br><span class="line">Epoch: <span class="number">6</span> Training Loss: <span class="number">0.044760</span></span><br><span class="line">Epoch: <span class="number">7</span> Training Loss: <span class="number">0.043184</span></span><br><span class="line">Epoch: <span class="number">8</span> Training Loss: <span class="number">0.042066</span></span><br><span class="line">Epoch: <span class="number">9</span> Training Loss: <span class="number">0.041246</span></span><br><span class="line">Epoch: <span class="number">10</span> Training Loss: <span class="number">0.040589</span></span><br><span class="line">Epoch: <span class="number">11</span> Training Loss: <span class="number">0.040059</span></span><br><span class="line">Epoch: <span class="number">12</span> Training Loss: <span class="number">0.039646</span></span><br><span class="line">Epoch: <span class="number">13</span> Training Loss: <span class="number">0.039272</span></span><br><span class="line">Epoch: <span class="number">14</span> Training Loss: <span class="number">0.038980</span></span><br><span class="line">Epoch: <span class="number">15</span> Training Loss: <span class="number">0.038733</span></span><br><span class="line">Epoch: <span class="number">16</span> Training Loss: <span class="number">0.038524</span></span><br><span class="line">Epoch: <span class="number">17</span> Training Loss: <span class="number">0.038328</span></span><br><span class="line">Epoch: <span class="number">18</span> Training Loss: <span class="number">0.038162</span></span><br><span class="line">Epoch: <span class="number">19</span> Training Loss: <span class="number">0.038012</span></span><br><span class="line">Epoch: <span class="number">20</span> Training Loss: <span class="number">0.037874</span></span><br></pre></td></tr></table></figure><p>那么效果如何呢? 上面一排是输入图像, 下面一排是输出图像. 经过自编码器之后, 还原度还是很高的.</p><p><img src="/images/20190814_3.png" alt></p><h3 id="2-测试-对有噪声图像的自编码"><a href="#2-测试-对有噪声图像的自编码" class="headerlink" title="2) 测试: 对有噪声图像的自编码"></a>2) 测试: 对有噪声图像的自编码</h3><p>首先查看一张图片</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a_img = np.squeeze(images[<span class="number">0</span>])</span><br><span class="line">print(a_img.shape)</span><br><span class="line">print(np.max(a_img))</span><br><span class="line">print(np.min(a_img))</span><br><span class="line"></span><br><span class="line">plt.imshow(a_img, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/20190814_4.png" alt><br>然后向其中加入噪声</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_img_x = a_img + <span class="number">0.08</span> * np.random.normal(loc=<span class="number">0.0</span>, scale=<span class="number">1.0</span>, size=a_img.shape)</span><br><span class="line"></span><br><span class="line">plt.imshow(a_img_x, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure><p>这是加入噪声之后的图片, 可以看出差别还是很大的. 那么我们的编码器能还原出如何的效果呢?<br><img src="/images/20190814_5.png" alt></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a_img_output = model(torch.Tensor(a_img_x).view(<span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">print(a_img_output.shape)</span><br><span class="line"></span><br><span class="line">output_img = a_img_output.view(<span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line">output_img = output_img.detach().numpy()</span><br><span class="line"></span><br><span class="line">plt.imshow(output_img, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure><p>这是还原后的, 说实话看到这个图片我心里也是很惊讶的. 就在于加入那么多噪声之后, 居然还可以还原的如此清晰. 当然这是对于MNIST数据集而言, 这个数据集比较简单.<br><img src="/images/20190814_6.png" alt></p><h3 id="3-卷积层实现"><a href="#3-卷积层实现" class="headerlink" title="3) 卷积层实现"></a>3) 卷积层实现</h3><p>不同之处在于定义自编码器的神经网络结构<br>如图所示<br><img src="/images/20190814_7.png" alt><br>可以看到在decoder中经过了两个反卷积层, <del>但是由于水平有限, 这个反卷积层看着好奇怪, 不知道是怎么反卷积的. </del></p><p>pytorch实现</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="comment"># define the NN architecture</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConvAutoencoder</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(ConvAutoencoder, self).__init__()</span><br><span class="line">        <span class="comment">## encoder layers ##</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">16</span>, <span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">16</span>, <span class="number">4</span>, <span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        self.pool = nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">## decoder layers ##</span></span><br><span class="line">        <span class="comment">## a kernel of 2 and a stride of 2 will increase the spatial dims by 2</span></span><br><span class="line">        self.t_conv1 = nn.ConvTranspose2d(<span class="number">4</span>, <span class="number">16</span>, <span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line">        self.t_conv2 = nn.ConvTranspose2d(<span class="number">16</span>, <span class="number">1</span>, <span class="number">2</span>, stride=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment">## encode ##</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">## decode ##</span></span><br><span class="line">        <span class="comment">## apply ReLu to all hidden layers *except for the output layer</span></span><br><span class="line">        <span class="comment">## apply a sigmoid to the output layer</span></span><br><span class="line">        x = F.relu(self.conv1(x))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        x = F.relu(self.conv2(x))</span><br><span class="line">        x = self.pool(x)</span><br><span class="line">        </span><br><span class="line">        x = F.relu(self.t_conv1(x))</span><br><span class="line">        x = torch.sigmoid(self.t_conv2(x))</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"><span class="comment"># initialize the NN</span></span><br><span class="line">model = ConvAutoencoder()</span><br><span class="line">print(model)</span><br></pre></td></tr></table></figure><p>训练起来比全连接层的网络还要慢很多, 而损失值的降低也慢很多, 不像之前从epoch 1 到 epoch 2 直接就断崖式下跌了. 下面是损失值的变化过程, 只训练了 15个epoch. 从损失之上看这个效果好像差很多?</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Epoch: <span class="number">1</span> Training Loss: <span class="number">0.448799</span></span><br><span class="line">Epoch: <span class="number">2</span> Training Loss: <span class="number">0.266815</span></span><br><span class="line">Epoch: <span class="number">3</span> Training Loss: <span class="number">0.251290</span></span><br><span class="line">Epoch: <span class="number">4</span> Training Loss: <span class="number">0.240823</span></span><br><span class="line">Epoch: <span class="number">5</span> Training Loss: <span class="number">0.231836</span></span><br><span class="line">Epoch: <span class="number">6</span> Training Loss: <span class="number">0.220550</span></span><br><span class="line">Epoch: <span class="number">7</span> Training Loss: <span class="number">0.210341</span></span><br><span class="line">Epoch: <span class="number">8</span> Training Loss: <span class="number">0.202768</span></span><br><span class="line">Epoch: <span class="number">9</span> Training Loss: <span class="number">0.197010</span></span><br><span class="line">Epoch: <span class="number">10</span> Training Loss: <span class="number">0.193259</span></span><br><span class="line">Epoch: <span class="number">11</span> Training Loss: <span class="number">0.190589</span></span><br><span class="line">Epoch: <span class="number">12</span> Training Loss: <span class="number">0.188406</span></span><br><span class="line">Epoch: <span class="number">13</span> Training Loss: <span class="number">0.186529</span></span><br><span class="line">Epoch: <span class="number">14</span> Training Loss: <span class="number">0.184983</span></span><br><span class="line">Epoch: <span class="number">15</span> Training Loss: <span class="number">0.183579</span></span><br></pre></td></tr></table></figure><p>观察下图的数字9的话, 可以看到损失了不少.<br><img src="/images/20190814_8.png" alt></p><p><strong>再看看噪声图片的处理能力如何</strong></p><p>原图:<br><img src="/images/20190814_9.png" alt><br>加入噪声:<br><img src="/images/20190814_10.png" alt><br>经过自编码器<br><img src="/images/20190814_11.png" alt><br>呃, 效果似乎有点不是很对, 可能是训练的epoch太少了, 毕竟我们可以前面看到训练15个epoch的损失值还是达到了0.18, 而在全连接层的简单自编码器上第二个epoch的损失值就达到了0.08</p><hr><h2 id="四-一些小细节"><a href="#四-一些小细节" class="headerlink" title="四. 一些小细节"></a>四. 一些小细节</h2><ol><li><p>numpy 的 squeeze 函数<br><a href="https://blog.csdn.net/zenghaitao0128/article/details/78512715" target="_blank" rel="noopener">参考博客</a><br>作用：<strong>从数组的形状中删除单维度条目，即把shape中为1的维度去掉</strong></p></li><li><p>给MNIST图片加入噪声的方法</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test_img_x = test_img + <span class="number">0.08</span> * np.random.normal(loc=<span class="number">0.0</span>, scale=<span class="number">1.0</span>, size=test_img.shape)</span><br></pre></td></tr></table></figure></li></ol><p>就是加入一些随机值, 在原图的基础上进行小幅度修改.</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to PyTorch 笔记</title>
      <link href="/2019/08/05/introduction-to-pytorch-bi-ji/"/>
      <url>/2019/08/05/introduction-to-pytorch-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction-to-PyTorch-笔记"><a href="#Introduction-to-PyTorch-笔记" class="headerlink" title="Introduction to PyTorch 笔记"></a>Introduction to PyTorch 笔记</h1><h2 id="Part-1-Tensors-in-PyTorch-Solution-ipynb"><a href="#Part-1-Tensors-in-PyTorch-Solution-ipynb" class="headerlink" title="Part 1 - Tensors in PyTorch (Solution).ipynb"></a>Part 1 - Tensors in PyTorch (Solution).ipynb</h2><ol><li><p>最基本的神经网络, 使用矩阵计算. </p></li><li><p>激活函数, sigmoid, softmax, relu等</p></li><li><p>使用pytorch生成随机数(用来初始化weights). 似乎用不同的norm函数影响较大</p></li><li><p>介绍了前向传播的实现方式, 矩阵相乘 + 偏置</p></li><li><p>矩阵改变形状, 从numpy转化来/去</p></li></ol><h2 id="Part-2-Neural-Networks-in-PyTorch-Exercises-ipynb"><a href="#Part-2-Neural-Networks-in-PyTorch-Exercises-ipynb" class="headerlink" title="Part 2 - Neural Networks in PyTorch (Exercises).ipynb"></a>Part 2 - Neural Networks in PyTorch (Exercises).ipynb</h2><ol><li><p>加载MNIST数据集, 设置是训练或者测试, 用DataLoader进行分批加载, 可设置随机化</p></li><li><p>使用了transforms转换器转换数据, 比如归一化, 转化为tensor, 改变图片大小等</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">train_transforms = transforms.Compose([transforms.RandomRotation(<span class="number">30</span>),</span><br><span class="line">                                       transforms.RandomResizedCrop(<span class="number">224</span>),</span><br><span class="line">                                       transforms.RandomHorizontalFlip(),</span><br><span class="line">                                       transforms.ToTensor(),</span><br><span class="line">                                       transforms.Normalize([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>], </span><br><span class="line">                                                            [<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])])</span><br></pre></td></tr></table></figure></li><li><p>练习自定义网络权重, 并实现网络的前向传播</p></li><li><p>自己用pytorch实现了softmax. 使用sum, argmax等函数需要注意设置dim</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">softmax</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> torch.exp(out) / torch.exp(out).sum(dim=<span class="number">1</span>).view(<span class="number">64</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>自定义网络结构(class方式), 继承自nn.Module. 自定义层次, 激活函数等, 实现init, forward函数</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Network</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Inputs to hidden layer linear transformation</span></span><br><span class="line">        self.hidden = nn.Linear(<span class="number">784</span>, <span class="number">256</span>)</span><br><span class="line">        <span class="comment"># Output layer, 10 units - one for each digit</span></span><br><span class="line">        self.output = nn.Linear(<span class="number">256</span>, <span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Define sigmoid activation and softmax output </span></span><br><span class="line">        self.sigmoid = nn.Sigmoid()</span><br><span class="line">        self.softmax = nn.Softmax(dim=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># Pass the input tensor through each of our operations</span></span><br><span class="line">        x = self.hidden(x)</span><br><span class="line">        x = self.sigmoid(x)</span><br><span class="line">        x = self.output(x)</span><br><span class="line">        x = self.softmax(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li><li><p>有model对象, 可方便地查看模型的权重, 偏置值, 还可以进行更改, 如使用随机值</p></li><li><p>使用nn.Sequential()搭建网络, 和之前其实类似</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model = nn.Sequential(nn.Linear(input_size, hidden_sizes[<span class="number">0</span>]),</span><br><span class="line">                      nn.ReLU(),</span><br><span class="line">                      nn.Linear(hidden_sizes[<span class="number">0</span>], hidden_sizes[<span class="number">1</span>]),</span><br><span class="line">                      nn.ReLU(),</span><br><span class="line">                      nn.Linear(hidden_sizes[<span class="number">1</span>], output_size),</span><br><span class="line">                      nn.Softmax(dim=<span class="number">1</span>))</span><br></pre></td></tr></table></figure></li></ol><ol start="8"><li>多次出现helper辅助代码, 实现一些功能, 如下所示</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">from</span> torch.autograd <span class="keyword">import</span> Variable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_network</span><span class="params">(net, trainloader)</span>:</span></span><br><span class="line"></span><br><span class="line">    criterion = nn.MSELoss()</span><br><span class="line">    optimizer = optim.Adam(net.parameters(), lr=<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line">    dataiter = iter(trainloader)</span><br><span class="line">    images, labels = dataiter.next()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create Variables for the inputs and targets</span></span><br><span class="line">    inputs = Variable(images)</span><br><span class="line">    targets = Variable(images)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Clear the gradients from all Variables</span></span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Forward pass, then backward pass, then update weights</span></span><br><span class="line">    output = net.forward(inputs)</span><br><span class="line">    loss = criterion(output, targets)</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imshow</span><span class="params">(image, ax=None, title=None, normalize=True)</span>:</span></span><br><span class="line">    <span class="string">"""Imshow for Tensor."""</span></span><br><span class="line">    <span class="keyword">if</span> ax <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        fig, ax = plt.subplots()</span><br><span class="line">    image = image.numpy().transpose((<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> normalize:</span><br><span class="line">        mean = np.array([<span class="number">0.485</span>, <span class="number">0.456</span>, <span class="number">0.406</span>])</span><br><span class="line">        std = np.array([<span class="number">0.229</span>, <span class="number">0.224</span>, <span class="number">0.225</span>])</span><br><span class="line">        image = std * image + mean</span><br><span class="line">        image = np.clip(image, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    ax.imshow(image)</span><br><span class="line">    ax.spines[<span class="string">'top'</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">'right'</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">'left'</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.spines[<span class="string">'bottom'</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.tick_params(axis=<span class="string">'both'</span>, length=<span class="number">0</span>)</span><br><span class="line">    ax.set_xticklabels(<span class="string">''</span>)</span><br><span class="line">    ax.set_yticklabels(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view_recon</span><span class="params">(img, recon)</span>:</span></span><br><span class="line">    <span class="string">''' Function for displaying an image (as a PyTorch Tensor) and its</span></span><br><span class="line"><span class="string">        reconstruction also a PyTorch Tensor</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line"></span><br><span class="line">    fig, axes = plt.subplots(ncols=<span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br><span class="line">    axes[<span class="number">0</span>].imshow(img.numpy().squeeze())</span><br><span class="line">    axes[<span class="number">1</span>].imshow(recon.data.numpy().squeeze())</span><br><span class="line">    <span class="keyword">for</span> ax <span class="keyword">in</span> axes:</span><br><span class="line">        ax.axis(<span class="string">'off'</span>)</span><br><span class="line">        ax.set_adjustable(<span class="string">'box-forced'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view_classify</span><span class="params">(img, ps, version=<span class="string">"MNIST"</span>)</span>:</span></span><br><span class="line">    <span class="string">''' Function for viewing an image and it's predicted classes.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    ps = ps.data.numpy().squeeze()</span><br><span class="line"></span><br><span class="line">    fig, (ax1, ax2) = plt.subplots(figsize=(<span class="number">6</span>,<span class="number">9</span>), ncols=<span class="number">2</span>)</span><br><span class="line">    ax1.imshow(img.resize_(<span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>).numpy().squeeze())</span><br><span class="line">    ax1.axis(<span class="string">'off'</span>)</span><br><span class="line">    ax2.barh(np.arange(<span class="number">10</span>), ps)</span><br><span class="line">    ax2.set_aspect(<span class="number">0.1</span>)</span><br><span class="line">    ax2.set_yticks(np.arange(<span class="number">10</span>))</span><br><span class="line">    <span class="keyword">if</span> version == <span class="string">"MNIST"</span>:</span><br><span class="line">        ax2.set_yticklabels(np.arange(<span class="number">10</span>))</span><br><span class="line">    <span class="keyword">elif</span> version == <span class="string">"Fashion"</span>:</span><br><span class="line">        ax2.set_yticklabels([<span class="string">'T-shirt/top'</span>,</span><br><span class="line">                            <span class="string">'Trouser'</span>,</span><br><span class="line">                            <span class="string">'Pullover'</span>,</span><br><span class="line">                            <span class="string">'Dress'</span>,</span><br><span class="line">                            <span class="string">'Coat'</span>,</span><br><span class="line">                            <span class="string">'Sandal'</span>,</span><br><span class="line">                            <span class="string">'Shirt'</span>,</span><br><span class="line">                            <span class="string">'Sneaker'</span>,</span><br><span class="line">                            <span class="string">'Bag'</span>,</span><br><span class="line">                            <span class="string">'Ankle Boot'</span>], size=<span class="string">'small'</span>);</span><br><span class="line">    ax2.set_title(<span class="string">'Class Probability'</span>)</span><br><span class="line">    ax2.set_xlim(<span class="number">0</span>, <span class="number">1.1</span>)</span><br><span class="line"></span><br><span class="line">    plt.tight_layout()</span><br></pre></td></tr></table></figure><h2 id="Part-3-Training-Neural-Networks-Exercises-ipynb"><a href="#Part-3-Training-Neural-Networks-Exercises-ipynb" class="headerlink" title="Part 3 - Training Neural Networks (Exercises).ipynb"></a>Part 3 - Training Neural Networks (Exercises).ipynb</h2><ol><li>梯度下降与反向传播. 反向传播算法是求导过程中链式法则的应用<br> $$<br> \large \frac{\partial \ell}{\partial W_1} = \frac{\partial L_1}{\partial W_1} \frac{\partial S}{\partial L_1} \frac{\partial L_2}{\partial S} \frac{\partial \ell}{\partial L_2}<br> $$</li></ol><p>$$<br>\large W^\prime_1 = W_1 - \alpha \frac{\partial \ell}{\partial W_1}<br>$$</p><ol start="2"><li><p>通常会导入的包</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>介绍了损失函数. </p><p> 比如交叉熵nn.CrossEntropyLoss(), 一般赋值给criterion</p><p> 还有比如nn.NLLLoss()</p></li></ol><ol start="4"><li><p>介绍了自动求导autograd, 调用.backward()可查看导数</p></li><li><p>介绍了optimizer, 在torch.optim中. 有SGD(随机梯度下降等). Adam更好. </p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optimizers require the parameters to optimize and a learning rate</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.01</span>)</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li><p>训练中记得清零梯度<code>optimizer.zero_grad()</code></p></li><li><p>optimizer调用step()方法更新模型的权重</p></li><li><p>一个较完整的训练过程</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Your solution here</span></span><br><span class="line"></span><br><span class="line">model = nn.Sequential(nn.Linear(<span class="number">784</span>, <span class="number">128</span>),</span><br><span class="line">                      nn.ReLU(),</span><br><span class="line">                      nn.Linear(<span class="number">128</span>, <span class="number">64</span>),</span><br><span class="line">                      nn.ReLU(),</span><br><span class="line">                      nn.Linear(<span class="number">64</span>, <span class="number">10</span>),</span><br><span class="line">                      nn.LogSoftmax(dim=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">criterion = nn.NLLLoss()</span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.003</span>)</span><br><span class="line"></span><br><span class="line">epochs = <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(epochs):</span><br><span class="line">    running_loss = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> images, labels <span class="keyword">in</span> trainloader:</span><br><span class="line">        <span class="comment"># Flatten MNIST images into a 784 long vector</span></span><br><span class="line">        images = images.view(images.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> Training pass</span></span><br><span class="line">        optimizer.zero_grad()</span><br><span class="line">        output = model.forward(images)</span><br><span class="line"><span class="comment">#         print(output.shape)</span></span><br><span class="line"><span class="comment">#         print(labels.shape)</span></span><br><span class="line">        </span><br><span class="line">        loss = criterion(output, labels)</span><br><span class="line">        </span><br><span class="line">        running_loss += loss.item()</span><br><span class="line">        </span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">f"Training loss: <span class="subst">&#123;running_loss/len(trainloader)&#125;</span>"</span>)</span><br></pre></td></tr></table></figure></li></ol><h2 id="Part-4-Fashion-MNIST-Exercises-ipynb"><a href="#Part-4-Fashion-MNIST-Exercises-ipynb" class="headerlink" title="Part 4 - Fashion-MNIST (Exercises).ipynb"></a>Part 4 - Fashion-MNIST (Exercises).ipynb</h2><p>使用pytorch对数据集Fashion-MNIST进行分类的练习, 有如下过程</p><ol><li>导入必要的库</li><li>导入数据集并格式化</li><li>定义网络结构</li><li>定义optimizer, loss函数等</li><li>开始训练, 分epoch和batch</li><li>前向传播后计算损失函数, 求梯度, 反向传播更新权重</li><li>训练结束, 输出正确率, 损失值等等</li></ol><p>完整代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> datasets, transforms</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define a transform to normalize the data</span></span><br><span class="line">transform = transforms.Compose([transforms.ToTensor(),</span><br><span class="line">                                transforms.Normalize((<span class="number">0.5</span>,), (<span class="number">0.5</span>,))])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download and load the training data</span></span><br><span class="line">trainset = datasets.FashionMNIST(<span class="string">'~/.pytorch/F_MNIST_data/'</span>, download=<span class="literal">True</span>, train=<span class="literal">True</span>, transform=transform)</span><br><span class="line">trainloader = torch.utils.data.DataLoader(trainset, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Download and load the test data</span></span><br><span class="line">testset = datasets.FashionMNIST(<span class="string">'~/.pytorch/F_MNIST_data/'</span>, download=<span class="literal">True</span>, train=<span class="literal">False</span>, transform=transform)</span><br><span class="line">testloader = torch.utils.data.DataLoader(testset, batch_size=<span class="number">64</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义网络结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFashionMnist</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    super().__init__()</span><br><span class="line">    self.fc1 = nn.Linear(<span class="number">784</span>, <span class="number">256</span>)</span><br><span class="line">    self.fc2 = nn.Linear(<span class="number">256</span>, <span class="number">64</span>)</span><br><span class="line">    self.fc3 = nn.Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    x = x.view(<span class="number">-1</span>, <span class="number">784</span>)</span><br><span class="line">    x = F.relu(self.fc1(x))</span><br><span class="line">    x = F.relu(self.fc2(x))</span><br><span class="line">    x = F.log_softmax(self.fc3(x))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  </span><br><span class="line">model = MyFashionMnist()</span><br><span class="line"></span><br><span class="line">optimizer = optim.Adam(model.parameters(), lr=<span class="number">0.003</span>)</span><br><span class="line"></span><br><span class="line">criterion = nn.NLLLoss()</span><br><span class="line"></span><br><span class="line">epochs = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> range(epochs):</span><br><span class="line">  running_loss = <span class="number">0</span> <span class="comment"># 损失</span></span><br><span class="line">  <span class="keyword">for</span> images, labels <span class="keyword">in</span> trainloader:</span><br><span class="line">    output = model(images)</span><br><span class="line">    loss = criterion(output, labels)</span><br><span class="line">    </span><br><span class="line">    optimizer.zero_grad()</span><br><span class="line">    loss.backward()</span><br><span class="line">    optimizer.step()</span><br><span class="line">    </span><br><span class="line">    running_loss += loss.item()</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"loss: "</span>, running_loss / len(trainloader))</span><br><span class="line">    </span><br><span class="line">sum = correct = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用测试集测试正确率</span></span><br><span class="line"><span class="keyword">for</span> images, labels <span class="keyword">in</span> testloader:</span><br><span class="line">  output = torch.exp(model(images))</span><br><span class="line">  result = torch.argmax(output, dim=<span class="number">1</span>)</span><br><span class="line">  correct += (result == labels).sum()</span><br><span class="line">  sum += len(images)</span><br><span class="line">  </span><br><span class="line">print(<span class="string">"correct = "</span>, correct.item())</span><br><span class="line">print(<span class="string">"sum = "</span>, sum)</span><br><span class="line">print(<span class="string">"rate = &#123;&#125;"</span>.format(correct.item() / sum))</span><br></pre></td></tr></table></figure><p>写了一份基于keras的代码做对比, 过程是类似的. 相对而言keras更黑箱所以代码短一些</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> datasets, models, layers</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_LOG_LEVEL'</span>] = <span class="string">'2'</span></span><br><span class="line"></span><br><span class="line">(train_images, train_labels), (test_images, test_labels) = datasets.fashion_mnist.load_data()</span><br><span class="line">train_images = tf.reshape(train_images, [<span class="number">-1</span>, <span class="number">784</span>])</span><br><span class="line">test_images = tf.reshape(test_images, [<span class="number">-1</span>, <span class="number">784</span>])</span><br><span class="line"></span><br><span class="line">print(train_images.shape, train_labels.shape, test_images.shape, test_labels.shape)</span><br><span class="line"></span><br><span class="line">model = models.Sequential()</span><br><span class="line">model.add(layers.Dense(<span class="number">256</span>, activation=<span class="string">'relu'</span>, input_shape=(<span class="number">784</span>, )))</span><br><span class="line">model.add(layers.Dense(<span class="number">64</span>, activation=<span class="string">'relu'</span>))</span><br><span class="line">model.add(layers.Dense(<span class="number">10</span>, activation=<span class="string">'softmax'</span>))</span><br><span class="line">print(<span class="string">"model build!"</span>)</span><br><span class="line"></span><br><span class="line">model.compile(optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">              loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">              metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将训练集随机化</span></span><br><span class="line">idx = tf.range(len(train_images))</span><br><span class="line">idx = tf.random.shuffle(idx)</span><br><span class="line">print(idx)</span><br><span class="line">train_images = tf.gather(train_images, indices=idx)</span><br><span class="line"><span class="comment"># train_images = train_images[idx]</span></span><br><span class="line">train_labels = tf.gather(train_labels, indices=idx)</span><br><span class="line"><span class="comment"># train_labels = train_labels[idx]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将label转化成one hot</span></span><br><span class="line">train_labels = tf.one_hot(train_labels, depth=<span class="number">10</span>)</span><br><span class="line">test_labels = tf.one_hot(test_labels, depth=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分出训练集和验证集</span></span><br><span class="line">partial_x_train = train_images[<span class="number">3000</span>:]</span><br><span class="line">x_val = train_images[:<span class="number">3000</span>]</span><br><span class="line">partial_y_train = train_labels[<span class="number">3000</span>:]</span><br><span class="line">y_val = train_labels[:<span class="number">3000</span>]</span><br><span class="line"></span><br><span class="line">print(partial_x_train.shape, partial_y_train.shape, x_val.shape, y_val.shape)</span><br><span class="line"></span><br><span class="line">history = model.fit(partial_x_train,</span><br><span class="line">                    partial_y_train,</span><br><span class="line">                    epochs=<span class="number">20</span>,</span><br><span class="line">                    batch_size=<span class="number">64</span>,</span><br><span class="line">                    validation_data=(x_val, y_val))</span><br><span class="line"></span><br><span class="line">result = model.evaluate(test_images, test_labels)</span><br></pre></td></tr></table></figure><p>差别是:</p><ol><li>keras的训练起来要比pytorch快得多. 不知道是不是因为keras在gpu条件满足情况下自动调用了gpu, 而pytorch用的是cpu</li><li>准确率用pytorch写的反而要高, 这么一个简单的网络正确率达到了86%-87%, 而反观keras的, 在和pytorch的超参数差不多的情况下, 正确率只有70%左右. 设置其他的超参数才能稍高一些</li></ol><h2 id="Part-5-Inference-and-Validation-Exercises-ipynb"><a href="#Part-5-Inference-and-Validation-Exercises-ipynb" class="headerlink" title="Part 5 - Inference and Validation (Exercises).ipynb"></a>Part 5 - Inference and Validation (Exercises).ipynb</h2><ol><li><p>这部分主要讲验证, 比如用topk()来衡量正确</p><p> 但用topk()时总是出错, 所以后面改用argmax()了</p></li><li><p>介绍了dropout的使用, 可以明显地减少过拟合. 也就是训练时的损失和验证损失差不多, 但同时训练时正确率更低一些</p><p> dropout也真是玄学</p></li><li><p>定义了自己的带dropout层的网络</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## <span class="doctag">TODO:</span> Define your model with dropout added</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Classifier</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">784</span>, <span class="number">256</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">256</span>, <span class="number">128</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">128</span>, <span class="number">64</span>)</span><br><span class="line">        self.fc4 = nn.Linear(<span class="number">64</span>, <span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">        self.dropout = nn.Dropout(p=<span class="number">0.2</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># make sure input tensor is flattened</span></span><br><span class="line">        x = x.view(x.shape[<span class="number">0</span>], <span class="number">-1</span>)</span><br><span class="line">        </span><br><span class="line">        x = self.dropout(F.relu(self.fc1(x)))</span><br><span class="line">        x = self.dropout(F.relu(self.fc2(x)))</span><br><span class="line">        x = self.dropout(F.relu(self.fc3(x)))</span><br><span class="line">        x = F.log_softmax(self.fc4(x), dim=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></li><li><p>在训练时记录了各个时间点的损失, 所以用下面的代码可以轻松画出损失的变化值, 来判断是否发生过拟合</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">train_losses = torch.Tensor(train_losses) / len(trainloader)</span><br><span class="line">test_losses = torch.Tensor(test_losses) / len(testloader)</span><br><span class="line"></span><br><span class="line">plt.plot(train_losses.numpy(), label=<span class="string">'train_losses'</span>)</span><br><span class="line">plt.plot(test_losses.numpy(), label=<span class="string">'test_losses'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li>在验证时需要调用model.eval(), 避免验证进入dropout. 训练时要验证, 验证之后要用model.train()进入训练模式</li></ol><h2 id="Part-6-Saving-and-Loading-Models-ipynb"><a href="#Part-6-Saving-and-Loading-Models-ipynb" class="headerlink" title="Part 6 - Saving and Loading Models.ipynb"></a>Part 6 - Saving and Loading Models.ipynb</h2><p>这部分将如何保存和恢复模型, 因为这一节notebook运行较麻烦原因没有很认真去看…</p><h2 id="Part-7-Loading-Image-Data-Exercises-ipynb"><a href="#Part-7-Loading-Image-Data-Exercises-ipynb" class="headerlink" title="Part 7 - Loading Image Data (Exercises).ipynb"></a>Part 7 - Loading Image Data (Exercises).ipynb</h2><p>这部分讲如何从文件夹中加载数据集</p><ol><li><p>文件夹格式, 主文件夹下有多个子文件夹, 分别代表图片的类别. 可以在这两层文件夹之间加一层来区分训练集和测试集.</p></li><li><p>常规步骤:</p><ol><li><p>定义转化器transform(改变图片大小, 中心裁剪部分图片, 转化成tensor, 翻转图片等)</p></li><li><p>使用datasets.ImageFolder()方法加载数据集</p></li><li><p>使用torch.utils.data.DataLoader()方法得到生成器dataloader</p><p>代码实现:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data_dir = <span class="string">'Cat_Dog_data/train'</span></span><br><span class="line"></span><br><span class="line">transform = transforms.Compose([transforms.Resize(<span class="number">255</span>),</span><br><span class="line">                               transforms.CenterCrop(<span class="number">224</span>),</span><br><span class="line">                               transforms.ToTensor()])</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> compose transforms here</span></span><br><span class="line">dataset = datasets.ImageFolder(data_dir, transform=transform)</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> create the ImageFolder</span></span><br><span class="line">dataloader = torch.utils.data.DataLoader(dataset, batch_size=<span class="number">32</span>, shuffle=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> use the ImageFolder dataset to create the DataLoader</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><ol start="3"><li>最后一部分是用之前所学网络结构实现猫狗分类(老师说很可能不成功, 因为之前只学了full connection net, 且只训练过MNIST这种简单的数据集, 像这种彩色的, 大图片的分类, 那些简单的网络可能效果非常不好, 所以我没尝试)</li></ol><h2 id="Part-8-Transfer-Learning-Exercises-ipynb"><a href="#Part-8-Transfer-Learning-Exercises-ipynb" class="headerlink" title="Part 8 - Transfer Learning (Exercises).ipynb"></a>Part 8 - Transfer Learning (Exercises).ipynb</h2><ol><li><p>这部分讲的是迁移学习, 用别人预训练好的模型就可以做好多很厉害的东西啦. 样例使用的是densenet121, 分为feature和classifier部分, 我们需要改动的是classifier部分, 从开始的ImageNet输出1000类改成2类的分类器(猫狗分类). 直观上, 感觉像是那很复杂很复杂的feature部分是将图片的特征提取出来了, 作为一个1024长度的向量是输入, 然后我们再用之前学过的知识对这个输入进行分类???</p></li><li><p>自定义classifier, 看着有点怪, 不像之前自己定义的网络</p> <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Freeze parameters so we don't backprop through them</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> model.parameters():</span><br><span class="line">    param.requires_grad = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line">classifier = nn.Sequential(OrderedDict([</span><br><span class="line">                          (<span class="string">'fc1'</span>, nn.Linear(<span class="number">1024</span>, <span class="number">500</span>)),</span><br><span class="line">                          (<span class="string">'relu'</span>, nn.ReLU()),</span><br><span class="line">                          (<span class="string">'fc2'</span>, nn.Linear(<span class="number">500</span>, <span class="number">2</span>)),</span><br><span class="line">                          (<span class="string">'output'</span>, nn.LogSoftmax(dim=<span class="number">1</span>))</span><br><span class="line">                          ]))</span><br><span class="line">    </span><br><span class="line">model.classifier = classifier</span><br></pre></td></tr></table></figure><ol start="3"><li>最后有一个自己使用预训练模型进行猫狗分类的练习, 我自己做出来正确率居然是51%(嗯, 不错, 对了一半…). 视频里讲的跟我差不多的方法是95+%的正确率. 我果然太天真. </li><li>不过过程就是这样了, 从torchvision.models加载某一预训练模型, 然后查看他的网络结构, 修改最后一部分(分类器), 注意freeze网络参数. 然后开始使用gpu训练(据比较gpu和cpu的训练速度是几百倍的差别, 然而在colab上进行训练即使是一个epoch也要训练几分钟的…), 这部分和普通的网络训练一样, 最后是测试(或者将验证部分嵌入到训练部分, 在训练过程中不断获悉正确率)</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用迁移学习进行花的分类 - github项目介绍</title>
      <link href="/2019/08/05/li-yong-qian-yi-xue-xi-jin-xing-hua-de-fen-lei-github-xiang-mu-jie-shao/"/>
      <url>/2019/08/05/li-yong-qian-yi-xue-xi-jin-xing-hua-de-fen-lei-github-xiang-mu-jie-shao/</url>
      
        <content type="html"><![CDATA[<p>前几天写了个小项目, 利用深度学习里的迁移学习方法做花的分类, 下面是项目的github地址.<br><a href="https://github.com/JameyWoo/transfer-learning" target="_blank" rel="noopener">https://github.com/JameyWoo/transfer-learning</a></p><p>感兴趣的同学可以了解一下, 源码比较简单, 下面是项目的说明</p><hr><h1 id="transfer-learning"><a href="#transfer-learning" class="headerlink" title="transfer learning"></a>transfer learning</h1><p>@ author 姬小野</p><p>— 迁移学习对五种花分类</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>ubuntu 18.04</p><h2 id="requirements"><a href="#requirements" class="headerlink" title="requirements"></a>requirements</h2><ol><li>torch==1.1.0</li><li>numpy==1.17.0</li><li>torchvision==0.3.0</li></ol><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h3><p>下载vgg的预训练模型<br><code>download.pytorch.org/models/vgg16-397923af.pth</code>放到目录<code>/home/jamey/.cache/torch/checkpoints</code>下<br>执行<br><code>python train.py</code> </p><p>即可在当前目录下训练自己的模型</p><p>ps. 在普通笔记本上生成模型的时间较久</p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>执行</p><p><code>python test.py</code></p><p>即可测试模型对花分类的准确率</p><p>当epoch为3时, 模型的准确率达到了83%, 其中, 除roses外准确率都极高. (大多数错误都是由roses引起的)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Test Accuracy of daisy: 84% (78/92)</span><br><span class="line">Test Accuracy of dandelion: 94% (125/132)</span><br><span class="line">Test Accuracy of roses: 59% (54/91)</span><br><span class="line">Test Accuracy of sunflowers: 85% (86/101)</span><br><span class="line">Test Accuracy of tulips: 87% (108/124)</span><br><span class="line"></span><br><span class="line">Test Accuracy (Overall): 83% (451/540)</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>对一张图片进行分类</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----------------usage----------------</span><br><span class="line">    run the demo with:</span><br><span class="line">    python demo.py -m model_name -i image_name.jpg</span><br><span class="line">    python demo.py --image image_name.jpg</span><br><span class="line">    python demo.py -i image_name.jpg</span><br><span class="line">    or use `python demo.py -h` to get <span class="built_in">help</span></span><br><span class="line">    -----------------end-----------------</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="demo-1"><a href="#demo-1" class="headerlink" title="demo 1"></a>demo 1</h3><p><img src="/images/20190805_1.png" alt></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python demo.py -m my_vgg16_3epochs.pth -i image/yvjingxiang_1.png</span><br><span class="line">郁金香</span><br></pre></td></tr></table></figure><p>demo.py 的输出结果是图片的识别的花的中文名</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java连接mysql数据库(jdbc增删改查)</title>
      <link href="/2019/07/10/java-lian-jie-mysql-shu-ju-ku-jdbc-zeng-shan-gai-cha/"/>
      <url>/2019/07/10/java-lian-jie-mysql-shu-ju-ku-jdbc-zeng-shan-gai-cha/</url>
      
        <content type="html"><![CDATA[<p>刚学java连接数据库, 放一个代码实例, 以作参考</p><p>由于是学习测试用, 因此代码并不规范, 并没有将增删改查等操作写在单独的函数里, 整个90+行的代码只有一个函数. 不过代码中有很多清晰的注释</p><p><a href="https://www.runoob.com/java/java-mysql-connect.html" target="_blank" rel="noopener">菜鸟的教程写的非常好</a></p><p>经过这次学习, 了解到了以下几点</p><ol><li>在java中设置数据表的字符集, 使其支持中文</li><li>很多异常捕获, 这是以前写代码很少见得</li><li>了解了很多sql语句在java中调用要使用的方法</li></ol><p>数据库的表目录是(id, name, major)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 姬小野</span></span><br><span class="line"><span class="comment"> * 2019/7/9 下午9:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZenShanGaiCha</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 据说这样能读中文?</span></span><br><span class="line">    <span class="keyword">static</span> String url = <span class="string">"jdbc:mysql://localhost:3306/studydb?useUnicode=true&amp;characterEncoding=utf8"</span>;</span><br><span class="line">    <span class="keyword">static</span> String user = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> String password = <span class="string">"fiveplus"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">            System.out.println(<span class="string">"数据库加载成功"</span>);</span><br><span class="line"></span><br><span class="line">            con = DriverManager.getConnection(url, user, password);</span><br><span class="line">            System.out.println(<span class="string">"数据库连接成功"</span>);</span><br><span class="line"></span><br><span class="line">            stmt = con.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成(学号, 名字, 专业)的虚拟数据</span></span><br><span class="line">            List ids = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;String&gt; majors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            String[] all_names = &#123;<span class="string">"赵"</span>, <span class="string">"钱"</span>, <span class="string">"孙"</span>, <span class="string">"李"</span>, <span class="string">"周"</span>, <span class="string">"吴"</span>, <span class="string">"郑"</span>, <span class="string">"王"</span>&#125;;</span><br><span class="line">            String[] all_majors = &#123;<span class="string">"计科"</span>, <span class="string">"软件"</span>, <span class="string">"信安"</span>, <span class="string">"通信"</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">                ids.add(i * <span class="number">12345</span> % <span class="number">1000</span>);</span><br><span class="line">                names.add(all_names[(<span class="number">11</span>*i + <span class="number">7</span>) % <span class="number">8</span>] + all_names[(i*<span class="number">123</span>) % <span class="number">8</span>] + all_names[(i*<span class="number">111</span> / <span class="number">3</span>) % <span class="number">8</span>]);</span><br><span class="line">                majors.add(all_majors[i*<span class="number">2357</span> % <span class="number">4</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ids.size(); ++i) &#123;</span><br><span class="line">                System.out.println(ids.get(i) + <span class="string">", "</span> + names.get(i) + <span class="string">", "</span> + majors.get(i));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String sql;</span><br><span class="line">            ResultSet res;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 首先删除数据表的所有行, 权当是做一个初始化</span></span><br><span class="line">            sql = <span class="string">"delete from student"</span>;</span><br><span class="line">            stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 增操作</span></span><br><span class="line">            <span class="comment">// sql = "insert into student values(3, \"名字\", \"major\")"; // 一条测试的语句, 测试中文</span></span><br><span class="line">            <span class="comment">// 用这条语句来设置数据库使用utf-8, 设置一次就好</span></span><br><span class="line">            <span class="comment">// stmt.executeUpdate("set character_set_database=\"utf8\"");</span></span><br><span class="line">            <span class="comment">// int count = stmt.executeUpdate(sql);</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ids.size(); ++i) &#123;</span><br><span class="line">                sql = <span class="string">"insert into student values(\'"</span> + ids.get(i) + <span class="string">"\', \'"</span></span><br><span class="line">                        + names.get(i) + <span class="string">"\', \'"</span> + majors.get(i) + <span class="string">"\');"</span>;</span><br><span class="line">                System.out.println(sql);</span><br><span class="line">                <span class="keyword">int</span> count = stmt.executeUpdate(sql);</span><br><span class="line">                System.out.println(<span class="string">"插入"</span> + count + <span class="string">"条数据"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 删除操作, 删除指定姓的行</span></span><br><span class="line">            sql = <span class="string">"delete from student where name like \"孙%\""</span>; <span class="comment">// 通配符删除孙姓的行</span></span><br><span class="line">            stmt.executeUpdate(sql);  <span class="comment">// 接下来查看数据表的话, 会发现姓孙的行已经没有了</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 改操作(更新)</span></span><br><span class="line">            <span class="comment">// 我们假设信安合并进入了计科, 下面在数据库中操作. 用即可表示新的计科</span></span><br><span class="line">            sql = <span class="string">"update student set major = \'即可\' where major = \'信安\'"</span>;</span><br><span class="line">            stmt.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查操作, 查一下id在(100, 500) 以外的行</span></span><br><span class="line">            sql = <span class="string">"select * from student where not id between 100 and 500"</span>;</span><br><span class="line">            res = stmt.executeQuery(sql);</span><br><span class="line">            System.out.println(<span class="string">"当前数据库数据:"</span>);</span><br><span class="line">            <span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">                <span class="keyword">int</span> id = res.getInt(<span class="string">"id"</span>);</span><br><span class="line">                String name = res.getString(<span class="string">"name"</span>);</span><br><span class="line">                String major = res.getString(<span class="string">"major"</span>);</span><br><span class="line">                System.out.println(<span class="string">"id: "</span> + id + <span class="string">", name: "</span> + name + <span class="string">", major: "</span> + major);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 统统关闭</span></span><br><span class="line">            res.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            con.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA及其他开发工具日常使用指南</title>
      <link href="/2019/07/08/idea-ji-qi-ta-kai-fa-gong-ju-ri-chang-shi-yong-zhi-nan/"/>
      <url>/2019/07/08/idea-ji-qi-ta-kai-fa-gong-ju-ri-chang-shi-yong-zhi-nan/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引入依赖包"><a href="#1-引入依赖包" class="headerlink" title="1. 引入依赖包"></a>1. 引入依赖包</h2><p>通过如图所示的路径添加tar文件, 即可引入外部包.<br><img src="/images/20190708_1.png" alt></p><h2 id="2-单独运行一个java文件"><a href="#2-单独运行一个java文件" class="headerlink" title="2. 单独运行一个java文件"></a>2. 单独运行一个java文件</h2><p>在java文件上右键, 如果你写好了main函数就可以编译运行. 之前由于不熟悉java, 所以main的参数没有写<code>String[] args</code>, 所以一直无法运行.<br><img src="/images/20190708_2.png" alt></p><h2 id="3-修改class的模板"><a href="#3-修改class的模板" class="headerlink" title="3. 修改class的模板"></a>3. 修改class的模板</h2><p>如加入作者, 时间等信息<br><img src="/images/20190708_3.png" alt></p><h2 id="4-生成javadoc"><a href="#4-生成javadoc" class="headerlink" title="4. 生成javadoc"></a>4. 生成javadoc</h2><p>刚学java, 知道了这个工具觉得好神奇啊, 居然这么方便开发者.<br><img src="/images/20190708_4.png" alt><br>效果如图<br><img src="/images/20190708_5.png" alt><br>不过在我的电脑上, 用jdk11生成不了, 得换成jdk8.</p><h2 id="5-git版本控制"><a href="#5-git版本控制" class="headerlink" title="5. git版本控制"></a>5. git版本控制</h2><p>在idea上进行版本控制很方便<br>在vcs这一栏开启之后就可以用git了.<br>有比较友好的图形操作界面.<br><img src="/images/20190708_6.png" alt><br><img src="/images/20190708_7.png" alt></p><h2 id="6-操作数据库"><a href="#6-操作数据库" class="headerlink" title="6. 操作数据库"></a>6. 操作数据库</h2><p>在view这一栏找到工具, 配置好数据库就可以连接了.<br><img src="/images/20190708_8.png" alt><br>然后在窗口上写sql语言, 下面的console就出现结果<br><img src="/images/20190708_9.png" alt></p><h2 id="7-ctrl-点击-可跳转到类的实现处"><a href="#7-ctrl-点击-可跳转到类的实现处" class="headerlink" title="7. ctrl + 点击 可跳转到类的实现处"></a>7. ctrl + 点击 可跳转到类的实现处</h2><h2 id="8-设置终端"><a href="#8-设置终端" class="headerlink" title="8. 设置终端"></a>8. 设置终端</h2><p>cmd真难受, 换成powershell好用多了<br><img src="/images/20190708_10.png" alt></p><h2 id="9-设置代理"><a href="#9-设置代理" class="headerlink" title="9. 设置代理"></a>9. 设置代理</h2><p>应该就不用每次都在代码里面弄了, scrapy配置socks真是麻烦死了啊.<br><img src="/images/20190708_11.png" alt></p><h2 id="10-格式化html"><a href="#10-格式化html" class="headerlink" title="10. 格式化html"></a>10. 格式化html</h2><p>原先<br><img src="/images/20190708_12.png" alt><br><code>Code-&gt;Reformat Code</code> 快捷键 <code>Ctrl+Alt+L</code><br><img src="/images/20190708_13.png" alt></p><h2 id="11-Sphinx-自动生成python文档"><a href="#11-Sphinx-自动生成python文档" class="headerlink" title="11. Sphinx 自动生成python文档"></a>11. Sphinx 自动生成python文档</h2><p><a href="http://www.sphinx-doc.org/en/master/#confval-language" target="_blank" rel="noopener">官网: http://www.sphinx-doc.org/en/master/#confval-language</a></p><p><a href="https://github.com/readthedocs/sphinx_rtd_theme" target="_blank" rel="noopener">sphinx_rtd_theme 主题github</a></p><p><a href="https://www.jianshu.com/p/d4a1347f467b" target="_blank" rel="noopener">简书上的好教程</a></p><p>效果<br><img src="/images/20190708_14.png" alt><br><img src="/images/20190708_15.png" alt></p><p>安装<br><code>pip install sphinx</code><br><code>mkdir doc_test</code><br><code>cd doc_test</code><br>执行<code>sphinx-quickstart</code><br>下面是配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\姬小野\PycharmProjects\get_nlp_data\doc_test&gt; sphinx-quickstart</span><br><span class="line">Welcome to the Sphinx 2.1.2 quickstart utility.</span><br><span class="line"></span><br><span class="line">Please enter values for the following settings (just press Enter to</span><br><span class="line">accept a default value, if one is given in brackets).</span><br><span class="line"></span><br><span class="line">Selected root path: .</span><br><span class="line"></span><br><span class="line">You have two options for placing the build directory for Sphinx output.</span><br><span class="line">Either, you use a directory &quot;_build&quot; within the root path, or you separate</span><br><span class="line">&quot;source&quot; and &quot;build&quot; directories within the root path.</span><br><span class="line">&gt; Separate source and build directories (y/n) [n]: n</span><br><span class="line"></span><br><span class="line">The project name will occur in several places in the built documentation.</span><br><span class="line">&gt; Project name: NLP_Books</span><br><span class="line">&gt; Author name(s): Jamey</span><br><span class="line">&gt; Project release []: v0.6</span><br><span class="line"></span><br><span class="line">If the documents are to be written in a language other than English,</span><br><span class="line">you can select a language here by its language code. Sphinx will then</span><br><span class="line">translate text that it generates into that language.</span><br><span class="line"></span><br><span class="line">For a list of supported codes, see</span><br><span class="line">https://www.sphinx-doc.org/en/master/usage/configuration.html#confval-language.</span><br><span class="line">&gt; Project language [en]: zh_cn</span><br><span class="line"></span><br><span class="line">Creating file .\conf.py.</span><br><span class="line">Creating file .\index.rst.</span><br><span class="line">Creating file .\Makefile.</span><br><span class="line">Creating file .\make.bat.</span><br><span class="line"></span><br><span class="line">Finished: An initial directory structure has been created.</span><br><span class="line"></span><br><span class="line">You should now populate your master file .\index.rst and create other documentation</span><br><span class="line">source files. Use the Makefile to build the docs, like so:</span><br><span class="line">   make builder</span><br><span class="line">where &quot;builder&quot; is one of the supported builders, e.g. html, latex or linkcheck.</span><br><span class="line"></span><br><span class="line">PS C:\Users\姬小野\PycharmProjects\get_nlp_data\doc_test&gt;</span><br></pre></td></tr></table></figure><p>找到conf.py, 取消注释, 路径改成自己项目路径<br><img src="/images/20190708_16.png" alt><br>修改extensions为如下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extensions = [</span><br><span class="line">    <span class="string">'sphinx.ext.autodoc'</span>,</span><br><span class="line">    <span class="string">'sphinx.ext.todo'</span>,</span><br><span class="line">    <span class="string">'sphinx.ext.viewcode'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>执行<br> <code>sphinx-apidoc -o ./source ../</code><br> 其中 <code>./source</code> 为rst文件所在目录</p><p>使用<code>make</code> 查看可用的make命令<br>这里我们<code>make html</code></p><h2 id="12-使用read-the-Doc-托管文档"><a href="#12-使用read-the-Doc-托管文档" class="headerlink" title="12. 使用read the Doc 托管文档"></a>12. 使用read the Doc 托管文档</h2><p>看这网站logo, 难道大多数python包的文档都是托管到这的?<br><img src="/images/20190708_17.png" alt></p><h2 id="13-IDEA补全快捷键"><a href="#13-IDEA补全快捷键" class="headerlink" title="13. IDEA补全快捷键"></a>13. IDEA补全快捷键</h2><h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1. for循环"></a>1. for循环</h3><p>打一个for循环, 些fori, 然后回车, 马上就有<br><img src="/images/20190708_18.png" alt></p><h3 id="2-main函数补全"><a href="#2-main函数补全" class="headerlink" title="2. main函数补全"></a>2. main函数补全</h3><p>输入psvm然后回车<br><img src="/images/20190708_19.png" alt></p><h3 id="3-System-out-println"><a href="#3-System-out-println" class="headerlink" title="3.System.out.println();"></a>3.System.out.println();</h3><p>输入sout, 回车<br><img src="/images/20190708_20.png" alt></p><h3 id="4-按ctrl-j查看所有代码生成"><a href="#4-按ctrl-j查看所有代码生成" class="headerlink" title="4. 按ctrl+j查看所有代码生成"></a>4. 按ctrl+j查看所有代码生成</h3><p><img src="/images/20190708_21.png" alt><br><a href="https://juejin.im/entry/5a0eaf38f265da431955d9a6" target="_blank" rel="noopener">参考: https://juejin.im/entry/5a0eaf38f265da431955d9a6</a></p><h3 id="5-自定义自己的快捷键"><a href="#5-自定义自己的快捷键" class="headerlink" title="5. 自定义自己的快捷键"></a>5. 自定义自己的快捷键</h3><p><img src="/images/20190708_22.png" alt><br><a href="https://blog.csdn.net/qq_27093465/article/details/52691572" target="_blank" rel="noopener">https://blog.csdn.net/qq_27093465/article/details/52691572</a></p><h3 id="6-技能表"><a href="#6-技能表" class="headerlink" title="6. 技能表"></a>6. 技能表</h3><p><a href="https://www.cnblogs.com/jx17/p/6244491.html" target="_blank" rel="noopener">https://www.cnblogs.com/jx17/p/6244491.html</a></p><h2 id="14-使用mkdocs生成快速文档"><a href="#14-使用mkdocs生成快速文档" class="headerlink" title="14. 使用mkdocs生成快速文档"></a>14. 使用mkdocs生成快速文档</h2><p>mkdocs能够根据markdown快速生成文档网站, 然后部署在github page上, 这样可以给每个项目都部署一个文档网站了<br><a href="https://fiveplus.top/hello-world/">比如这个文档页面, 就是我用来测试mkdocs效果的页面</a><br>效果如图<br><img src="/images/20190708_23.png" alt><br><img src="/images/20190708_24.png" alt><br>可以方便地更换各种主题</p><p>甚至可以单独把它作为一个博客网站来玩</p><p>输入命令<code>mkdocs -h</code> 即可查看他的功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(torch)$  mkdocs -h</span><br><span class="line">Usage: mkdocs [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">  MkDocs - Project documentation with Markdown.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -V, --version  Show the version and <span class="built_in">exit</span>.</span><br><span class="line">  -q, --quiet    Silence warnings</span><br><span class="line">  -v, --verbose  Enable verbose output</span><br><span class="line">  -h, --<span class="built_in">help</span>     Show this message and <span class="built_in">exit</span>.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  build      Build the MkDocs documentation</span><br><span class="line">  gh-deploy  Deploy your documentation to GitHub Pages</span><br><span class="line">  new        Create a new MkDocs project</span><br><span class="line">  serve      Run the <span class="built_in">builtin</span> development server</span><br></pre></td></tr></table></figure><h2 id="15-github-gist"><a href="#15-github-gist" class="headerlink" title="15. github gist"></a>15. github gist</h2><p>代码片段管理服务</p><p>今天偶然知道了github还提供这样一个服务, 之前知道贴代码可以用Pastebin.</p><p>简而言之就是大家可以把自己的代码片段贴上去, 然后分享.  支持匿名, 私密, markdown等.<br><img src="/images/20190708_25.png" alt></p><p>而且我突然发现之前我colab上有一个选项保存到github gist上就是这个! 恍然大悟.<br><img src="/images/20190708_26.png" alt><br>在gist链接后面加一个<code>.pibb</code>后缀, 直接将这部分内容变成一个干净的html网页了.</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>darknet--目标检测开源库学习记录</title>
      <link href="/2019/06/28/darknet-mu-biao-jian-ce-kai-yuan-ku-xue-xi-ji-lu/"/>
      <url>/2019/06/28/darknet-mu-biao-jian-ce-kai-yuan-ku-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-效果展示"><a href="#1-效果展示" class="headerlink" title="1. 效果展示"></a>1. 效果展示</h2><p><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">官网链接</a></p><p>darknet 实现了c语言版本的yolo v3, 不依赖任何其他库. 因此安装非常简单.</p><p>效果图:<br><img src="/images/20190628_1.png" alt><br><img src="/images/20190628_2.png" alt><br><img src="/images/20190628_3.png" alt></p><hr><h2 id="2-安装方法"><a href="#2-安装方法" class="headerlink" title="2. 安装方法"></a>2. 安装方法</h2><p>如何安装?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/pjreddie/darknet</span><br><span class="line"><span class="built_in">cd</span> darknet</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>然后下载yolov3权重, 放到darknet根目录下<br><code>wget https://pjreddie.com/media/files/yolov3.weights</code></p><p>执行命令<code>./darknet detector test cfg/coco.data cfg/yolov3.cfg yolov3.weights data/dog.jpg</code> 测试一下效果, 生成的图片保存在darknet根目录下</p><hr><h2 id="3-常用命令"><a href="#3-常用命令" class="headerlink" title="3. 常用命令"></a>3. 常用命令</h2><p>以下是几个常用的检测命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 调用摄像头进行目标检测</span><br><span class="line">./darknet detector demo cfg/coco.data cfg/yolov3.cfg yolov3.weights</span><br><span class="line"></span><br><span class="line"># 对视频进行目标检测</span><br><span class="line">./darknet detector demo cfg/coco.data cfg/yolov3.cfg yolov3.weights &lt;video_file&gt;</span><br><span class="line"></span><br><span class="line"># 检测单独的一张图片</span><br><span class="line">./darknet detect cfg/yolov3.cfg yolov3.weights data/dog.jpg</span><br><span class="line"></span><br><span class="line"># 设置阈值的检测</span><br><span class="line">./darknet detect cfg/yolov3.cfg yolov3.weights data/dog.jpg -thresh 0</span><br><span class="line"></span><br><span class="line"># 对多张图片的检测, 输入命令后, 输入图片路径</span><br><span class="line">./darknet detect cfg/yolov3.cfg yolov3.weights</span><br><span class="line"></span><br><span class="line"># 指定摄像头设备, 加参数 -c</span><br><span class="line">./darknet detector demo cfg/coco.data cfg/yolov3.cfg yolov3.weights -c 1</span><br></pre></td></tr></table></figure><hr><h2 id="4-GPU加速"><a href="#4-GPU加速" class="headerlink" title="4. GPU加速"></a>4. GPU加速</h2><p>用CPU进行测试非常的慢, 下面是官网的描述, 一张图10s(在我的电脑上还不止)<br><img src="/images/20190628_4.png" alt></p><p>使用GPU可以大幅提高速度, 提升有多少呢? 在我的Geforce 940MX 辣鸡显卡上, 都可以实现比较卡顿的摄像头目标检测了! 如果是高性能的显卡, 想必会非常流畅(羡慕)</p><p>当然, 用GPU是需要安装好cuda的. 我用的是cuda 10.0</p><p>如何开启GPU模式? 修改makefile, GPU=0 改成GPU=1, 然后重新make.<br><img src="/images/20190628_5.png" alt></p><hr><h2 id="5-安装opencv"><a href="#5-安装opencv" class="headerlink" title="5. 安装opencv"></a>5. 安装opencv</h2><p>建议安装C++版本的opencv, 安装好了同样是改成OPENCV=1.  (因为装了opencv他才会在屏幕上显示出检测的结果)</p><p><a href="https://blog.csdn.net/cocoaqin/article/details/78163171" target="_blank" rel="noopener">如何在ubuntu 18.04 上安装opencv 3.4.6 ? 看这篇教程, 亲测有效. 除了后期有一丁点的不同基本顺利安装.</a></p><hr><h2 id="6-几点小提示"><a href="#6-几点小提示" class="headerlink" title="6. 几点小提示"></a>6. 几点小提示</h2><p>查看<code>./cfg/yolov3.cfg</code> 文件, 有两种模式, 根据自己的实际需要进行注释. 比如说我们做测试, 就改成testing模式.<br><img src="/images/20190628_6.png" alt><br>如果GPU太垃圾(比如我), 一测试就报显存溢出错误, 可以设置下面的width 和 height, 将它设小一点就可以了.<br><img src="/images/20190628_7.png" alt></p><hr><h2 id="7-使用网络摄像头-手机-之一"><a href="#7-使用网络摄像头-手机-之一" class="headerlink" title="7. 使用网络摄像头(手机)之一"></a>7. 使用网络摄像头(手机)之一</h2><p>使用网络摄像头, 用手机作为外接摄像头而不只是笔记本的摄像头来做目标检测, 下面是效果图.</p><p><img src="/images/20190628_8.png" alt><br>我使用的是Droidcam ip摄像头</p><p>手机需要下载Droidcam app, 可以直接在google play上下载</p><p><a href="http://www.dev47apps.com/" target="_blank" rel="noopener">官网: http://www.dev47apps.com/</a></p><p><a href="https://www.freeyourdesktop.com/2018/10/need-a-webcam-in-ubuntu-no-problem-thanks-to-android/" target="_blank" rel="noopener">以及一篇非常好的安装教程</a></p><p>ubuntu 18.04 (linux)下的安装方法是<br>复制下面这段代码做一个bash脚本, 然后执行它.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /tmp/</span><br><span class="line">sudo apt-get install linux-headers-`uname -r`</span><br><span class="line">bits=`getconf LONG_BIT`</span><br><span class="line">wget https://www.dev47apps.com/files/600/droidcam-<span class="variable">$&#123;bits&#125;</span>bit.tar.bz2</span><br><span class="line">[[ <span class="variable">$&#123;bits&#125;</span> -eq 32 ]] &amp;&amp; checksum=90cd43b4745c51cffedc352090912eb1</span><br><span class="line">[[ <span class="variable">$&#123;bits&#125;</span> -eq 64 ]] &amp;&amp; checksum=9507c0b738f427c5f1dde7b2a364fdfb</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;checksum&#125;</span>  droidcam-<span class="variable">$&#123;bits&#125;</span>bit.tar.bz2"</span> | md5sum -c --</span><br><span class="line"><span class="comment"># OK?</span></span><br><span class="line">tar xjf droidcam-<span class="variable">$&#123;bits&#125;</span>bit.tar.bz2</span><br><span class="line"><span class="built_in">cd</span> droidcam-<span class="variable">$&#123;bits&#125;</span>bit/</span><br><span class="line">sudo ./install</span><br></pre></td></tr></table></figure><p>建立启动器<br><code>gedit ~/.local/share/applications/droidcam.desktop</code><br>拷贝下面的代码进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Version=1.0</span><br><span class="line">Type=Application</span><br><span class="line">Terminal=false</span><br><span class="line">Name=DroidCam</span><br><span class="line">Exec=droidcam</span><br><span class="line">Comment=Use your Android phone as a wireless webcam or an IP Cam!</span><br><span class="line">Icon=droidcam</span><br><span class="line">Categories=GNOME;GTK;Video;</span><br><span class="line">Name[it]=droidcam</span><br></pre></td></tr></table></figure><p>就可以找到图形程序的图标</p><p>然后就可以使用wifi连接手机上的摄像头. 也可以用usb连接的方式.<br><img src="/images/20190628_9.png" alt></p><hr><p>用命令<code>ls /dev/video*</code> 查看电脑上的摄像头设备. 目前有两个. 这个video1就是ip摄像头了.<br><img src="/images/20190628_10.png" alt><br>在使用darknet的时候, 在后面加参数<code>-c 1</code> 就可以指定摄像头设备了.</p><p>比如<code>./darknet detector demo cfg/coco.data cfg/yolov3.cfg yolov3.weights -c 1</code></p><hr><h2 id="8-使用网络摄像头-手机-之二"><a href="#8-使用网络摄像头-手机-之二" class="headerlink" title="8. 使用网络摄像头(手机)之二"></a>8. 使用网络摄像头(手机)之二</h2><p>但如果用ip摄像头的话, 一来比较卡顿, 二来如果在外面没有wifi怎么办呢? 那么用usb就是个更好的选择. 参考这篇文章弄好了usb摄像头<br><a href="https://xpenxpen.iteye.com/blog/2182397" target="_blank" rel="noopener">https://xpenxpen.iteye.com/blog/2182397</a></p><p>安装adb <code>sudo apt-get install adb</code></p><p>查看设备<code>adb devices</code></p><p>输入<code>adb forward tcp:4747 tcp:4747</code> 启用摄像头 (改成自己的端口)</p><p>手机打开开发者模式, 进开发者选项把usb调试打开</p><p>客户端开启usb模式</p><p><img src="/images/20190628_11.png" alt></p><hr><h2 id="9-保存检测视频到本地"><a href="#9-保存检测视频到本地" class="headerlink" title="9. 保存检测视频到本地"></a>9. 保存检测视频到本地</h2><p>darknet官方似乎并没有一个简单的参数可以将检测的视频保存在本地, 找了好多文章后终于找到一个靠谱的方法. </p><p><a href="https://github.com/pjreddie/darknet/issues/1235" target="_blank" rel="noopener">来源链接</a></p><p><img src="/images/20190628_12.png" alt></p><p>思路是, darknet提供了一种参数, -prefix, 可以将视频检测的结果输出为一系列的图片. 我们将这些图片保存在tmp文件夹, 然后使用视频转化工具ffmpeg 将这一系列的图片转化为视频.</p><p>下面是修改了的bash脚本, 保存为run.sh</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">./darknet detector demo cfg/coco.data cfg/yolov3.cfg yolov3.weights $<span class="number">1</span> -prefix ./tmp/pictures</span><br><span class="line">ffmpeg -i ./tmp/pictures_%<span class="number">08</span>d.jpg $<span class="number">2</span></span><br><span class="line"></span><br><span class="line">rm ./tmp/pictures_*.jpg</span><br></pre></td></tr></table></figure><p>我稍微修改了github issue上的脚本, 使得我们可以指定输入和输出的文件.<br>执行这条命令就可以保存视频了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./run.sh ./data/<span class="built_in">test</span>-5.mp4 ./outputfiles/<span class="built_in">test</span>-5.mp4</span><br></pre></td></tr></table></figure><p>调用摄像头然后保存的话, 也稍微修改一下脚本就好了</p><hr><p>perfect</p>]]></content>
      
      
      <categories>
          
          <category> 计算机视觉 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 开源库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用face_recognition进行人脸特征检测</title>
      <link href="/2019/06/26/shi-yong-face-recognition-jin-xing-ren-lian-te-zheng-jian-ce/"/>
      <url>/2019/06/26/shi-yong-face-recognition-jin-xing-ren-lian-te-zheng-jian-ce/</url>
      
        <content type="html"><![CDATA[<p>效果图<br><img src="/images/20190626_1.png" alt><br>调用face_recognition.face_landmarks()方法即可得到人脸特征点, 返回一个字典, 下图是返回的数据, 包括chin(下巴), left_eye(左眼)等.<br><img src="/images/20190626_2.png" alt><br>我画了两种图, 一种是遍历所有的点, 直接给点画图的图(点用实心圆绘制). 第二个是单独画下巴, 连成线, 用的是polylines方法.</p><p>我是4.10版本的opencv. 查阅官方py文档, <a href="https://docs.opencv.org/4.1.0/dc/da5/tutorial_py_drawing_functions.html" target="_blank" rel="noopener">这是链接</a><br><img src="/images/20190626_3.png" alt><br>完整代码:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">image = face_recognition.load_image_file(<span class="string">"./data/奥巴马.png"</span>)</span><br><span class="line">image2 = image.copy()</span><br><span class="line">face_landmarks_list = face_recognition.face_landmarks(image)</span><br><span class="line"><span class="comment"># print(face_landmarks_list)</span></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> face_landmarks_list:</span><br><span class="line">    print(each)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> each.keys():</span><br><span class="line">        print(i, end=<span class="string">': '</span>)</span><br><span class="line">        print(each[i])</span><br><span class="line">        <span class="keyword">for</span> any <span class="keyword">in</span> each[i]:</span><br><span class="line">            image = cv2.circle(image, any, <span class="number">3</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">-1</span>)</span><br><span class="line">cv2.imshow(<span class="string">"奥巴马"</span>, image)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独画下巴</span></span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> face_landmarks_list:</span><br><span class="line">    pts = np.array(each[<span class="string">'chin'</span>])</span><br><span class="line">    pts = pts.reshape((<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">    cv2.polylines(image2, [pts], <span class="literal">False</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>)) <span class="comment"># false 参数使其不闭合</span></span><br><span class="line">cv2.imshow(<span class="string">"奥巴马2"</span>, image2)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><p>在线摄像机版本:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line">camera = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, image = camera.read()</span><br><span class="line">    image = cv2.flip(image, <span class="number">1</span>)</span><br><span class="line">    image2 = image.copy()</span><br><span class="line"></span><br><span class="line">    face_landmarks_list = face_recognition.face_landmarks(image)</span><br><span class="line">    <span class="comment"># print(face_landmarks_list)</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> face_landmarks_list:</span><br><span class="line">        print(each)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> each.keys():</span><br><span class="line">            print(i, end=<span class="string">': '</span>)</span><br><span class="line">            print(each[i])</span><br><span class="line">            <span class="keyword">for</span> any <span class="keyword">in</span> each[i]:</span><br><span class="line">                image = cv2.circle(image, any, <span class="number">3</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">-1</span>)</span><br><span class="line">    cv2.imshow(<span class="string">"奥巴马"</span>, image)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 单独画下巴</span></span><br><span class="line">    <span class="keyword">for</span> each <span class="keyword">in</span> face_landmarks_list:</span><br><span class="line">        pts = np.array(each[<span class="string">'chin'</span>])</span><br><span class="line">        pts = pts.reshape((<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        cv2.polylines(image2, [pts], <span class="literal">False</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>)) <span class="comment"># false 参数使其不闭合</span></span><br><span class="line">    cv2.imshow(<span class="string">"奥巴马2"</span>, image2)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1000</span> // <span class="number">12</span>) &amp; <span class="number">0xff</span> == ord(<span class="string">"q"</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">camera.release()</span><br></pre></td></tr></table></figure><p>附一份在线的人脸搜索代码, 人脸数据保存在相对路径<code>./data/mans</code> 下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 人脸数据, 文件, 编码, 名字</span></span><br><span class="line">files = os.listdir(<span class="string">"./data/mans"</span>)</span><br><span class="line">face_images = [<span class="number">0</span>]*len(files)</span><br><span class="line">face_encodings = [<span class="number">0</span>]*len(files)</span><br><span class="line">face_names = [<span class="number">0</span>]*len(files)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取编码和名称</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(files)):</span><br><span class="line">    face_images[i] = face_recognition.load_image_file(<span class="string">'./data/mans/'</span> + files[i])</span><br><span class="line">    face_encodings[i] = face_recognition.face_encodings(face_images[i])</span><br><span class="line">    <span class="keyword">if</span> len(face_encodings[i]) &gt; <span class="number">0</span>:</span><br><span class="line">        face_encodings[i] = face_encodings[i][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        face_encodings[i] = <span class="literal">None</span></span><br><span class="line">    face_names[i] = re.findall(<span class="string">r'(.*)\..*'</span>, files[i])[<span class="number">0</span>]</span><br><span class="line">print(face_names)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 人脸比较</span></span><br><span class="line"><span class="comment"># results = face_recognition.compare_faces(face_encodings[0], face_encodings[1])</span></span><br><span class="line"><span class="comment"># print(results)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 人脸距离</span></span><br><span class="line"><span class="comment"># face_distances = face_recognition.face_distance(face_encodings[0], face_encodings[1])</span></span><br><span class="line"><span class="comment"># index = np.argmin(face_distances)</span></span><br><span class="line"><span class="comment"># print(index)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># camera = cv2.VideoCapture('./data/test.avi') # 从视频文件</span></span><br><span class="line">camera = cv2.VideoCapture(<span class="number">0</span>) <span class="comment"># 从摄像头</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, img = camera.read()</span><br><span class="line">    img = cv2.flip(img, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) # 灰度处理</span></span><br><span class="line">    locations = face_recognition.face_locations(img)</span><br><span class="line">    <span class="keyword">for</span> top, right, bottom, left <span class="keyword">in</span> locations:</span><br><span class="line">        cv2.rectangle(img, (left, top), (right, bottom), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        sub_img = img[top:bottom, left:right]</span><br><span class="line">        sub_img_code = face_recognition.face_encodings(sub_img)</span><br><span class="line">        <span class="keyword">if</span> len(sub_img_code) != <span class="number">0</span>:</span><br><span class="line">            face_distances = face_recognition.face_distance(face_encodings, sub_img_code[<span class="number">0</span>])</span><br><span class="line">            print(face_distances)</span><br><span class="line">            index = np.argmin(face_distances)</span><br><span class="line">            name = face_names[index]</span><br><span class="line">            cv2.putText(img, name, (left, top - <span class="number">20</span>), cv2.FONT_HERSHEY_SIMPLEX, <span class="number">1</span>, <span class="number">255</span>, <span class="number">2</span>)</span><br><span class="line">    cv2.imshow(<span class="string">'Face'</span>, img)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1000</span> // <span class="number">12</span>) &amp; <span class="number">0xff</span> == ord(<span class="string">"q"</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">camera.release()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开源库 </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 人脸识别 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅地使用ubuntu18.04（二）</title>
      <link href="/2019/06/10/you-ya-di-shi-yong-ubuntu18.04-er/"/>
      <url>/2019/06/10/you-ya-di-shi-yong-ubuntu18.04-er/</url>
      
        <content type="html"><![CDATA[<h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h2><p><a href="https://blog.csdn.net/wjh2622075127/article/details/91182584" target="_blank" rel="noopener">优雅地使用ubuntu18.04（一）</a><br><a href="https://blog.csdn.net/wjh2622075127/article/details/91384365" target="_blank" rel="noopener">优雅地使用ubuntu18.04（二）</a></p><h2 id="12、设置默认终端"><a href="#12、设置默认终端" class="headerlink" title="12、设置默认终端"></a>12、设置默认终端</h2><p>使用命令<code>sudo update-alternatives --config x-terminal-emulator</code><br>然后就可以选择了<br><img src="/images/20190610_1.png" alt></p><h2 id="13、设置开启自动启动"><a href="#13、设置开启自动启动" class="headerlink" title="13、设置开启自动启动"></a>13、设置开启自动启动</h2><p>找到<code>启动应用程序</code></p><p><img src="/images/20190610_2.png" alt><br>就可以直接添加自启动了<br><img src="/images/20190610_3.png" alt></p><h2 id="14、自定义右键"><a href="#14、自定义右键" class="headerlink" title="14、自定义右键"></a>14、自定义右键</h2><p>想实现文件夹右键，可以执行打开某一指定程序（如我们下载的终端），并设置工作目录为当前目录。<br>但还没有实现，挖个坑。</p><h2 id="15、使用albert"><a href="#15、使用albert" class="headerlink" title="15、使用albert"></a>15、使用albert</h2><p>这个工具类似于windows中的everything<br>但感觉不是很好用的样子？虽然有人强烈推荐<br><a href="https://software.opensuse.org/download.html?project=home:manuelschneid3r&package=albert" target="_blank" rel="noopener">可以直接下载deb文件进行安装了</a></p><h2 id="16、设置终端复制黏贴快捷键"><a href="#16、设置终端复制黏贴快捷键" class="headerlink" title="16、设置终端复制黏贴快捷键"></a>16、设置终端复制黏贴快捷键</h2><p>习惯了用Ctrl+C复制，所以也直接把终端的快捷方式给改了。里面有各种快捷方式，可以根据自己的习惯自定义啊。<br><img src="/images/20190610_4.png" alt></p><h2 id="17、几个好玩的命令"><a href="#17、几个好玩的命令" class="headerlink" title="17、几个好玩的命令"></a>17、几个好玩的命令</h2><h3 id="boxes"><a href="#boxes" class="headerlink" title="boxes"></a>boxes</h3><p><code>sudo apt install boxes</code><br><img src="/images/20190610_5.png" alt></p><h3 id="终端跑小火车"><a href="#终端跑小火车" class="headerlink" title="终端跑小火车"></a>终端跑小火车</h3><p><code>sudo apt install sl</code><br><code>sl</code><br><img src="/images/20190610_6.png" alt></p><h3 id="黑客帝国代码雨"><a href="#黑客帝国代码雨" class="headerlink" title="黑客帝国代码雨"></a>黑客帝国代码雨</h3><p><code>sudo apt install cmatrix</code><br><code>cmatrix</code><br><code>ctrl+z</code> 退出<br><img src="/images/20190610_7.png" alt></p><h3 id="screenfetch"><a href="#screenfetch" class="headerlink" title="screenfetch"></a>screenfetch</h3><p><code>sudo apt install screenfetch</code><br><code>screenfetch</code><br><img src="/images/20190610_8.png" alt></p><h2 id="18、顶栏自动隐藏"><a href="#18、顶栏自动隐藏" class="headerlink" title="18、顶栏自动隐藏"></a>18、顶栏自动隐藏</h2><p>安装Hide Top Bar插件<br><a href="https://extensions.gnome.org/extension/545/hide-top-bar/" target="_blank" rel="noopener">https://extensions.gnome.org/extension/545/hide-top-bar/</a></p><p>在全屏显示窗口时就会自动隐藏深色难看的顶栏了</p><h2 id="19、设置字体缩放比例。"><a href="#19、设置字体缩放比例。" class="headerlink" title="19、设置字体缩放比例。"></a>19、设置字体缩放比例。</h2><p>在字体这里设置缩放比例为1.25，看起来就大很多了，接近我在win 10 的大小习惯<br><img src="/images/20190610_9.png" alt></p><h2 id="20、安装Mac-OS-风格主题"><a href="#20、安装Mac-OS-风格主题" class="headerlink" title="20、安装Mac OS 风格主题"></a>20、安装Mac OS 风格主题</h2><p>参考<br><a href="https://blog.csdn.net/jasonzhoujx/article/details/80400245" target="_blank" rel="noopener">https://blog.csdn.net/jasonzhoujx/article/details/80400245</a></p><p><a href="https://www.opendesktop.org/s/Gnome" target="_blank" rel="noopener">到这个网站找各种主题</a><br>效果如图<br><img src="/images/20190610_10.png" alt></p><h2 id="21、修改登录界面的图片"><a href="#21、修改登录界面的图片" class="headerlink" title="21、修改登录界面的图片"></a>21、修改登录界面的图片</h2><p>修改这个文件夹<br><code>/etc/alternatives/gdm3.css</code><br>找到这段，修改成自己的图片路径, 以及下面几行css设置.<br><img src="/images/20190610_11.png" alt></p><h2 id="22、添加应用启动图标"><a href="#22、添加应用启动图标" class="headerlink" title="22、添加应用启动图标"></a>22、添加应用启动图标</h2><p>安装好pycharm后，没有启动的图标，所以自己设置一个。</p><p>首先找到图标文件，<a href="https://icon-icons.com/zh/%E5%9B%BE%E6%A0%87/pycharm/93936#256" target="_blank" rel="noopener">链接</a></p><p>然后在<code>/usr/share/applications/</code> 目录下添加<code>Pycharm.desktop</code>。</p><p>修改这个文件。注意，其中的Exec改成执行的命令，Icon改成自己图标的路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[Desktop Entry]</span><br><span class="line">Type=Application</span><br><span class="line">Name=Pycharm</span><br><span class="line">GenericName=Pycharm3</span><br><span class="line">Comment=Pycharm3:The Python IDE</span><br><span class="line">Exec=bash /home/jamey/programs/pycharm-2019.1.3/bin/pycharm.sh</span><br><span class="line">Icon=/home/jamey/programs/pycharm-2019.1.3/pycharm.ico</span><br><span class="line">Terminal=pycharm</span><br><span class="line">Categories=Pycharm;</span><br></pre></td></tr></table></figure><p>出现图标<br><img src="/images/20190610_12.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 开源库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优雅地使用ubuntu18.04（一）</title>
      <link href="/2019/06/09/you-ya-di-shi-yong-ubuntu18.04-yi/"/>
      <url>/2019/06/09/you-ya-di-shi-yong-ubuntu18.04-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="文章链接"><a href="#文章链接" class="headerlink" title="文章链接"></a>文章链接</h2><p><a href="https://blog.csdn.net/wjh2622075127/article/details/91182584" target="_blank" rel="noopener">优雅地使用ubuntu18.04（一）</a><br><a href="https://blog.csdn.net/wjh2622075127/article/details/91384365" target="_blank" rel="noopener">优雅地使用ubuntu18.04（二）</a></p><h2 id="1、ubuntu-截图"><a href="#1、ubuntu-截图" class="headerlink" title="1、ubuntu 截图"></a>1、ubuntu 截图</h2><p>理论上来说应该是可以直接下面这样，但是我的截图出来不会弹出窗口，所以直接搜索截图程序进行截图。<br><img src="/images/20190609_1.png" alt><br>shift+ctrl+prtSc 能够选中区域截图，并复制到剪切板</p><h2 id="2、终端快捷方式"><a href="#2、终端快捷方式" class="headerlink" title="2、终端快捷方式"></a>2、终端快捷方式</h2><p>ctrl+alt+t</p><h2 id="3、ubuntu自定义程序快捷方式"><a href="#3、ubuntu自定义程序快捷方式" class="headerlink" title="3、ubuntu自定义程序快捷方式"></a>3、ubuntu自定义程序快捷方式</h2><p>首先查看设置-键盘；发现有很多快捷键的记录<br><img src="/images/20190609_2.png" alt><br>比如我们可以设置移动工作区的快捷方式<br><img src="/images/20190609_3.png" alt><br>关于截图的快捷键<br><img src="/images/20190609_4.png" alt></p><h2 id="4、ubuntu快速回到桌面"><a href="#4、ubuntu快速回到桌面" class="headerlink" title="4、ubuntu快速回到桌面"></a>4、ubuntu快速回到桌面</h2><p><code>win + D</code><br>点击ubuntu的小图标不会自动消失真是难受。</p><h2 id="5、安装tim、微信等应用"><a href="#5、安装tim、微信等应用" class="headerlink" title="5、安装tim、微信等应用"></a>5、安装tim、微信等应用</h2><p>使用deepin-wine安装<br>别看别人写的博客安装了，看官方github说明吧<a href="https://github.com/wszqkzqk/deepin-wine-ubuntu" target="_blank" rel="noopener">https://github.com/wszqkzqk/deepin-wine-ubuntu</a></p><h2 id="6、rtl8821CE系列-安装ubuntu-找不到wifi适配器"><a href="#6、rtl8821CE系列-安装ubuntu-找不到wifi适配器" class="headerlink" title="6、rtl8821CE系列 安装ubuntu 找不到wifi适配器"></a>6、rtl8821CE系列 安装ubuntu 找不到wifi适配器</h2><p>参考下面这个博客，thinkpad e系列还真是坑<br><a href="https://blog.csdn.net/fljhm/article/details/79281655" target="_blank" rel="noopener">https://blog.csdn.net/fljhm/article/details/79281655</a></p><h2 id="7、ubuntu-手势操作"><a href="#7、ubuntu-手势操作" class="headerlink" title="7、ubuntu 手势操作"></a>7、ubuntu 手势操作</h2><p>找了网上很多的手势操作的程序，很多都没弄成功，最后弄好了这个<code>comfortable swipe</code><br><a href="https://github.com/Hikari9/comfortable-swipe" target="_blank" rel="noopener">这是它的github，里面如何安装讲的非常清楚</a><br>可以实现多指滑动自定义，虽然没有win 10 那么舒服，但好歹更方便了。</p><h2 id="8、二次点击dock图标隐藏窗口"><a href="#8、二次点击dock图标隐藏窗口" class="headerlink" title="8、二次点击dock图标隐藏窗口"></a>8、二次点击dock图标隐藏窗口</h2><p>初始的程序窗口点击不会消失，设置二次点击dock能够让程序消失<br>先输入<br><code>export GIO_EXTRA_MODULES=/usr/lib/x86_64-linux-gnu/gio/modules/</code><br>再输入<br><code>gsettings set org.gnome.shell.extensions.dash-to-dock click-action &#39;minimize&#39;</code><br>即可设置dock最小化</p><h2 id="9、设置dock为mac风格"><a href="#9、设置dock为mac风格" class="headerlink" title="9、设置dock为mac风格"></a>9、设置dock为mac风格</h2><p><a href="https://www.linuxidc.com/Linux/2018-05/152379.htm" target="_blank" rel="noopener">看这篇文章</a><br>但我用这总有bug<br>预期图<br><img src="/images/20190609_5.png" alt></p><h2 id="10、设定制终端的提示符"><a href="#10、设定制终端的提示符" class="headerlink" title="10、设定制终端的提示符"></a>10、设定制终端的提示符</h2><p>原先终端提示符有冗长的主机名，然而这东西没一点用处，拜拜占了那么多位置。<br>查看~/.bashrc文件中的PS1参数，这个参数就是提示符的格式。主机名代表\h，那么我们找到\h删除掉。<br>其他很多还可以自定义<br><img src="/images/20190609_6.png" alt><br><img src="/images/20190609_7.png" alt><br>如图，变得简洁了不少<br><img src="/images/20190609_8.png" alt></p><p>参考<a href="https://blog.csdn.net/sunbocong/article/details/82971477" target="_blank" rel="noopener">https://blog.csdn.net/sunbocong/article/details/82971477</a></p><h2 id="11、下载多种终端"><a href="#11、下载多种终端" class="headerlink" title="11、下载多种终端"></a>11、下载多种终端</h2><p>我下载了两个终端，一个是<strong>下拉式终端guake</strong><br>可设置透明、在顶栏还是下面、失去焦点隐藏、F12开关<br><img src="/images/20190609_9.png" alt><br>第二个是tilix，功能比原生的多，特别是这窗口，比较丰富<br><img src="/images/20190609_10.png" alt><br>如图为三种终端的比较<br><img src="/images/20190609_11.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> 开源库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>opencv-python 人脸识别尝试——knn与深度学习</title>
      <link href="/2019/06/08/opencv-python-ren-lian-shi-bie-chang-shi-knn-yu-shen-du-xue-xi/"/>
      <url>/2019/06/08/opencv-python-ren-lian-shi-bie-chang-shi-knn-yu-shen-du-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>人脸识别和人脸检测不同，人脸检测时检测到人脸位置，而人脸识别是基于人脸数据库，进行一些识别操作如识别某一个人像是数据库中的哪个标签。</p><p>需要说明的是，使用knn和Dense层的神经网络作为人脸识别算法只是我的尝试，在实际的使用中基本不使用这两种算法的。同时，经过实际测试，这样得到的结果极不准确，甚至可以说毫无效果（苦笑）。</p><hr><h2 id="人脸数据获取"><a href="#人脸数据获取" class="headerlink" title="人脸数据获取"></a>人脸数据获取</h2><p>进行人脸识别首先要有人脸数据库，我们可以用opencv调用摄像头，进行人脸检测，并将人脸灰度图片写入到(200, 200)的pgm文件作为我们的人脸数据库。</p><p>code</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span><span class="params">()</span>:</span></span><br><span class="line">    face_cascade = cv2.CascadeClassifier( <span class="comment"># haar级联文件-人脸</span></span><br><span class="line">        <span class="string">'./cascades/haarcascade_frontalface_default.xml'</span></span><br><span class="line">    )</span><br><span class="line">    camera = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ret, frame = camera.read()</span><br><span class="line">        frame = cv2.flip(frame, <span class="number">1</span>)  <span class="comment"># 翻转为正常角度</span></span><br><span class="line">        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) <span class="comment">#转灰度处理</span></span><br><span class="line">        faces = face_cascade.detectMultiScale(gray, <span class="number">1.3</span>, <span class="number">5</span>) <span class="comment"># 识别</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">            img = cv2.rectangle( <span class="comment"># 画框图</span></span><br><span class="line">                frame, (x, y), (x + w, y + h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span></span><br><span class="line">            )</span><br><span class="line">            <span class="comment"># cv2.putText(</span></span><br><span class="line">            <span class="comment">#     img, 'name', (x, y - 20), cv2.FONT_HERSHEY_SIMPLEX, 1, 255, 2</span></span><br><span class="line">            <span class="comment"># )</span></span><br><span class="line">            f = cv2.resize(gray[y: y+h, x: x+w], (<span class="number">200</span>, <span class="number">200</span>)) <span class="comment"># 统一大小</span></span><br><span class="line">            cv2.imwrite(<span class="string">'./data/at/name/%s.pgm'</span> % str(count), f) <span class="comment"># 将人脸数据写入到pgm文件中</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        cv2.imshow(<span class="string">'camera'</span>, frame)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(int(<span class="number">1000</span> / <span class="number">12</span>)) &amp; <span class="number">0xff</span> == ord(<span class="string">"q"</span>): <span class="comment"># 等待ｑ键</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    camera.release()</span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    generate()</span><br></pre></td></tr></table></figure><h2 id="处理图片读取到并数组中"><a href="#处理图片读取到并数组中" class="headerlink" title="处理图片读取到并数组中"></a>处理图片读取到并数组中</h2><p><strong>这个代码是读取数据的模块，在后面的代码中多次调用以获取数据</strong>。<br>将上一步存储的图片数据转化为可处理的numpy数组，提供了两种相似的接口函数。</p><p>read_images 为普通的读取到灰度的pgm图片返回的数组<br>read_images_binary 是将pgm图片进行了二值化处理得到的数组数据</p><p>返回的数据类型为 list, list, dict<br>分别为 图片数据、图片标签、标签和人名的映射字典</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys, re</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_images</span><span class="params">(path, sz=None)</span>:</span> <span class="comment"># 读取自己的图片数据库</span></span><br><span class="line">    c = <span class="number">0</span></span><br><span class="line">    X, y = [], []</span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> dirname, dirnames, filenames <span class="keyword">in</span> os.walk(path): <span class="comment"># 遍历文件夹下文件</span></span><br><span class="line">        <span class="keyword">for</span> subdirname <span class="keyword">in</span> dirnames:</span><br><span class="line">            subject_path = os.path.join(dirname, subdirname)</span><br><span class="line">            <span class="comment"># print("subdirname = ", dirname)</span></span><br><span class="line">            <span class="comment"># print("subject_path = ", subject_path)</span></span><br><span class="line">            <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(subject_path):</span><br><span class="line">                <span class="keyword">if</span> filename[<span class="number">-4</span>:] != <span class="string">'.pgm'</span>: <span class="comment"># 如果文件不是pgm文件,那么跳过</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                filepath = os.path.join(subject_path, filename) <span class="comment"># 生成完整的文件名</span></span><br><span class="line">                <span class="comment"># print(filepath)</span></span><br><span class="line">                im = cv2.imread(os.path.join(subject_path, filename), \</span><br><span class="line">                                cv2.IMREAD_GRAYSCALE) <span class="comment"># 读取pgm图片</span></span><br><span class="line">                <span class="comment"># print(np.shape(im))</span></span><br><span class="line">                <span class="comment"># 改变大小</span></span><br><span class="line">                <span class="keyword">if</span> sz <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    im = cv2.resize(im, (<span class="number">200</span>, <span class="number">200</span>)) <span class="comment"># 调整图片大小</span></span><br><span class="line"></span><br><span class="line">                X.append(np.asarray(im, dtype=np.uint8))</span><br><span class="line">                y.append(c)</span><br><span class="line">            <span class="comment"># print(re.findall(r'./data/at/(.*)', subject_path))</span></span><br><span class="line">            dic[c] = re.findall(<span class="string">r'./data/at/(.*)'</span>, subject_path)[<span class="number">0</span>]</span><br><span class="line">            c = c + <span class="number">1</span></span><br><span class="line">    <span class="comment"># print("c = ", c)</span></span><br><span class="line">    <span class="comment"># print(X)</span></span><br><span class="line">    <span class="keyword">return</span> [X, y], dic</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_images_binary</span><span class="params">(path, sz=None)</span>:</span> <span class="comment"># 读取自己的图片数据库</span></span><br><span class="line">    c = <span class="number">0</span></span><br><span class="line">    X, y = [], []</span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> dirname, dirnames, filenames <span class="keyword">in</span> os.walk(path): <span class="comment"># 遍历文件夹下文件</span></span><br><span class="line">        <span class="keyword">for</span> subdirname <span class="keyword">in</span> dirnames:</span><br><span class="line">            subject_path = os.path.join(dirname, subdirname)</span><br><span class="line">            <span class="comment"># print("subdirname = ", dirname)</span></span><br><span class="line">            <span class="comment"># print("subject_path = ", subject_path)</span></span><br><span class="line">            <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(subject_path):</span><br><span class="line">                <span class="keyword">if</span> filename[<span class="number">-4</span>:] != <span class="string">'.pgm'</span>: <span class="comment"># 如果文件不是pgm文件,那么跳过</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                filepath = os.path.join(subject_path, filename) <span class="comment"># 生成完整的文件名</span></span><br><span class="line">                <span class="comment"># print(filepath)</span></span><br><span class="line">                im = cv2.imread(os.path.join(subject_path, filename), \</span><br><span class="line">                                cv2.IMREAD_GRAYSCALE) <span class="comment"># 读取pgm图片</span></span><br><span class="line">                ret, im = cv2.threshold(im, <span class="number">120</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">                <span class="keyword">if</span> sz <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                    im = cv2.resize(im, (<span class="number">200</span>, <span class="number">200</span>)) <span class="comment"># 调整图片大小</span></span><br><span class="line"></span><br><span class="line">                X.append(np.asarray(im, dtype=np.uint8))</span><br><span class="line">                y.append(c)</span><br><span class="line">            <span class="comment"># print(re.findall(r'./data/at/(.*)', subject_path))</span></span><br><span class="line">            dic[c] = re.findall(<span class="string">r'./data/at/(.*)'</span>, subject_path)[<span class="number">0</span>]</span><br><span class="line">            c = c + <span class="number">1</span></span><br><span class="line">    <span class="comment"># print("c = ", c)</span></span><br><span class="line">    <span class="comment"># print(X)</span></span><br><span class="line">    <span class="keyword">return</span> [X, y], dic</span><br></pre></td></tr></table></figure><h2 id="调用opencv内置函数进行人脸识别"><a href="#调用opencv内置函数进行人脸识别" class="headerlink" title="调用opencv内置函数进行人脸识别"></a>调用opencv内置函数进行人脸识别</h2><p>内置的三种人脸识别函数</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = cv2.face.EigenFaceRecognizer_create() <span class="comment"># 这个版本的opencv名字改了,和书上的有点不一样</span></span><br><span class="line">model = cv2.face.LBPHFaceRecognizer_create(<span class="number">1</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">90</span>)</span><br><span class="line">model = cv2.face.FisherFaceRecognizer_create()</span><br></pre></td></tr></table></figure><p>调用opencv-python提供的这三种人脸识别函数，发现效果都不好。人脸总是检测错误，准确率极低，要它何用？（不知道是不是我使用姿势不太正确）于是我催生出自己实现人脸识别算法那的念头。</p><p>观察框出的人脸，觉得一个人的人脸图片，单单框出了人脸，那应该相似度很高啊。类似于手写数字识别，简单的knn算法可以达到很高的正确率，那么是不是可以用knn较好的解决这个问题。</p><p>实践出来的结果是：不是的。</p><p>code</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"><span class="keyword">from</span> getData <span class="keyword">import</span> read_images</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv2ImgAddText</span><span class="params">(img, text, left, top, textColor=<span class="params">(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span>, textSize=<span class="number">20</span>)</span>:</span></span><br><span class="line">    img = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    fontText = ImageFont.truetype(</span><br><span class="line">        <span class="string">"SimHei.ttf"</span>, textSize, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">    draw.text((left, top), text, textColor, font=fontText)</span><br><span class="line">    <span class="keyword">return</span> cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">face_rec</span><span class="params">()</span>:</span> <span class="comment"># 人脸识别</span></span><br><span class="line"></span><br><span class="line">    [X, y], label2name = read_images(<span class="string">'./data/at'</span>)</span><br><span class="line">    print(<span class="string">"label2name:"</span>, label2name)</span><br><span class="line">    print(np.shape(X))</span><br><span class="line">    print(<span class="string">"label2name = "</span>, label2name)</span><br><span class="line">    print(np.shape(X))</span><br><span class="line">    <span class="comment"># print("y = ", y)</span></span><br><span class="line">    y = np.asarray(y, dtype=np.int32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用人脸识别函数生成模型</span></span><br><span class="line">    <span class="comment"># model = cv2.face.EigenFaceRecognizer_create() # 这个版本的opencv名字改了,和书上的有点不一样</span></span><br><span class="line">    model = cv2.face.LBPHFaceRecognizer_create(<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">8</span>)</span><br><span class="line">    model.train(np.asarray(X), np.asarray(y)) <span class="comment"># 训练</span></span><br><span class="line">    camera = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">    face_cascade = cv2.CascadeClassifier( <span class="comment"># 分类器检测人脸</span></span><br><span class="line">        <span class="string">'./cascades/haarcascade_frontalface_default.xml'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        read, img = camera.read()</span><br><span class="line">        img = cv2.flip(img, <span class="number">1</span>)  <span class="comment"># 翻转为正常角度</span></span><br><span class="line">        faces = face_cascade.detectMultiScale(img, <span class="number">1.3</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">            img = cv2.rectangle(img, (x, y), (x+w, y+h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">            roi = gray[x: x+<span class="number">2</span>, y: y+h]</span><br><span class="line">            roi = cv2.resize(roi, (<span class="number">200</span>, <span class="number">200</span>), interpolation=cv2.INTER_LINEAR)</span><br><span class="line">            params = model.predict(roi) <span class="comment"># 预测</span></span><br><span class="line">            print(params) <span class="comment"># 返回 (图片标签, 置信度)</span></span><br><span class="line">            <span class="keyword">if</span> params[<span class="number">0</span>] &gt;= <span class="number">0</span>:</span><br><span class="line">                name = label2name[params[<span class="number">0</span>]]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                name = <span class="string">"未知"</span></span><br><span class="line">            print(<span class="string">"检测到%s"</span> % name)</span><br><span class="line">            print(<span class="string">"label: %s, Confidence: %.2f"</span> % (params[<span class="number">0</span>], params[<span class="number">1</span>]))</span><br><span class="line">            img = cv2ImgAddText(img, name, x, y - <span class="number">20</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">20</span>)</span><br><span class="line">            <span class="comment"># cv2.putText(img, name, (x, y - 20),</span></span><br><span class="line">            <span class="comment">#             cv2.FONT_HERSHEY_SIMPLEX, 1, 255, 2) # putText只能写上ascii中的部分字符, 呵呵</span></span><br><span class="line">        <span class="comment"># print(img)</span></span><br><span class="line"></span><br><span class="line">        cv2.imshow(<span class="string">'camera'</span>, img)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1000</span> // <span class="number">12</span>) &amp; <span class="number">0xff</span> == ord(<span class="string">"q"</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    face_rec() <span class="comment"># 人脸识别</span></span><br></pre></td></tr></table></figure><h2 id="knn算法进行人脸识别"><a href="#knn算法进行人脸识别" class="headerlink" title="knn算法进行人脸识别"></a>knn算法进行人脸识别</h2><p>简单的knn模板</p><p>knn 实现</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> getData <span class="keyword">import</span> read_images</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knn</span><span class="params">(xtest, data, label, k)</span>:</span> <span class="comment"># xtest为测试的特征向量，data、label为“训练”数据集，k为设定的阈值</span></span><br><span class="line"><span class="comment">#     print(xtest.shape)</span></span><br><span class="line"><span class="comment">#     print(label.shape)</span></span><br><span class="line">    exp_xtest = np.tile(xtest, (len(label), <span class="number">1</span>)) - data</span><br><span class="line">    sq_diff = exp_xtest**<span class="number">2</span></span><br><span class="line">    sum_diff = sq_diff.sum(axis=<span class="number">1</span>)</span><br><span class="line">    distance = sum_diff**<span class="number">0.5</span></span><br><span class="line">    <span class="comment"># print(distance)</span></span><br><span class="line">    sort_index = distance.argsort()</span><br><span class="line">    classCount = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        one_label = label[sort_index[i]]</span><br><span class="line">        classCount[one_label] = classCount.get(one_label, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    sortedClassCount = sorted(classCount.items(), key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    print(distance.sum())</span><br><span class="line">    print(classCount)</span><br><span class="line">    print(sortedClassCount)</span><br><span class="line">    <span class="keyword">return</span> sortedClassCount[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    [X, y], label2name = read_images(<span class="string">'./data/at/'</span>)</span><br><span class="line">    print(np.shape(X))</span><br><span class="line">    X = np.array(X)</span><br><span class="line">    Xx = X.reshape(X.shape[<span class="number">0</span>], <span class="number">40000</span>)</span><br><span class="line">    xdata, label = Xx, y</span><br><span class="line">    result = knn(np.array(xdata[<span class="number">67</span>]), xdata, label, <span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"result = "</span>, label2name[result])</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>调用knn的主体部分</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"><span class="keyword">from</span> getData <span class="keyword">import</span> read_images_binary</span><br><span class="line"><span class="keyword">from</span> knn <span class="keyword">import</span> knn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv2ImgAddText</span><span class="params">(img, text, left, top, textColor=<span class="params">(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span>, textSize=<span class="number">20</span>)</span>:</span></span><br><span class="line">    img = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    fontText = ImageFont.truetype(</span><br><span class="line">        <span class="string">"SimHei.ttf"</span>, textSize, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">    draw.text((left, top), text, textColor, font=fontText)</span><br><span class="line">    <span class="keyword">return</span> cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">face_rec</span><span class="params">()</span>:</span> <span class="comment"># 人脸识别</span></span><br><span class="line"></span><br><span class="line">    [X, y], label2name = read_images_binary(<span class="string">'./data/at'</span>)</span><br><span class="line">    X = np.array(X)</span><br><span class="line">    Xx = X.reshape(X.shape[<span class="number">0</span>], <span class="number">40000</span>)</span><br><span class="line">    xdata, label = Xx, y</span><br><span class="line"></span><br><span class="line">    y = np.asarray(y, dtype=np.int32)</span><br><span class="line">    face_cascade = cv2.CascadeClassifier( <span class="comment"># 分类器检测人脸</span></span><br><span class="line">        <span class="string">'./cascades/haarcascade_frontalface_default.xml'</span></span><br><span class="line">    )</span><br><span class="line">    videoCapture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        read, img = videoCapture.read()</span><br><span class="line">        img = cv2.flip(img, <span class="number">1</span>)</span><br><span class="line">        faces = face_cascade.detectMultiScale(img, <span class="number">1.3</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">            img = cv2.rectangle(img, (x, y), (x+w, y+h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">            roi = gray[x: x+<span class="number">2</span>, y: y+h]</span><br><span class="line">            roi = cv2.resize(roi, (<span class="number">200</span>, <span class="number">200</span>), interpolation=cv2.INTER_LINEAR)</span><br><span class="line">            roi = np.array(roi).reshape(<span class="number">40000</span>, )</span><br><span class="line">            result = knn(roi, xdata, label, <span class="number">3</span>)</span><br><span class="line">            print(result) <span class="comment"># 返回结果的标签</span></span><br><span class="line">            name = label2name[result]</span><br><span class="line">            print(<span class="string">"检测到%s"</span> % name)</span><br><span class="line">            img = cv2ImgAddText(img, name, x, y - <span class="number">20</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">20</span>)</span><br><span class="line">        cv2.imshow(<span class="string">'camera'</span>, img)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1000</span> // <span class="number">12</span>) &amp; <span class="number">0xff</span> == ord(<span class="string">"q"</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    face_rec() <span class="comment"># 人脸识别</span></span><br></pre></td></tr></table></figure><h2 id="使用Dense层神经网络进行人脸识别"><a href="#使用Dense层神经网络进行人脸识别" class="headerlink" title="使用Dense层神经网络进行人脸识别"></a>使用Dense层神经网络进行人脸识别</h2><p>简单的神经网络多分类器实现（效果不好，大概是数据太少，每个人只有200张(200, 200) 的pgm图片数据。</p><p>调用keras的高级API，搭积木一样的建立神经网络。</p><p>即使是这么少的数据，训练一次的时间也要好几分钟。调参调了好久，关键是调不出效果啊～</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> getData <span class="keyword">import</span> read_images, read_images_binary</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> layers</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_onehot</span><span class="params">(y)</span>:</span> <span class="comment"># 将标签转化为独热码oen-hot</span></span><br><span class="line">    print(<span class="string">"max of y = "</span>, np.max(y))</span><br><span class="line">    onehots = np.zeros((len(y), np.max(y) + <span class="number">1</span>), dtype=np.float)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(y)):</span><br><span class="line">        onehots[i][y[i]] = <span class="number">1.0</span></span><br><span class="line">    print(<span class="string">"shape of onehots : "</span>, np.shape(onehots))</span><br><span class="line">    <span class="keyword">return</span> onehots</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_model_dense</span><span class="params">(size=<span class="params">(<span class="number">200</span>, <span class="number">200</span>)</span>)</span>:</span> <span class="comment"># 设置一个全连接层网络，返回模型，未训练</span></span><br><span class="line">    model = models.Sequential([</span><br><span class="line">        layers.Dense(<span class="number">16</span>, activation=<span class="string">'relu'</span>, input_shape=((<span class="number">40000</span>, ))),</span><br><span class="line">        layers.Dense(<span class="number">16</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">        layers.Dense(<span class="number">16</span>, activation=<span class="string">'relu'</span>),</span><br><span class="line">        layers.Dense(<span class="number">4</span>, activation=<span class="string">'softmax'</span>)</span><br><span class="line">    ])</span><br><span class="line">    model.compile(</span><br><span class="line">        optimizer=<span class="string">'rmsprop'</span>,</span><br><span class="line">        loss=<span class="string">'categorical_crossentropy'</span>,</span><br><span class="line">        metrics=[<span class="string">'accuracy'</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">k_fold_validation</span><span class="params">(train_data, train_targets)</span>:</span></span><br><span class="line">    k = <span class="number">4</span></span><br><span class="line">    num_val_samples = len(train_data) // k</span><br><span class="line">    num_epochs = <span class="number">5</span></span><br><span class="line">    all_scores = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        print(<span class="string">'processing fole # '</span>, i)</span><br><span class="line">        val_data = train_data[i * num_val_samples: (i + <span class="number">1</span>) * num_val_samples]</span><br><span class="line">        val_targets = train_targets[i * num_val_samples: (i + <span class="number">1</span>) * num_val_samples]</span><br><span class="line"></span><br><span class="line">        partial_train_data = np.concatenate(</span><br><span class="line">            [train_data[:i * num_val_samples],</span><br><span class="line">            train_data[(i + <span class="number">1</span>) * num_val_samples:]],</span><br><span class="line">            axis=<span class="number">0</span></span><br><span class="line">        )</span><br><span class="line">        partial_train_targets = np.concatenate(</span><br><span class="line">            [train_targets[:i * num_val_samples],</span><br><span class="line">             train_targets[(i + <span class="number">1</span>) * num_val_samples:]],</span><br><span class="line">            axis = <span class="number">0</span></span><br><span class="line">        )</span><br><span class="line">        model = get_model_dense()</span><br><span class="line">        model.fit(</span><br><span class="line">            partial_train_data,</span><br><span class="line">            partial_train_targets,</span><br><span class="line">            epochs=num_epochs,</span><br><span class="line">            batch_size=<span class="number">3</span></span><br><span class="line">        )</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        model5开始，对图片进行了阈值为１２０的图片二值化处理</span></span><br><span class="line"><span class="string">        model6调整了参数（防止过拟合），从６４调成１６</span></span><br><span class="line"><span class="string">        model7加了一层</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        model.save(<span class="string">'dense_model_7.h5'</span>)</span><br><span class="line">        val_mse, val_mae = model.evaluate(val_data, val_targets)</span><br><span class="line">        all_scores.append(val_mae)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    [X, y], label2name = read_images_binary(<span class="string">'./data/at/'</span>) <span class="comment"># 调用人脸数据</span></span><br><span class="line">    X = np.array(X).reshape(len(X), <span class="number">40000</span>) / <span class="number">255</span></span><br><span class="line">    y = to_onehot(np.array(y))</span><br><span class="line">    index = np.arange(len(X))</span><br><span class="line">    np.random.shuffle(index) <span class="comment"># 生成打乱的索引</span></span><br><span class="line">    print(<span class="string">"index = "</span>, index)</span><br><span class="line">    X = X[index] <span class="comment"># 得到打乱的数据</span></span><br><span class="line">    y = y[index]</span><br><span class="line">    print(X)</span><br><span class="line">    print(y)</span><br><span class="line">    print(X.shape)</span><br><span class="line">    print(y.shape)</span><br><span class="line">    k_fold_validation(X, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>主体部分</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"><span class="keyword">from</span> getData <span class="keyword">import</span> read_images</span><br><span class="line"><span class="keyword">from</span> knn <span class="keyword">import</span> knn</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv2ImgAddText</span><span class="params">(img, text, left, top, textColor=<span class="params">(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span>, textSize=<span class="number">20</span>)</span>:</span></span><br><span class="line">    img = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    fontText = ImageFont.truetype(</span><br><span class="line">        <span class="string">"SimHei.ttf"</span>, textSize, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">    draw.text((left, top), text, textColor, font=fontText)</span><br><span class="line">    <span class="keyword">return</span> cv2.cvtColor(np.asarray(img), cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">face_rec</span><span class="params">()</span>:</span> <span class="comment"># 人脸识别</span></span><br><span class="line"></span><br><span class="line">    [X, y], label2name = read_images(<span class="string">'./data/at'</span>)</span><br><span class="line">    print(<span class="string">"label2name: "</span>, label2name)</span><br><span class="line">    X = np.array(X)</span><br><span class="line">    Xx = X.reshape(X.shape[<span class="number">0</span>], <span class="number">40000</span>)</span><br><span class="line">    xdata, label = Xx, y</span><br><span class="line"></span><br><span class="line">    y = np.asarray(y, dtype=np.int32)</span><br><span class="line">    face_cascade = cv2.CascadeClassifier( <span class="comment"># 分类器检测人脸</span></span><br><span class="line">        <span class="string">'./cascades/haarcascade_frontalface_default.xml'</span></span><br><span class="line">    )</span><br><span class="line">    videoCapture = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    model = models.load_model(<span class="string">'dense_model_6.h5'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        read, img = videoCapture.read()</span><br><span class="line">        img = cv2.flip(img, <span class="number">1</span>)</span><br><span class="line">        faces = face_cascade.detectMultiScale(img, <span class="number">1.3</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> (x, y, w, h) <span class="keyword">in</span> faces:</span><br><span class="line">            img = cv2.rectangle(img, (x, y), (x+w, y+h), (<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">            roi = gray[x: x+<span class="number">2</span>, y: y+h]</span><br><span class="line">            roi = cv2.resize(roi, (<span class="number">200</span>, <span class="number">200</span>), interpolation=cv2.INTER_LINEAR)</span><br><span class="line">            roi = np.array(roi).reshape(<span class="number">40000</span>, )</span><br><span class="line">            prediction = model.predict(np.array([roi]))</span><br><span class="line">            <span class="comment"># print(np.shape(roi))</span></span><br><span class="line">            print(<span class="string">"dnn predict result :"</span>, prediction)</span><br><span class="line">            index = np.argmax(prediction) <span class="comment"># 最大值所在的索引</span></span><br><span class="line">            name = label2name[index]</span><br><span class="line">            print(<span class="string">"检测到%s"</span> % name)</span><br><span class="line">            img = cv2ImgAddText(img, name, x, y - <span class="number">20</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">20</span>)</span><br><span class="line">        cv2.imshow(<span class="string">'camera'</span>, img)</span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1000</span> // <span class="number">12</span>) &amp; <span class="number">0xff</span> == ord(<span class="string">"q"</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    face_rec() <span class="comment"># 人脸识别</span></span><br></pre></td></tr></table></figure><h2 id="一些小知识点"><a href="#一些小知识点" class="headerlink" title="一些小知识点"></a>一些小知识点</h2><h3 id="opencv-putText无法写中文"><a href="#opencv-putText无法写中文" class="headerlink" title="opencv putText无法写中文"></a>opencv putText无法写中文</h3><p>putText()不能直接写上中文，那就用PIL库曲线救国了。下面是一个demo。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="comment">#中文乱码处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv2ImgAddText</span><span class="params">(img, text, left, top, textColor=<span class="params">(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>)</span>, textSize=<span class="number">20</span>)</span>:</span></span><br><span class="line">    img = Image.fromarray(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))</span><br><span class="line">    draw = ImageDraw.Draw(img)</span><br><span class="line">    fontText = ImageFont.truetype(</span><br><span class="line">        <span class="string">"SimHei.ttf"</span>, textSize, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">    draw.text((left, top), text, textColor, font=fontText)</span><br><span class="line">    <span class="keyword">return</span> cv2.cvtColor(numpy.asarray(img), cv2.COLOR_RGB2BGR)</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'./test.png'</span>)</span><br><span class="line">img = cv2ImgAddText(img, <span class="string">"你好世界"</span>, <span class="number">140</span>, <span class="number">60</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">20</span>)</span><br><span class="line">cv2.imshow(<span class="string">'image'</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="二值化图片"><a href="#二值化图片" class="headerlink" title="二值化图片"></a>二值化图片</h3><p>使用<code>cv2.threshold()</code>函数，设置<code>cv2.THRESH_BINARY</code>参数进行二值化。可以设置阈值。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">'test.jpg'</span>)</span><br><span class="line"><span class="comment"># img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span></span><br><span class="line">cv2.imwrite(<span class="string">'test.jpg'</span>, cv2.Canny(img, <span class="number">50</span>, <span class="number">120</span>))</span><br><span class="line">cv2.imshow(<span class="string">'canny'</span>, cv2.imread(<span class="string">'test.jpg'</span>))</span><br><span class="line">ret, img = cv2.threshold(img, <span class="number">110</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line">cv2.imshow(<span class="string">'binary'</span>, img)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure><h3 id="路径目录测试"><a href="#路径目录测试" class="headerlink" title="路径目录测试"></a>路径目录测试</h3><p>由于代码文件和图片文件中间隔了两个文件夹，且图片所在文件夹名称代表图片标签名称，所以如何遍历文件夹，读取到有用的信息是个技术活。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">path = <span class="string">'./data'</span></span><br><span class="line"><span class="keyword">for</span> dirname, dirnames, filenames <span class="keyword">in</span> os.walk(path):</span><br><span class="line">    <span class="keyword">for</span> subdirname <span class="keyword">in</span> dirnames:</span><br><span class="line">        subject_path = os.path.join(dirname, subdirname)</span><br><span class="line">        <span class="comment"># print(subject_path)</span></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(subject_path):</span><br><span class="line">            <span class="keyword">if</span> filename[<span class="number">-4</span>:] == <span class="string">'.pgm'</span>:</span><br><span class="line">                filepath = os.path.join(subject_path, filename)</span><br><span class="line">                print(filepath)</span><br></pre></td></tr></table></figure><h3 id="np-random-shuffle-测试"><a href="#np-random-shuffle-测试" class="headerlink" title="np.random.shuffle() 测试"></a>np.random.shuffle() 测试</h3><p><code>np.random.shuffle()</code> 能够将某一迭代对象进行打乱。<br>会直接改变传递给他的对象，而不会返回值，需要注意。</p><p>用这个函数，生成索引的随机排列，可以很方便的得到打乱的数据和标签，从而更好的进行训练。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(type(a[<span class="number">9</span>]))</span><br><span class="line">print(np.array(a))</span><br><span class="line">index = np.array(a)</span><br><span class="line">np.random.shuffle(index)</span><br><span class="line">print(index)</span><br><span class="line"></span><br><span class="line">index = np.arange(<span class="number">7</span>)</span><br><span class="line">print(index)</span><br></pre></td></tr></table></figure><h3 id="keras保存和恢复模型"><a href="#keras保存和恢复模型" class="headerlink" title="keras保存和恢复模型"></a>keras保存和恢复模型</h3><p><code>from tensorflow.keras import models</code><br><code>model.save(&#39;dense_model_7.h5&#39;)</code><br><code>model = models.load_model(&#39;dense_model_6.h5&#39;)</code><br>就不用每次都重新训练了。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人脸识别 </tag>
            
            <tag> opencv </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda虚拟环境及PyCharm项目环境设置</title>
      <link href="/2019/05/05/anaconda-xu-ni-huan-jing-ji-pycharm-xiang-mu-huan-jing-she-zhi/"/>
      <url>/2019/05/05/anaconda-xu-ni-huan-jing-ji-pycharm-xiang-mu-huan-jing-she-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="Anaconda虚拟环境"><a href="#Anaconda虚拟环境" class="headerlink" title="Anaconda虚拟环境"></a>Anaconda虚拟环境</h2><h3 id="1、创建环境"><a href="#1、创建环境" class="headerlink" title="1、创建环境"></a>1、创建环境</h3><p><code>conda create --name your_env_name python=3.6</code><br>或者<br><code>conda create -n  your_env_name python=3.7</code><br>新建一个环境</p><h3 id="2、查看环境"><a href="#2、查看环境" class="headerlink" title="2、查看环境"></a>2、查看环境</h3><p>进入Anaconda Prompt，使用<code>conda info -e</code>查看所有环境和当前环境</p><h3 id="3、激活环境"><a href="#3、激活环境" class="headerlink" title="3、激活环境"></a>3、激活环境</h3><p>使用<code>activate py36</code> 激活虚拟环境</p><h3 id="4、复制环境老环境到新的环境中"><a href="#4、复制环境老环境到新的环境中" class="headerlink" title="4、复制环境老环境到新的环境中"></a>4、复制环境老环境到新的环境中</h3><p><code>conda create --name new_env_name --clone old_env_name</code></p><h3 id="5、删除某个环境"><a href="#5、删除某个环境" class="headerlink" title="5、删除某个环境"></a>5、删除某个环境</h3><p><code>conda remove --name your_env_name --all</code></p><h3 id="6、导出和导入环境（分享）"><a href="#6、导出和导入环境（分享）" class="headerlink" title="6、导出和导入环境（分享）"></a>6、导出和导入环境（分享）</h3><p>切换到了要导出的环境之后，使用命令<br><code>conda env export &gt; environment.yml</code><br>将当前环境导出</p><p>使用命令<br><code>conda env create -f environment.yml</code><br>建立（导入）新的环境</p><h3 id="7、查看指定环境的包"><a href="#7、查看指定环境的包" class="headerlink" title="7、查看指定环境的包"></a>7、查看指定环境的包</h3><p><code>conda list -n your_env_name</code></p><h3 id="8、为某个指定环境安装包"><a href="#8、为某个指定环境安装包" class="headerlink" title="8、为某个指定环境安装包"></a>8、为某个指定环境安装包</h3><p><code>conda install -n env_name package_name</code></p><h3 id="9、添加conda虚拟环境为jupyter-kernel"><a href="#9、添加conda虚拟环境为jupyter-kernel" class="headerlink" title="9、添加conda虚拟环境为jupyter kernel"></a>9、添加conda虚拟环境为jupyter kernel</h3><p><code>conda install ipykernel</code><br><code>python -m ipykernel install --user --name 环境名称 --display-name 名称(不需要引号)</code><br>注意这个命令要在安装了ipykernel的环境下进行。<br>如果出一些奇怪的故障，重启jupyter notebook。</p><p>参考：<a href="https://blog.csdn.net/menc15/article/details/71477949/" target="_blank" rel="noopener">https://blog.csdn.net/menc15/article/details/71477949/</a></p><h3 id="10、ubuntu-中的激活环境"><a href="#10、ubuntu-中的激活环境" class="headerlink" title="10、ubuntu 中的激活环境"></a>10、ubuntu 中的激活环境</h3><p>用命令<code>source activate env-name</code></p><p>因为最近使用opencv，4版本的有很多不兼容的地方，所以我安装一个3.4版本的虚拟环境。<br>编辑批量安装包</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opencv-python==<span class="number">3.4</span><span class="number">.2</span><span class="number">.16</span></span><br><span class="line">pip install opencv-contrib-python==<span class="number">3.4</span><span class="number">.2</span><span class="number">.16</span></span><br><span class="line">numpy</span><br></pre></td></tr></table></figure><p>使用命令<code>pip install -r requirements.txt</code> 安装</p><hr><h2 id="PyCharm项目环境配置"><a href="#PyCharm项目环境配置" class="headerlink" title="PyCharm项目环境配置"></a>PyCharm项目环境配置</h2><p>之前每次新建一个PyCharm项目，他给我的环境都是一个新的虚拟环境，所以很不方便而且还要项目文件很冗余，打开项目的速度又慢。于是设置了默认的本地python环境。</p><p>1、找到<code>file-&gt;settings-&gt;project interpreter</code>，里面有很多的project interpreter。点击右边的设置，然后点击+，即可添加新的环境。如果他没有检索到我们使用的python环境，就需要手动添加。<br><img src="/images/20190505_1.png" alt><br>2、选择Existing environment，从目录里面选择自己需要使用的python环境。<br>如我在anaconda里面添加的新的虚拟环境就在下面这个目录下，找到<code>python.exe</code>添加即可。<br><img src="/images/20190505_2.png" alt><br>3、需要注意的是，在我的电脑里面，<code>C:\ProgramData</code>这个目录默认是隐藏的，所以无法直接从pycharm中找到这个目录。只需要找到这个隐藏文件夹，取消隐藏即可。<br><img src="/images/20190505_3.png" alt><br>4、选择好了环境之后，我们可以设置当前项目的环境<br><img src="/images/20190505_4.png" alt></p><p>5、在新建一个项目时，我们可以设置环境为已存在的，找到目录中这个环境，并勾选对所有项目生效。这样我们的默认环境设置就大功告成了。<br><img src="/images/20190505_5.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机树生成算法（就是树！）</title>
      <link href="/2019/04/02/sui-ji-shu-sheng-cheng-suan-fa-jiu-shi-shu/"/>
      <url>/2019/04/02/sui-ji-shu-sheng-cheng-suan-fa-jiu-shi-shu/</url>
      
        <content type="html"><![CDATA[<p>一个<strong>生成随机树（此树非彼数）的算法</strong>，树的结点编号从1开始，这个算法生成了树的结点个数、树的结点的权值、树的每条边的结点。<br>如下面是一棵10结点的二叉树的生成结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">-23 -44 -51 -9 13 51 62 11 -63 19 </span><br><span class="line">6 9</span><br><span class="line">6 4</span><br><span class="line">9 2</span><br><span class="line">9 3</span><br><span class="line">4 7</span><br><span class="line">4 1</span><br><span class="line">2 5</span><br><span class="line">2 8</span><br><span class="line">3 10</span><br></pre></td></tr></table></figure><hr><h1 id="第一次更新"><a href="#第一次更新" class="headerlink" title="第一次更新"></a>第一次更新</h1><p>想到一种O(n)复杂度的随机树生成算法。</p><p>设想有树结点1、2、3、4、5，生成它们的一个随机排列，如4、1、3、5、2；<br>那么，如果我们设定每个结点的子节点数量为2，或者设置其他区间（如[1, 3]）。<br>那么根节点就是4，它的子节点为1、3，以BFS的方式遍历生成子节点，1的子节点为5、2，就可以生成随机树了。</p><p>生成随机排列的算法复杂度为O(n)。<br>对于a[0], a[1], a[2], a[3], a[4]，如何生成随机排列？<br>获得x = random(0, 3)，（区间[0, 3]的下标），然后交换a[x], a[3]，就生成了一个随机值<br>接下来，x = random(0, 2),然后交换a[x], a[2]<br>不断地依次生成，就可以得到一个随机排列，且时间复杂度为O(n)。</p><p>所以整个算法的时间复杂度为O(n)。</p><p>下面的代码将生成随机排列和BFS遍历的过程融合在了一起，建议分开实现，更加清晰、模块化。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> random(a, b) rand()%(b-a+1) + a</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creatData</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">string</span> filename)</span> </span>&#123;</span><br><span class="line"><span class="function">fstream <span class="title">file</span><span class="params">(filename.c_str(), ios::out)</span></span>;</span><br><span class="line"><span class="keyword">int</span> *tree = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">tree[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> root = random(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">swap(tree[root], tree[n - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> nxt_idx = n - <span class="number">2</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Que;</span><br><span class="line">file &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">file &lt;&lt; random(<span class="number">-1024</span>, <span class="number">1024</span>) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line">file &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Que.push(tree[n - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">while</span> (!Que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> now = Que.front();</span><br><span class="line">Que.pop();</span><br><span class="line"><span class="keyword">int</span> cnt = random(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> tmp_idx = random(<span class="number">0</span>, nxt_idx); </span><br><span class="line">swap(tree[tmp_idx], tree[nxt_idx]);</span><br><span class="line">file &lt;&lt; now &lt;&lt; <span class="string">' '</span> &lt;&lt; tree[nxt_idx] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Que.push(tree[nxt_idx]);</span><br><span class="line">nxt_idx--;</span><br><span class="line"><span class="keyword">if</span> (nxt_idx == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (nxt_idx == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">creatData(<span class="number">10</span>, <span class="string">"creatTree10.txt"</span>);</span><br><span class="line">creatData(<span class="number">1000</span>, <span class="string">"creatTree1000.txt"</span>);</span><br><span class="line">creatData(<span class="number">10000</span>, <span class="string">"creatTree10000.txt"</span>);</span><br><span class="line">creatData(<span class="number">100000</span>, <span class="string">"creatTree100000.txt"</span>);</span><br><span class="line">creatData(<span class="number">1000000</span>, <span class="string">"creatTree1000000.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><hr><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><p>思路是将结点<br>编号1-n push进vector中，然后随机选一个点为root，并从vector中删除这个点。然后使用基于BFS的方式，从root扩展，随机选在（m, n）区间的子节点个数，同时使用随机方法获取在剩余的vector中获取子节点编号，然后从vector中删除。就这样不断地扩散，当vector的size为0时，说明无子节点可选，从而可以结束算法。</p><p>可以设置子节点的随机范围，结点权值的随机范围。</p><p>需要注意的是，该算法时间复杂度大概高达O(n^2)，生成100000个数据要40+s，所以要生成更大规模的数据需要较长的时间。</p><hr><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> random(a, b) rand()%(b-a+1) + a</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; que;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; seq;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteOne</span><span class="params">(<span class="keyword">int</span> one)</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = que.begin();</span><br><span class="line"><span class="keyword">while</span> (it != que.end()) &#123;</span><br><span class="line"><span class="keyword">if</span> (*it == one) &#123;</span><br><span class="line">que.erase(it);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">it++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">creat</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">string</span> filename)</span> </span>&#123;</span><br><span class="line">que.clear();</span><br><span class="line"><span class="function">fstream <span class="title">outfile</span><span class="params">(filename.c_str(), ios::out)</span></span>;</span><br><span class="line">outfile &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x = random(<span class="number">-64</span>, <span class="number">64</span>);</span><br><span class="line">outfile &lt;&lt; x &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">que.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">outfile &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> root = random(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">root = que[root];</span><br><span class="line"><span class="comment">//outfile &lt;&lt; "root = " &lt;&lt; root &lt;&lt; endl;</span></span><br><span class="line">deleteOne(root);</span><br><span class="line">seq.push(root);</span><br><span class="line"><span class="keyword">while</span> (que.size()) &#123;</span><br><span class="line"><span class="keyword">int</span> now = seq.front();</span><br><span class="line">seq.pop();</span><br><span class="line"><span class="keyword">int</span> ns = random(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 将子节点范围取做（2，2）就生成了二叉树 </span></span><br><span class="line"><span class="keyword">int</span> len = que.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ns; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x = random(<span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">outfile &lt;&lt; now &lt;&lt; <span class="string">' '</span> &lt;&lt; que[x] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">seq.push(que[x]);</span><br><span class="line">deleteOne(que[x]);</span><br><span class="line">len--;</span><br><span class="line"><span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">creat(<span class="number">10</span>, <span class="string">"creatTree10.txt"</span>);</span><br><span class="line">creat(<span class="number">1000</span>, <span class="string">"creatTree1000.txt"</span>);</span><br><span class="line">creat(<span class="number">10000</span>, <span class="string">"creatTree10000.txt"</span>);</span><br><span class="line">creat(<span class="number">100000</span>, <span class="string">"creatTree100000.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随机树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hands-on-ml chapter2 笔记1</title>
      <link href="/2019/03/30/handson-ml-chp2/"/>
      <url>/2019/03/30/handson-ml-chp2/</url>
      
        <content type="html"><![CDATA[<p>批量学习（batch learning），一次性批量输入给学习算法，可以被形象的称为填鸭式学习。<br>在线学习（online learning），按照顺序，循序的学习，不断的去修正模型，进行优化。</p><p>batch learning 如果数据很大的话，可以使用MapReduce技术，或者使用online learning。</p><p>performance measure 使用RMSE（root mean square error），也就是均方根误差。看<a href="https://www.jianshu.com/p/9ee85fdad150" target="_blank" rel="noopener">https://www.jianshu.com/p/9ee85fdad150</a> 。学到了root 是根号的意思。</p><p>hypothesis ：假设<br>outlier ：异常值</p><p>有很多异常值（很大）的话，可能倾向于用MAE。</p><blockquote><p>RMSE 和 MAE 都是测量预测值和目标值两个向量距离的方法。有多种测量距离的方法，或范数：<br>计算对应欧几里得范数的平方和的根（RMSE）：这个距离介绍过。它也称作ℓ2范数，标记为 （或只是 ）。<br>计算对应于ℓ1（标记为 ）范数的绝对值和（MAE）。有时，也称其为曼哈顿范数，因为它测量了城市中的两点，沿着矩形的边行走的距离。<br>更一般的，包含n个元素的向量v的ℓk范数（K 阶闵氏范数），定义成</p></blockquote><blockquote><p>ℓ0（汉明范数）只显示了这个向量的基数（即，非零元素的个数），ℓ∞（切比雪夫范数）是向量中最大的绝对值。</p></blockquote><blockquote><p>范数的指数越高，就越关注大的值而忽略小的值。这就是为什么 RMSE 比 MAE 对异常值更敏感。但是当异常值是指数分布的（类似正态曲线），RMSE 就会表现很好。</p></blockquote><p>entry ：条目，entries<br>histogram ：统计直方图<br>histogram ：后端</p><p>数据可能经过预处理，这不一定会出错，但你得知道数据是怎么来的。</p><p>feature scaling ：特征缩放</p><p>如果右边的属性很长，会处理这些属性，使其变为正态分布。 </p><p>P49：生成随机排列以获得比较随机的train和test集划分。random seed控制结果。<br>P50：使用hash方法来生成稳定的train、test集，当得到新的数据时，原来的划分保持不变，新的实例同样进行划分。<br>调用的库是hashlib，可以稍微研究一下python中的hash方法。<br>增加一列索引index。<br>可以使用scikit learn提供的函数</p><p>P51：讲到要使用分层采样，因为不同层次的样本数量是不一样的，如果全都随机采样的话，误差会比较大。<br>strata：层<br>stratify：分层<br>使用sklearn提供的分层类，配合pandas的where等，分层正确可以获得较大的性能提升。<br>还可以查看分层比例。</p><p>pandas的where方法</p><blockquote><p>Series.where(cond, other=nan, inplace=False, axis=None, level=None, errors=‘raise’, try_cast=False, raise_on_error=None)<br>如果 cond 为真，保持原来的值，否则替换为other， inplace为真标识在原数据上操作，为False标识在原数据的copy上操作。</p></blockquote><p>insight：见解，洞察力<br>density：密度</p><p>分析数据，数据的可视化：可以得到数据之间的联系，哪些数据更有用，从而更加有技巧地进行训练；而且，从数据的可视化中，就可以得出一些只是看数据得不到的结论，图像能使信息暴露出来，所以matplotlib在机器学习中会有那么重要的作用，而看到的哪些讲机器学习的书、比赛的notebook，他们都有大量的数据可视化，这是呈现数据，探索数据的过程，也是：为什么此模型能够比其他人的模型更加强大的原因。但是数据分析有套路，要多看熟悉这些套路。</p><p>alpha参数的作用：它是一个设置透明度的参数。看到书上用它时，觉得没啥用啊，不是每个点都会设置一样的透明度吗？但是转念一想，存在透明度的话，点多的地方，颜色就会深，而点少的地方颜色就会浅。这就是透明度的作用啊！</p><p>correlation：相关；关联<br>median：中位数<br>coefficient：率；系数<br>correlation coefficient：相关系数</p><p>可以使用corr方法获取属性两两之间的（linear）相关性。（可以说是很强了！没想到居然还提供了这种方法。不过相关系数是怎么计算的？）<br>得到了相关性，然后呢？有什么作用吗？<br>书上说：想要移除掉相关性大的属性，避免重复。所谓数据清洗。</p><p>属性的结合，可能会获取更加有效的数据。</p><p>数据清洗：missing features<br>三种策略<br>sklearn提供了一种Imputer类来实现确实数据的填充</p><p>要设计自己的读取、划分数据函数，一种通用的方法，能够对不同的数据进行划分。</p><p>想到一个问题：如何将自己写的类，在python中import？就像numpy那样？但是numpy不是一个类而是一个包，那么如何制作自己的包？</p><p>interfeace：接口</p><p>P61讲述了sklearn的设计风格<br>评估器、转换器等的设计模式，统一性。</p><p>将文本属性转化成数字。标签编码。</p><p>sklearn.preprocessing </p><p>独热编码OneHotEncoder</p><p>sparse matrix：稀疏矩阵。书上一般说SciPy sparse matrix</p><p>text attribute -&gt; num -&gt; one hot; text -&gt; one hot; 可选scipy</p><p>设计自定义的transformers，三种method，fit，transform，fit_transform。<br>使用两个基类，提供一些功能。</p><p>feature scaling：特征缩放<br>normalization、standardization(less attected by outliers)<br>只能向数据集拟合：这样更准确。</p><p>pipelines class<br>数值属性和文本属性的特征可以分开设置pipeline，然后可以使用FeatureUnion来合并，真是方便！不过这个pipeline的设计有点麻烦。</p><p>选择模型、拟合、计算error。<br>underfitting and overfitting<br>cross validation：交叉验证。比较可靠的评估方式。<br>utility function：效用函数。越大越好<br>cost function：成本函数。越小越好</p><p>overfitting的可怕，还以为放出决策树回归出来会吊打线性回归呢，结果被吊打了，哈哈。</p><p>ensemble learning：集成学习。如random forests</p><p>把模型和训练结果保存下来，以便以后的对比。<br>可以使用pickle，或者sklearn.externals.joblib。<br>可以说是很方便了。</p><p>fine tune：微调</p><p>超参数：hyperparameter</p><blockquote><p>在机器学习的上下文中，超参数是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。<br>在机器学习的上下文中，超参数是在开始学习过程之前设置值的参数。 相反，其他参数的值通过训练得出。<br>超参数：<br>定义关于模型的更高层次的概念，如复杂性或学习能力。<br>不能直接从标准模型培训过程中的数据中学习，需要预先定义。<br>可以通过设置不同的值，训练不同的模型和选择更好的测试值来决定</p></blockquote><p>超参数的一些示例：</p><ul><li>树的数量或树的深度</li><li>矩阵分解中潜在因素的数量</li><li>学习率（多种模式）</li><li>深层神经网络隐藏层数</li><li>k均值聚类中的簇数</li></ul><p>amazing Grid Search！直译是网格搜索，但是显然不能这么理解。<br>这是sklearn提供的一种超级方便的选择hyperparameter的工具，简直是开挂啊。fine tune果然不赖。<br>还有一些分析的技巧。不过话说想要选好一组适合的超参数要训练好多组啊。<br>甚至直接获取the best estimator</p><p>Randomized Search 和 Gird相比，有几个有点。但目的和作用是一样的。</p><p>Ensemble Method 集成方法</p><p>分析最佳模型和他们的误差，可以获得更深的对问题的理解。比如可以给出每个属性对于做出准确预测的相对重要性，然后去掉某些属性，是否会使得分类更加准确。</p><p>maintain：维护</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>csapp datalab实验</title>
      <link href="/2019/03/29/csapp-datalab-shi-yan/"/>
      <url>/2019/03/29/csapp-datalab-shi-yan/</url>
      
        <content type="html"><![CDATA[<p>datalab 实验</p><p>代码如下</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * CS:APP Data Lab </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * &lt;Please put your name and userid here&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * bits.c - Source file with your solutions to the Lab.</span></span><br><span class="line"><span class="comment"> *          This is the file you will hand in to your instructor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Do not include the &lt;stdio.h&gt; header; it confuses the dlc</span></span><br><span class="line"><span class="comment"> * compiler. You can still use printf for debugging without including</span></span><br><span class="line"><span class="comment"> * &lt;stdio.h&gt;, although you might get a compiler warning. In general,</span></span><br><span class="line"><span class="comment"> * it's not good practice to ignore compiler warnings, but in this</span></span><br><span class="line"><span class="comment"> * case it's OK.  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Instructions to Students:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * STEP 1: Read the following instructions carefully.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">You will provide your solution to the Data Lab by</span><br><span class="line">editing the collection of functions in <span class="keyword">this</span> source file.</span><br><span class="line"></span><br><span class="line">INTEGER CODING RULES:</span><br><span class="line"> </span><br><span class="line">  Replace the <span class="string">"return"</span> statement in each function with one</span><br><span class="line">  <span class="keyword">or</span> more lines of C code that implements the function. Your code </span><br><span class="line">  must conform to the following style:</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Funct</span><span class="params">(arg1, arg2, ...)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/* brief description of how your implementation works */</span></span><br><span class="line">      <span class="keyword">int</span> var1 = Expr1;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">int</span> varM = ExprM;</span><br><span class="line"></span><br><span class="line">      varJ = ExprJ;</span><br><span class="line">      ...</span><br><span class="line">      varN = ExprN;</span><br><span class="line">      <span class="keyword">return</span> ExprR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Each <span class="string">"Expr"</span> is an expression <span class="keyword">using</span> ONLY the following:</span><br><span class="line">  <span class="number">1.</span> Integer constants <span class="number">0</span> through <span class="number">255</span> (<span class="number">0xFF</span>), inclusive. You are</span><br><span class="line">      <span class="keyword">not</span> allowed to use big constants such as <span class="number">0xffffffff</span>.</span><br><span class="line">  2. Function arguments and local variables (no global variables).</span><br><span class="line">  <span class="number">3.</span> Unary integer operations ! ~</span><br><span class="line">  <span class="number">4.</span> Binary integer operations &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">    </span><br><span class="line">  Some of the problems <span class="keyword">restrict</span> the <span class="built_in">set</span> of allowed operators even further.</span><br><span class="line">  Each <span class="string">"Expr"</span> may consist of multiple operators. You are <span class="keyword">not</span> restricted to</span><br><span class="line">  one <span class="keyword">operator</span> per line.</span><br><span class="line"></span><br><span class="line">  You are expressly forbidden to:</span><br><span class="line">  <span class="number">1.</span> Use any control constructs such as <span class="keyword">if</span>, <span class="keyword">do</span>, <span class="keyword">while</span>, <span class="keyword">for</span>, <span class="keyword">switch</span>, etc.</span><br><span class="line">  <span class="number">2.</span> Define <span class="keyword">or</span> use any macros.</span><br><span class="line">  <span class="number">3.</span> Define any additional functions in <span class="keyword">this</span> file.</span><br><span class="line">  <span class="number">4.</span> Call any functions.</span><br><span class="line">  <span class="number">5.</span> Use any other operations, such as &amp;&amp;, ||, -, <span class="keyword">or</span> ?:</span><br><span class="line">  <span class="number">6.</span> Use any form of casting.</span><br><span class="line">  <span class="number">7.</span> Use any data type other than <span class="keyword">int</span>.  This implies that you</span><br><span class="line">     cannot use arrays, structs, <span class="keyword">or</span> unions.</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  You may assume that your machine:</span><br><span class="line">  <span class="number">1.</span> Uses <span class="number">2</span>s complement, <span class="number">32</span>-bit representations of integers.</span><br><span class="line">  <span class="number">2.</span> Performs right shifts arithmetically.</span><br><span class="line">  <span class="number">3.</span> Has unpredictable behavior when shifting an integer by more</span><br><span class="line">     than the word size.</span><br><span class="line"></span><br><span class="line">EXAMPLES OF ACCEPTABLE CODING STYLE:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * pow2plus1 - returns 2^x + 1, where 0 &lt;= x &lt;= 31</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">pow2plus1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* exploit ability of shifts to compute powers of 2 */</span></span><br><span class="line">     <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; x) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * pow2plus4 - returns 2^x + 4, where 0 &lt;= x &lt;= 31</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">pow2plus4</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/* exploit ability of shifts to compute powers of 2 */</span></span><br><span class="line">     <span class="keyword">int</span> result = (<span class="number">1</span> &lt;&lt; x);</span><br><span class="line">     result += <span class="number">4</span>;</span><br><span class="line">     <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">FLOATING POINT CODING RULES</span><br><span class="line"></span><br><span class="line">For the problems that require you to implent floating-point operations,</span><br><span class="line">the coding rules are less strict.  You are allowed to use looping <span class="keyword">and</span></span><br><span class="line">conditional control.  You are allowed to use both ints <span class="keyword">and</span> unsigneds.</span><br><span class="line">You can use arbitrary integer <span class="keyword">and</span> <span class="keyword">unsigned</span> constants.</span><br><span class="line"></span><br><span class="line">You are expressly forbidden to:</span><br><span class="line">  <span class="number">1.</span> Define <span class="keyword">or</span> use any macros.</span><br><span class="line">  <span class="number">2.</span> Define any additional functions in <span class="keyword">this</span> file.</span><br><span class="line">  <span class="number">3.</span> Call any functions.</span><br><span class="line">  <span class="number">4.</span> Use any form of casting.</span><br><span class="line">  <span class="number">5.</span> Use any data type other than <span class="keyword">int</span> <span class="keyword">or</span> <span class="keyword">unsigned</span>.  This means that you</span><br><span class="line">     cannot use arrays, structs, <span class="keyword">or</span> unions.</span><br><span class="line">  <span class="number">6.</span> Use any floating point data types, operations, <span class="keyword">or</span> constants.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTES:</span><br><span class="line">  <span class="number">1.</span> <span class="function">Use the <span class="title">dlc</span> <span class="params">(data lab checker)</span> <span class="title">compiler</span> <span class="params">(described in the handout)</span> to </span></span><br><span class="line">     check the legality of your solutions.</span><br><span class="line">  <span class="number">2.</span> <span class="function">Each function has a maximum number of <span class="title">operators</span> <span class="params">(! ~ &amp; ^ | + &lt;&lt; &gt;&gt;)</span></span></span><br><span class="line">     that you are allowed to use for your implementation of the function. </span><br><span class="line">     The max <span class="keyword">operator</span> count is checked by dlc. Note that <span class="string">'='</span> is <span class="keyword">not</span> </span><br><span class="line">     counted; you may use as many of these as you want without penalty.</span><br><span class="line">  <span class="number">3.</span> Use the btest test harness to check your functions <span class="keyword">for</span> correctness.</span><br><span class="line">  <span class="number">4.</span> Use the BDD checker to formally verify your functions</span><br><span class="line">  <span class="number">5.</span> The maximum number of ops <span class="keyword">for</span> each function is given in the</span><br><span class="line">     header comment <span class="keyword">for</span> each function. If there are any inconsistencies </span><br><span class="line">     between the maximum ops in the writeup <span class="keyword">and</span> in <span class="keyword">this</span> file, consider</span><br><span class="line">     <span class="keyword">this</span> file the authoritative source.</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * STEP 2: Modify the following functions according the coding rules.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *   IMPORTANT. TO AVOID GRADING SURPRISES:</span></span><br><span class="line"><span class="comment"> *   1. Use the dlc compiler to check that your solutions conform</span></span><br><span class="line"><span class="comment"> *      to the coding rules.</span></span><br><span class="line"><span class="comment"> *   2. Use the BDD checker to formally verify that your solutions produce </span></span><br><span class="line"><span class="comment"> *      the correct answers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitAnd - x&amp;y using only ~ and | </span></span><br><span class="line"><span class="comment"> *   Example: bitAnd(6, 5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ |</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~((~x)|(~y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * getByte - Extract byte n from word x</span></span><br><span class="line"><span class="comment"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span></span><br><span class="line"><span class="comment"> *   Examples: getByte(0x12345678,1) = 0x56</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 6</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tmp = ((x &lt;&lt; ((<span class="number">4</span> + (~n)) &lt;&lt; <span class="number">3</span>)) &gt;&gt; <span class="number">24</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> tmp&amp;<span class="number">0x000000ff</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">????Byte???????????????????24????????????????????n????????????????(3 - n = 3 + ~n + 1) &lt;&lt; 3????????</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class="line"><span class="comment"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 20</span></span><br><span class="line"><span class="comment"> *   Rating: 3 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t = (<span class="number">0x1</span> &lt;&lt; <span class="number">31</span>) ^ ((!n) &lt;&lt; <span class="number">31</span>);</span><br><span class="line"><span class="keyword">return</span> (x &gt;&gt; n) &amp; ~(t &gt;&gt; (n + ~<span class="number">1</span> + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">??????????????????????1???????n = 0?????????????????</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitCount - returns count of number of 1's in word</span></span><br><span class="line"><span class="comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 40</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// ??????????????2?4?8?16?32?01??1???? </span></span><br><span class="line">    <span class="keyword">int</span> bitcount;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmp1 = (<span class="number">0x55</span>)|(<span class="number">0x55</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">int</span> mask1 = (tmp1)|(tmp1&lt;&lt;<span class="number">16</span>);  <span class="comment">//????? 01010101��01010101</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmp2 = (<span class="number">0x33</span>)|(<span class="number">0x33</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">int</span> mask2 = (tmp2)|(tmp2&lt;&lt;<span class="number">16</span>);  <span class="comment">//????? 00110011��00110011</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> tmp3 = (<span class="number">0x0f</span>)|(<span class="number">0x0f</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">int</span> mask3 = (tmp3)|(tmp3&lt;&lt;<span class="number">16</span>);  <span class="comment">//????? 00001111��00001111</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mask4 = (<span class="number">0xff</span>)|(<span class="number">0xff</span>&lt;&lt;<span class="number">16</span>);          <span class="comment">//????? 0000 0000 1111 1111 0000 0000 1111 1111</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mask5 = (<span class="number">0xff</span>)|(<span class="number">0xff</span>&lt;&lt;<span class="number">8</span>);           <span class="comment">//????? 0000 0000 0000 0000 1111 1111 1111 1111</span></span><br><span class="line">    </span><br><span class="line">    bitcount = (x &amp; mask1) + ((x&gt;&gt;<span class="number">1</span>) &amp; mask1);       <span class="comment">//??????2??????1??????????2??????1???????? </span></span><br><span class="line">    bitcount = (bitcount &amp; mask2) + ((bitcount &gt;&gt; <span class="number">2</span>) &amp; mask2);</span><br><span class="line">    bitcount = (bitcount + (bitcount &gt;&gt; <span class="number">4</span>)) &amp; mask3;</span><br><span class="line">    bitcount = (bitcount + (bitcount &gt;&gt; <span class="number">8</span>)) &amp; mask4;</span><br><span class="line">    bitcount = (bitcount + (bitcount &gt;&gt; <span class="number">16</span>)) &amp; mask5;</span><br><span class="line">    <span class="keyword">return</span> bitcount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bang - Compute !x without using !</span></span><br><span class="line"><span class="comment"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = ~x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ((t | x) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//??0??+1????0?????x?0?????31???0?+1?????1. ????????????????????????????????31??????-1?+1?????0.</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ???????????1????31??????????????????</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class="line"><span class="comment"> *  n-bit, two's complement integer.</span></span><br><span class="line"><span class="comment"> *   1 &lt;= n &lt;= 32</span></span><br><span class="line"><span class="comment"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// x????n???? ??32-n????32-n????????? </span></span><br><span class="line"><span class="keyword">int</span> shift = <span class="number">32</span> + ~n + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t = x &lt;&lt; shift &gt;&gt; shift;</span><br><span class="line"><span class="keyword">return</span> !(t ^ x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x?????n???? ??32-n????32-n????????????????</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class="line"><span class="comment"> *  Round toward zero</span></span><br><span class="line"><span class="comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// ?????????????????????????????????????-5/2 = -3??? </span></span><br><span class="line">    <span class="keyword">int</span> sign = x &gt;&gt; <span class="number">31</span>; <span class="comment">// ?? </span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; (1 &lt;&lt; n) + ~0 &lt;&lt; endl; </span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; "(sign &amp; ((1 &lt;&lt; n) + ~0)) = " &lt;&lt; (sign &amp; ((1 &lt;&lt; n) + ~0)) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> (x + (sign &amp; ((<span class="number">1</span> &lt;&lt; n) + ~<span class="number">0</span>))) &gt;&gt; n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ???????0???????????????????-5/2 = -3???????0????????????????????????????????????</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ?????????+1.</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Example: isPositive(-1) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (!((x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>) &amp; !!(x)); <span class="comment">// ????????????0</span></span><br><span class="line"> <span class="comment">// ????????????????</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ????????????0</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// ??????????</span></span><br><span class="line"><span class="keyword">int</span> xl = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> yl = (y &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> zl = ((y + ~x + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> ((xl ^ yl) &amp; xl) | (!(xl ^ yl) &amp; !zl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ??????????????isPositive?????????????????????</span></span><br><span class="line"><span class="comment">// ???????????????x&lt;0?y&gt;=0,????????1???????????y-x???????0???x????y?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class="line"><span class="comment"> *   Example: ilog2(16) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 90</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// ???????1???+?????&lt;&lt;????????? </span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">id = (!!(x &gt;&gt; <span class="number">16</span>)) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">id = id + ((!!(x &gt;&gt; (id + <span class="number">8</span>))) &lt;&lt; <span class="number">3</span>);</span><br><span class="line">id = id + ((!!(x &gt;&gt; (id + <span class="number">4</span>))) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">id = id + ((!!(x &gt;&gt; (id + <span class="number">2</span>))) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">id = id + ((!!(x &gt;&gt; (id + <span class="number">1</span>))) &lt;&lt; <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ??????log2?log2n?????????1???????????????1???????16?????????????????id??????id???????+?????&lt;&lt;????????? </span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> tmp = (uf &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (((tmp &amp; <span class="number">0xFF000000</span>) == <span class="number">0xFF000000</span>) &amp;&amp; (tmp != <span class="number">0xFF000000</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> uf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (uf + <span class="number">0x80000000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1????????NAN??????????NAN</span></span><br><span class="line"><span class="comment">// 2?????????????????????????????????????????????????+1??????????????</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class="line"><span class="comment"> *   Result is returned as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// ????????????????????????????? </span></span><br><span class="line"><span class="keyword">int</span> sign, id, shr, mid;</span><br><span class="line"><span class="keyword">unsigned</span> tmp; </span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">sign = x &amp; <span class="number">0x80000000</span>;</span><br><span class="line"><span class="keyword">if</span> (sign) x = -x;</span><br><span class="line">id = <span class="number">-1</span>;</span><br><span class="line">tmp = x;</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">tmp &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">id++; <span class="comment">// x = 5, id = 2, ??????1?? </span></span><br><span class="line">&#125;</span><br><span class="line">tmp = x &lt;&lt; (<span class="number">32</span> - id); <span class="comment">// 23???????? </span></span><br><span class="line">shr = (tmp &amp; <span class="number">0x1ff</span>) &gt;&gt; <span class="number">1</span>; <span class="comment">// ???? </span></span><br><span class="line">tmp = tmp &gt;&gt; <span class="number">9</span>; <span class="comment">// ?????</span></span><br><span class="line">mid = (<span class="number">127</span> + id) &lt;&lt; <span class="number">23</span>; <span class="comment">// ???</span></span><br><span class="line"><span class="keyword">if</span> (shr &gt; <span class="number">128</span> || (shr == <span class="number">128</span> &amp;&amp; (tmp &amp; <span class="number">1</span>) == <span class="number">1</span>)) &#123;</span><br><span class="line">tmp = tmp + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (tmp + mid + sign);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interfrpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s = uf &amp; <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">int</span> e = uf &amp; <span class="number">0x7f800000</span>;</span><br><span class="line">  <span class="keyword">int</span> m = uf &amp; <span class="number">0x007fffff</span>;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (e == <span class="number">0x7f800000</span>) <span class="keyword">return</span> uf;</span><br><span class="line">  <span class="keyword">if</span> (e == <span class="number">0</span>) ans = s + (m &lt;&lt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">else</span>  ans = s + e + <span class="number">0x00800000</span> + m;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ????????????M??????????</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> csapp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编与gdb调试学习</title>
      <link href="/2019/03/09/hui-bian-yu-gdb-diao-shi-xue-xi/"/>
      <url>/2019/03/09/hui-bian-yu-gdb-diao-shi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h4 id="1、在gdb中如何列出汇编代码"><a href="#1、在gdb中如何列出汇编代码" class="headerlink" title="1、在gdb中如何列出汇编代码"></a>1、在gdb中如何列出汇编代码</h4><p>应该是不可以用list 命令列出汇编代码的。<br>但可以使用<code>display /i $pc</code> 命令在调试的时候出了列出一行源码，也列出相应的汇编代码<br>同时，s和si等的区别还是比较大的：si按汇编一行一行执行，有的源码一行会有很多条汇编；<br>我认为这是个学习汇编的好方法：<strong>使用gdb一步一步调试，对比汇编和源码</strong></p><h4 id="2、如何将一个可执行文件或者是-o文件得到它的汇编码或者是源码？"><a href="#2、如何将一个可执行文件或者是-o文件得到它的汇编码或者是源码？" class="headerlink" title="2、如何将一个可执行文件或者是.o文件得到它的汇编码或者是源码？"></a>2、如何将一个可执行文件或者是.o文件得到它的汇编码或者是源码？</h4><p>可以使用<code>objdump -d test.out</code> 获取汇编代码（右侧）以及机器码（左侧）；要查看但里面有很多除我写的东西之外的东西，要具体定位到自己写的东西，可根据函数名查看。</p><p>如果编译时<strong>使用了-g参数</strong>的话，使用<code>objdump -dS test</code> 就可以得到机器码，源码，汇编码一一对应了！但如果没用-g的话，可执行文件是没有源码信息的，这时需要通过特殊手段得到。</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0wz27sv1rj30s60gwjy7.jpg" alt="在这里插入图片描述"></p><h4 id="3、将c源码变成-o文件，会不会很干净，和变成可执行文件的区别？体量？"><a href="#3、将c源码变成-o文件，会不会很干净，和变成可执行文件的区别？体量？" class="headerlink" title="3、将c源码变成.o文件，会不会很干净，和变成可执行文件的区别？体量？"></a>3、将c源码变成.o文件，会不会很干净，和变成可执行文件的区别？体量？</h4><p>编译过程图，来源：<a href="https://blog.csdn.net/misskissC/article/details/38020151" target="_blank" rel="noopener">https://blog.csdn.net/misskissC/article/details/38020151</a><br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0wz3cnv22j30dk07874k.jpg" alt="在这里插入图片描述"><br>和期待的相符，没有目标文件的链接过程，.o 文件果然很干净，使用-d命令查看的话，可以只看我自己写的代码部分！但是没有 -g 的话没有源码。<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0wz3qgssaj30uu0t3dpz.jpg" alt="在这里插入图片描述"><br>同样和期待的相符，加了-g之后，成功出现源码<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz49e2xnj30r30oyq8r.jpg" alt="在这里插入图片描述"></p><h4 id="4、c代码变成-s文件，如何精确捕捉到我写的函数的内容？"><a href="#4、c代码变成-s文件，如何精确捕捉到我写的函数的内容？" class="headerlink" title="4、c代码变成.s文件，如何精确捕捉到我写的函数的内容？"></a>4、c代码变成.s文件，如何精确捕捉到我写的函数的内容？</h4><p>额，我发现.s 文件还是非常干净的，没有什么特别多的其他文件，想要找哪个函数，前面都有名字的。 尝试是由-g会有什么区别码？<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz4p1qm5j30hd0kt41y.jpg" alt="在这里插入图片描述"><br>加了-g 参数后，生成的.s 文件果然多了很多不认识的东西，仔细找了下后，发现并没有看到源码的字符串，可能是以某种特殊的方式编码了？如图是对比，左侧是加了 -g的，而右侧是没有加的。<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0wz509prej31el0k5wmu.jpg" alt="在这里插入图片描述"><br>我们来验证以下，这个加了-g的.s文件，是否真的是包含了我源码的信息？</p><p>验证通过，确实有，哈哈<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz5i91ybj30nn0scq9h.jpg" alt="在这里插入图片描述"></p><h4 id="5、各种情况的编译失败是在编译的过程是哪一步？"><a href="#5、各种情况的编译失败是在编译的过程是哪一步？" class="headerlink" title="5、各种情况的编译失败是在编译的过程是哪一步？"></a>5、各种情况的编译失败是在编译的过程是哪一步？</h4><p>在编译c语言的时候，通常是一步全编译，我们来尝试分部编译，探究不同错误的编译失败地点。<br>1、如果我只是写一个函数而没有main函数，可以进行到哪一步？<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz5u0tlsj30er05s3yw.jpg" alt="在这里插入图片描述"><br>编译成汇编代码居然就报错了！预处理的话还是可以的<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0wzcl23cbj30vx05176q.jpg" alt="在这里插入图片描述"></p><p>2、不小心没写分号 ;<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz6h56eaj30pi09kq3z.jpg" alt="在这里插入图片描述"><br>额，看来还是这个源码变成汇编的过程过程<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz6uqm52j30mu03kabl.jpg" alt="在这里插入图片描述"><br>我突然想到，整个编译的大过程分为<code>预处理-&gt;编译-&gt;汇编-&gt;链接</code>，那么可能语法问题之类的都是在<code>编译</code>这个小过程被发现的吧。</p><h4 id="6、list命令用法"><a href="#6、list命令用法" class="headerlink" title="6、list命令用法"></a>6、list命令用法</h4><p>默认显示10行，可使用<code>list 1,1000</code> 来获取更多行的代码<br>使用<code>list +/-</code> 用以继续，和查看更前的源码<br><code>set listsize 20</code> 设置显示行数<br><code>show listsize</code> 查看显示行数</p><h4 id="7、删除断点：d-b"><a href="#7、删除断点：d-b" class="headerlink" title="7、删除断点：d b"></a>7、删除断点：<code>d b</code></h4><p>查看断点：<br><code>info b</code><br><code>info watch</code></p><hr><p>查表<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz788t0zj30u30gtjsb.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python查看包版本、全部可更新包、更新单个包、更新全部包</title>
      <link href="/2019/03/07/python-cha-kan-bao-ban-ben-quan-bu-ke-geng-xin-bao-geng-xin-dan-ge-bao-geng-xin-quan-bu-bao/"/>
      <url>/2019/03/07/python-cha-kan-bao-ban-ben-quan-bu-ke-geng-xin-bao-geng-xin-dan-ge-bao-geng-xin-quan-bu-bao/</url>
      
        <content type="html"><![CDATA[<h3 id="一、如何查看python某个包的版本？"><a href="#一、如何查看python某个包的版本？" class="headerlink" title="一、如何查看python某个包的版本？"></a>一、如何查看python某个包的版本？</h3><p>1、<code>pip list</code>  // 全部，在里面找</p><p>2、<code>pip freeze</code> // 全部</p><p>3、<code>pip show numpy</code> // 单个</p><p>4、<code>conda list numpy</code> // 单个</p><h3 id="二、列出全部outdated（可更新）的包"><a href="#二、列出全部outdated（可更新）的包" class="headerlink" title="二、列出全部outdated（可更新）的包"></a>二、列出全部outdated（可更新）的包</h3><p><code>pip list  --outdated --format=legacy</code>  </p><p><code>pip list  --outdated --format=columns</code></p><p>这两个命令的区别是列表的方式不一样。且他们的命令执行时间都非常的长。</p><h3 id="三、更新单个包如numpy"><a href="#三、更新单个包如numpy" class="headerlink" title="三、更新单个包如numpy"></a>三、更新单个包如numpy</h3><p><code>pip install --upgrade numpy</code></p><p>或者</p><p><code>pip install -U numpy</code></p><h3 id="四、更新全部包"><a href="#四、更新全部包" class="headerlink" title="四、更新全部包"></a>四、更新全部包</h3><p>需要用到一个叫pip-review的执行程序</p><p>首先通过pip下载<code>pip install pip-review</code></p><p>然后执行以下命令：<code>pip-review --local --interactive</code></p><p>或者执行下面python程序</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pip._internal.utils.misc <span class="keyword">import</span> get_installed_distributions</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> call</span><br><span class="line"><span class="keyword">for</span> dist <span class="keyword">in</span> get_installed_distributions():</span><br><span class="line">    call(<span class="string">"pip install --upgrade "</span> + dist.project_name, shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>:（  不过更新全部包不是非常靠谱，毕竟更新一个包都经常出问题！何况是更新所有的。</p><h3 id="五、卸载包的方法"><a href="#五、卸载包的方法" class="headerlink" title="五、卸载包的方法"></a>五、卸载包的方法</h3><p>和安装的方法类似</p><p><code>pip uninstall numpy</code></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
            <tag> Anaconda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu常见命令及使用技巧</title>
      <link href="/2019/03/02/ubuntu-chang-jian-ming-ling-ji-shi-yong-ji-qiao/"/>
      <url>/2019/03/02/ubuntu-chang-jian-ming-ling-ji-shi-yong-ji-qiao/</url>
      
        <content type="html"><![CDATA[<p><a href="http://man.linuxde.net/" target="_blank" rel="noopener">一个查询Linux命令比较方便的网址http://man.linuxde.net/</a></p><hr><p>1、在ubuntu 12.04系统中，使用Ctrl+Alt+F1~6切换到shell，使用Ctrl+Alt+F7切换到图形界面</p><p>2、使用touch新建一个文件</p><p>3、在命令前使用sudo获取root权限</p><p>4、使用nano进入nano编辑器，比用vi进入的vim编辑器使用更简便</p><p>5、安装g++使用 sudo apt-get install g++</p><p>6、查看gcc位置使用 which gcc</p><p>7、使用rm删除文件</p><p>8、使用mv移动文件，也可以移动目录</p><p>9、g++编译文件时，-o参数给文件命名， g++ test.cpp -o program_name</p><p>10、ls列出当前目录下的文件列表</p><p>11、pwd输出当前工作区目录</p><p>12、cd转到某一指定目录</p><p>13、mkdir新建目录（文件夹）</p><p>14、rmdir删除目录</p><p>15、cp复制文件</p><p>16、cat在终端上显示文本信息</p><p>17、grep文本搜索工具</p><p>18、tar文件压缩命令</p><p>19、在终端，可以使用shift + PgUp/PgDn 进行翻页</p><p>20、在终端，可以将输出的文本重定向到某一文件如see.txt，然后使用cat（或其他）查看，然后使用cat see.txt | more，或者cat see.txt | less. 一页一页查看</p><p>21、exit，终止当前的终端会话</p><p>22、who显示目前登录系统的用户信息</p><p>23、ping测试网络</p><p>24、ctrl + q 退出程序</p><p>25、axel与aria2c据说比wget更快的多线程下载。</p><p>26、<code>sudo dpkg -i 软件包名.deb</code> 安装deb文件</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高斯朴素贝叶斯方法进行鸢尾花分类</title>
      <link href="/2018/11/17/gao-si-po-su-bei-xie-si-fang-fa-jin-xing-yuan-wei-hua-fen-lei/"/>
      <url>/2018/11/17/gao-si-po-su-bei-xie-si-fang-fa-jin-xing-yuan-wei-hua-fen-lei/</url>
      
        <content type="html"><![CDATA[<h3 id="贝叶斯方法完整代码"><a href="#贝叶斯方法完整代码" class="headerlink" title="贝叶斯方法完整代码"></a>贝叶斯方法完整代码</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns  </span><br><span class="line">iris = sns.load_dataset(<span class="string">'iris'</span>)</span><br><span class="line"></span><br><span class="line">X_iris = iris.drop(<span class="string">'species'</span>, axis=<span class="number">1</span>)</span><br><span class="line">y_iris = iris[<span class="string">'species'</span>]</span><br><span class="line"></span><br><span class="line">print(X_iris)</span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain, Xtest, ytrain, ytest = train_test_split(X_iris, y_iris, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line">model = GaussianNB()</span><br><span class="line">model.fit(Xtrain, ytrain)</span><br><span class="line">y_model = model.predict(Xtest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line">accuracy_score(ytest, y_model)</span><br></pre></td></tr></table></figure><hr><h2 id="步骤分析"><a href="#步骤分析" class="headerlink" title="步骤分析"></a>步骤分析</h2><h3 id="一-首先获取数据"><a href="#一-首先获取数据" class="headerlink" title="一-首先获取数据."></a>一-首先获取数据.</h3><p>这里我们在线导入seaborn库的iris(鸢尾花)数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">iris = sns.load_dataset(<span class="string">'iris'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://github.com/mwaskom/seaborn-data" target="_blank" rel="noopener">这是github上的说明</a>, 可直接下载csv文件</p><h3 id="二-将数据格式化"><a href="#二-将数据格式化" class="headerlink" title="二-将数据格式化"></a>二-将数据格式化</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_iris = iris.drop(<span class="string">'species'</span>, axis=<span class="number">1</span>)</span><br><span class="line">y_iris = iris[<span class="string">'species'</span>]</span><br></pre></td></tr></table></figure><p>将类别那一列删除生成新的对象赋值给X_iris, y_iris为分类.<br><a href="https://blog.csdn.net/sinat_32547403/article/details/73822660" target="_blank" rel="noopener">pandas的drop方法参考</a></p><h3 id="三-将数据切分为训练数据和测试数据"><a href="#三-将数据切分为训练数据和测试数据" class="headerlink" title="三-将数据切分为训练数据和测试数据"></a>三-将数据切分为训练数据和测试数据</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line">Xtrain, Xtest, ytrain, ytest = train_test_split(X_iris, y_iris, random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>cross validation</code>是<strong>交叉验证</strong>的意思, <a href="https://blog.csdn.net/CherDW/article/details/54881167" target="_blank" rel="noopener">参考文章</a><br>参数<code>random_state</code>是固定的随机种子, <a href="http://sofasofa.io/forum_main_post.php?postid=1001204" target="_blank" rel="noopener">参考文章</a></p><h3 id="四-调用高斯朴素贝叶斯实现训练"><a href="#四-调用高斯朴素贝叶斯实现训练" class="headerlink" title="四-调用高斯朴素贝叶斯实现训练"></a>四-调用高斯朴素贝叶斯实现训练</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.naive_bayes <span class="keyword">import</span> GaussianNB</span><br><span class="line">model = GaussianNB()</span><br><span class="line">model.fit(Xtrain, ytrain)</span><br><span class="line">y_model = model.predict(Xtest) # 进行预测</span><br></pre></td></tr></table></figure><p>调用<code>Gaussian naive Bayes</code>模型, 并进行拟合, 预测</p><h3 id="五-对测试结果进行评估"><a href="#五-对测试结果进行评估" class="headerlink" title="五-对测试结果进行评估"></a>五-对测试结果进行评估</h3><p><a href="https://blog.csdn.net/CherDW/article/details/55813071" target="_blank" rel="noopener">评估方法介绍</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score</span><br><span class="line">accuracy_score(ytest, y_model)</span><br></pre></td></tr></table></figure><p>得到准确率为<code>0.9736842105263158</code><br><code>metrics</code>是指标的意思.</p><p>说明对特征明显的数据, 即使是非常简单的分类算法也可以高效地进行分析.</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA*算法解十六宫格拼图问题</title>
      <link href="/2018/10/01/ida-star-suan-fa-jie-shi-liu-gong-ge-pin-tu-wen-ti/"/>
      <url>/2018/10/01/ida-star-suan-fa-jie-shi-liu-gong-ge-pin-tu-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>IDA*算法, ID(Iterative Deepening)指的是迭代加深. 它的思想是重复进行限制最大深度的深度优先搜索(此限制从某个最小值遍历到最大值), 也称为深度受限搜索.</p><p>一般情况下, 为了提高搜索速度, 迭代加深不会记录已搜索过的状态, <strong>但同时, 需要做一些调整, 以避免出现马上回溯到上一状态的情况.</strong></p><hr><p>IDA*算法的步骤</p><p>1) 首先对初始状态进行评估, 评估值作为最小限度, 而最大限度为自己的设置.<br>这个评估值在这个问题中可以用此状态到正确状态的每个位置的曼哈顿距离来表示.</p><p>2) 从最小限度到最大限度进行遍历, 此值作为当前dfs的限度值, 这个限度不断在有效范围内递增的过程就称作迭代加深</p><p>3) 进行dfs, 调整状态, 将新状态加入到新的dfs中, 直到找到了一个解(由于迭代加深, 此解为最优解). 进行回溯, 加入路径, 算法结束.</p><p>PS. 如果在限度内都没有找到解, 就输出<code>unsolved</code>. </p><p>从上面的分析中可见, 即使是IDA*算法, 其局限性依然很大, 比如它需要设置一个最大限制, 而超出这个限制的状态将无法求解出. </p><hr><p>一些解释:</p><ol><li><p><strong>曼哈顿距离预处理, 每个点在另一个位置的曼哈顿距离16*16</strong><br>x坐标距离 <code>abs(i / N - j / N)</code><br>y坐标距离 <code>abs(i % N - j % N)</code><br>曼哈顿距离可以将x坐标和y坐标相互独立开来, 且曼哈顿距离是相对的. 而在上面的表达式中, 可以理解为他们以(0, 0)为参照点;<br>即<code>abs((i / N - 0 - (j / N - 0))</code></p></li><li><p><strong>状态的定义</strong><br>在这个IDA*算法中, 每个状态包含了以下信息.<br> 1) 16个数的位置<br> 2) 空格所在位置<br> 3) 当前状态距离正确状态的曼哈顿距离<br> 简单的结构体可实现</p></li><li><p><strong>dfs难道要遍历所有可能的情况? 不, 别忘了我们是迭代加深(Iterative Deepeni)!</strong><br>所谓迭代, 就是一代一代更迭, 所以, 既然我们确定了最大范围(LIMIT), 那么我们就可以在这个范围里再设置范围限制, 然后搜索(dfs).<br>每当找到了一个解, 这个解就是最优解, 因为更优解在我们之前的搜索中没有出现.</p></li><li><p><strong>不会绕圈吗?</strong><br>答: 会绕圈, 但是不会有很大影响, 因为我们设置了搜索次数, 所以绕圈多消耗步骤的自然会淘汰掉.</p></li><li><p><strong>如何理解<code>sum += MDT[i][pz.f[i] - 1];</code></strong><br><code>MDT[i][pz.f[i] - 1]</code>这个状态可以理解为, 在第i格位置, 当它的值为<code>pz.f[i]</code>时, 他们的曼哈顿距离之差. 为什么要减一? 因为输入的值为<code>1...15</code>, 而代码中都位置下标都是从0开始的.</p></li></ol><hr><p>IDA*完整代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N2 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIMIT 57</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> dir[<span class="number">4</span>] = &#123;<span class="string">'r'</span>, <span class="string">'u'</span>, <span class="string">'l'</span>, <span class="string">'d'</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> MDT[N2][N2];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Puzzle</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> f[N2], space, MD; <span class="comment">// 位置, 空格, 曼哈顿距离</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Puzzle state;</span><br><span class="line"><span class="keyword">int</span> limit;</span><br><span class="line"><span class="keyword">int</span> path[LIMIT];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getALLMD</span><span class="params">(Puzzle pz)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N2; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (pz.f[i] == N2) <span class="keyword">continue</span>;</span><br><span class="line">sum += MDT[i][pz.f[i] - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSolved</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N2; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (state.f[i] != i + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> depth, <span class="keyword">int</span> prev)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (state.MD == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 搜索到了答案.</span></span><br><span class="line"><span class="keyword">if</span> (depth + state.MD &gt; limit) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 超过当前迭代限制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sx = state.space / N;</span><br><span class="line"><span class="keyword">int</span> sy = state.space % N;</span><br><span class="line">Puzzle tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">4</span>; ++r) &#123;</span><br><span class="line"><span class="keyword">int</span> tx = sx + dx[r];</span><br><span class="line"><span class="keyword">int</span> ty = sy + dy[r];</span><br><span class="line"><span class="keyword">if</span> (tx &lt; <span class="number">0</span> || ty &lt; <span class="number">0</span> || tx &gt;= N || ty &gt;= N) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (max(prev, r) - min(prev, r) == <span class="number">2</span>) <span class="keyword">continue</span>; <span class="comment">// 妙! 避免迂回. 减少了很多不必要搜索</span></span><br><span class="line">tmp = state;</span><br><span class="line"></span><br><span class="line">state.MD -= MDT[tx * N + ty][state.f[tx * N + ty] - <span class="number">1</span>]; <span class="comment">// 消除原位置的曼哈顿距离</span></span><br><span class="line">state.MD += MDT[sx * N + sy][state.f[tx * N + ty] - <span class="number">1</span>]; <span class="comment">// 添加新位置的曼哈顿距离, 注意, MDT由非0/16产生</span></span><br><span class="line">swap(state.f[tx * N + ty], state.f[sx * N + sy]);</span><br><span class="line">state.space = tx * N + ty;</span><br><span class="line"><span class="keyword">if</span> (dfs(depth + <span class="number">1</span>, r)) &#123; <span class="comment">// 先搜索, 搜索成功后再添加路径. 巧妙, 值得学习</span></span><br><span class="line">path[depth] = r;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">state = tmp; <span class="comment">// 回溯复原</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">iterative_deepening</span><span class="params">(Puzzle in)</span> </span>&#123;</span><br><span class="line">in.MD = getALLMD(in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (limit = in.MD; limit &lt;= LIMIT; limit++) &#123; <span class="comment">// 绝了, 原来是这样加一个常数</span></span><br><span class="line">state = in;</span><br><span class="line"><span class="keyword">if</span> (dfs(<span class="number">0</span>, <span class="number">-100</span>)) &#123;</span><br><span class="line"><span class="built_in">string</span> ans = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; ++i) ans += dir[path[i]];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"unsolvable"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N2; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N2; ++j) &#123;</span><br><span class="line">MDT[i][j] = <span class="built_in">abs</span>(i / N - j / N) + <span class="built_in">abs</span>(i % N - j % N);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Puzzle in;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N2; ++i) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; in.f[i];</span><br><span class="line"><span class="keyword">if</span> (in.f[i] == <span class="number">0</span>) &#123;</span><br><span class="line">in.f[i] = N2;</span><br><span class="line">in.space = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> ans = iterative_deepening(in);</span><br><span class="line"><span class="keyword">if</span> (ans != <span class="string">"unsolvable"</span>) <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考数据:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">13</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">8</span> <span class="number">1</span> <span class="number">10</span> <span class="number">12</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">15</span> <span class="number">9</span></span><br><span class="line"><span class="number">14</span> <span class="number">4</span> <span class="number">0</span> <span class="number">11</span> <span class="comment">// 53</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">0</span></span><br><span class="line"><span class="number">5</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br><span class="line"><span class="number">9</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">8</span> <span class="number">9</span> <span class="number">14</span></span><br><span class="line"><span class="number">10</span> <span class="number">13</span> <span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">12</span> <span class="number">2</span> <span class="number">7</span> <span class="number">15</span></span><br><span class="line"><span class="number">4</span> <span class="number">0</span> <span class="number">3</span> <span class="number">11</span>  <span class="comment">// 56</span></span><br><span class="line"></span><br><span class="line"><span class="number">12</span> <span class="number">7</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">0</span> <span class="number">9</span></span><br><span class="line"><span class="number">14</span> <span class="number">13</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">3</span> <span class="number">15</span> <span class="number">10</span> <span class="number">11</span> <span class="comment">// 47</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">11</span> <span class="number">10</span> <span class="number">7</span></span><br><span class="line"><span class="number">13</span> <span class="number">0</span> <span class="number">9</span> <span class="number">3</span></span><br><span class="line"><span class="number">14</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">15</span> <span class="number">6</span> <span class="number">12</span>  <span class="comment">// 38</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">0</span> <span class="number">11</span> <span class="number">3</span></span><br><span class="line"><span class="number">9</span> <span class="number">6</span> <span class="number">10</span> <span class="number">8</span></span><br><span class="line"><span class="number">13</span> <span class="number">14</span> <span class="number">15</span> <span class="number">12</span>  <span class="comment">// 14</span></span><br><span class="line"></span><br><span class="line"><span class="number">9</span> <span class="number">14</span> <span class="number">13</span> <span class="number">15</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">11</span> <span class="number">6</span></span><br><span class="line"><span class="number">8</span> <span class="number">12</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span> <span class="number">7</span> <span class="number">4</span> <span class="number">0</span>  <span class="comment">// unsolvable</span></span><br></pre></td></tr></table></figure><p>十六宫格随机数据: <strong>排列置乱算法</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAND(l, r) l+(int)(r-l+1)*rand()/(RAND_MAX+1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand(time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">int</span> data[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; ++i) &#123;</span><br><span class="line">data[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">15</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line"><span class="keyword">int</span> ind = RAND(<span class="number">0</span>, i);</span><br><span class="line">swap(data[i], data[ind]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[i*<span class="number">4</span> + j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中出现次数超过一半的数字</title>
      <link href="/2018/09/23/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi/"/>
      <url>/2018/09/23/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi/</url>
      
        <content type="html"><![CDATA[<p>用头脑风暴学算法，对于一个问题，我们不只是要解决它，还要去思考有什么好的方法，差的方法去解决，甚至是一些错误的但可以提供思想借鉴的方法。</p><p>此问题“数组中出现次数超过一半的数字”是一道非常经典的算法题，我把它放在算法风暴系列第一篇来解析，探讨学习一个算法的过程，从慢到快，从最直观的方法到脑洞大开的方法，由表面深入本质。</p><hr><p><a href="https://blog.csdn.net/wjh2622075127/article/details/82830683" target="_blank" rel="noopener">下一篇：算法风暴之二—最小的k个数</a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>给定一个数组，且已知数组中有一个数出现次数超过一半（严格），请求出这个数。</strong></p><p>问题很简单，方法也多样，但什么方法是最好的呢？为什么它最好？各种方法之间有什么优缺点？下面我们一一展开。</p><hr><h2 id="方法一：给数组排序"><a href="#方法一：给数组排序" class="headerlink" title="方法一：给数组排序"></a>方法一：给数组排序</h2><p>这大概是最直观的方法了，最容易想到，也是最多人能够想出来的。如果我们使用快排的话，只需要<code>O(nlogn)</code>的时间就可以找到这个数。</p><p>那么思考这样一个问题：给数组排序了，然后怎么找这个数呢？有两种方法</p><p>1、从小到大遍历已排序数组，同时统计每个数出现的次数（某个数和上一个数不同则计数置为1），如果出现某个计数超过一半，那么正在计数的数就是所求数。</p><p>PS：这种方法可行，相比于快排的时间复杂度是可以忽略的，但是我们还有更好的方法，直击本质。</p><p>2、对一个已排好序的序列，出现次数超过一半的数必定是中位数。因此，我们只要输出中位数即可。</p><p>复杂度分析：<br>| <strong>时间复杂度</strong> |  <strong>O(nlogn)</strong> |<br>|–|–|<br>| <strong>空间复杂度</strong> | <strong>O(n)</strong> |</p><p>手写快排代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAND(start, end) start+(int)(end-start+1)*rand()/(RAND_MAX+1);</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">10005</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start == end) <span class="keyword">return</span> start;</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">int</span> index = RAND(start, end);</span><br><span class="line">swap(data[index], data[end]);</span><br><span class="line"><span class="keyword">int</span> one = start - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (index = start; index &lt; end; ++index) &#123;</span><br><span class="line"><span class="keyword">if</span> (data[index] &lt; data[end]) &#123;</span><br><span class="line">++one;</span><br><span class="line"><span class="keyword">if</span> (one != index) swap(data[one], data[index]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++one;</span><br><span class="line">swap(data[one], data[end]);</span><br><span class="line"><span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (length &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = Partition(data, length, start, end);</span><br><span class="line"><span class="keyword">if</span> (mid &gt; start)</span><br><span class="line">QuickSort(data, length, start, mid - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (mid &lt; end)</span><br><span class="line">QuickSort(data, length, mid + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, data[maxn];</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; data[i];</span><br><span class="line">&#125;</span><br><span class="line">QuickSort(data, n, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[n &gt;&gt; <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二：桶排序计数"><a href="#方法二：桶排序计数" class="headerlink" title="方法二：桶排序计数"></a>方法二：桶排序计数</h2><p>如果我们需要统计的数组元素都是正整数呢？那么我们就可以使用桶排序，给他们计数，然后超过数组大小一半的就是结果了。</p><p>然而桶排序看上去很简单，“复杂度也不高”，却有很多的限制。</p><p>1、首先，数组统计的数需得是可hash的，不然无法将他们在hash数组上计数。但是某些情况，如元素有负值，可进行灵活转化，使其可hash。<br>2、其次，桶排序方法空间换时间，需要消耗额外的空间，取决于数据的范围。<br>3、桶排序并非真的那么快。桶排序的时间复杂度并非是普通的<code>O(n)</code>, 它的n指的是最大数据范围，如果有这样一组数据<code>1 100 10000 1000000</code>，那么桶排序将会有至少1000000次循环，且开出1e6的空间，大大浪费资源。</p><p>桶排序方法适合数据范围不大，且数据密度较大的数据。非也，则在此问题上算不上好方法。</p><p>代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, max_size = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> *data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; data[i];</span><br><span class="line">max_size = max(max_size, data[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> *hash = <span class="keyword">new</span> <span class="keyword">int</span>[max_size + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max_size; ++i)</span><br><span class="line">hash[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">hash[data[i]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max_size; ++i)</span><br><span class="line"><span class="keyword">if</span> (hash[i] &gt; n &gt;&gt; <span class="number">1</span>) ans = i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line"><span class="keyword">delete</span> [] data;</span><br><span class="line"><span class="keyword">delete</span> [] hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法三：巧用栈"><a href="#方法三：巧用栈" class="headerlink" title="方法三：巧用栈"></a>方法三：巧用栈</h2><p>其实我们可以发现，上面的方法一和方法二，固然是这道题的解法之一，但<strong>不是非常具有针对性</strong>。也就是说，那两种方法是<strong>功能过剩的</strong>，而这所谓功能过剩，也正是导致它性能不是最佳的原因。</p><p><strong>那么，我们就应该思考某种算法，只针对这个问题，完全的利用好效率。那么就要从题目出发，找蕴含在问题中的本质规律了。</strong></p><p>其实这个问题的核心就是：<strong>出现次数超过一半</strong>。</p><p>我们做这样的思考：</p><p>假设k就是我们要求的那个数，那么对这个数组，删掉其中任意两个数所剩下的数组，其对应的k值会改变吗？答案是会的。<strong>但是，如果删掉任意两个不相同的数呢？答案是不会！</strong> 为什么不会？相信聪明的读者瞬间就明白原因，只需进行简单的推导就可以了。</p><p>具体的实现过程就是：<strong>每遍历一个数，就将其入栈，同时查询它和栈内前一个元素的大小，如果不同，就同时出栈，否则不变。</strong></p><p>以上，就是用栈的方法解决这个问题的核心。</p><table><thead><tr><th>时间复杂度</th><th>O(n)</th></tr></thead><tbody><tr><td><strong>空间复杂度</strong></td><td><strong>O(n)</strong></td></tr></tbody></table><p>栈实现代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> *data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">stack</span> = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; data[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">stack</span>[++top] = data[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; data[i];</span><br><span class="line"><span class="built_in">stack</span>[++top] = data[i];</span><br><span class="line"><span class="keyword">if</span> (top &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">stack</span>[top] != <span class="built_in">stack</span>[top - <span class="number">1</span>]) top -= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">stack</span>[top];</span><br><span class="line"><span class="keyword">delete</span> [] data;</span><br><span class="line"><span class="keyword">delete</span> [] <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法四：找中位数（第n-2大数）"><a href="#方法四：找中位数（第n-2大数）" class="headerlink" title="方法四：找中位数（第n/2大数）"></a>方法四：找中位数（第n/2大数）</h2><p>从方法一的分析中我们知道，这个数组的中位数就是答案。方法一是通过给所有的数进行排序找出这个中位数，而我们思考，排序是否有些大材小用？找这个中位数的方法是否可以更简单些？</p><p>答案是有的，而且这类问题被称为<strong>找第k个数</strong>。</p><p><strong>思想是快排的思想。时间复杂度为<code>O(n)</code></strong></p><p>利用快排思想，我们可以找出第n/2大的数，同时在第n/2th数左边的数都小于它，右边的数都大于它。这个数就是数组的中位数。</p><p>快速排序简称快排，利用分治的思想，在数组中随机选择一个数，然后以这个数为基准，把大于它的数划分到它的右侧，小于它的数划分到它的左侧，并且递归的分别对左右两侧数据进行处理，直到所有的区间都按照这样的规律划分好。</p><p>那么在这个问题中，如何利用快排的方法呢？<strong>快排是对每一个区间进行分治处理，而此问题不必，我们只要找到第n/2小的数。每次随机划分得的第m个数，如果m &lt; n/2, 那么对[m + 1, n - 1]这个区间继续递归；如果m &gt; n/2，那么对[0, m - 1]这个区间进行递归；如果刚好有m = n/2，那么函数结束，区间[0, n/2 - 1]的数就是最小的n/2个数。</strong></p><p>此算法的平均时间复杂度为O(n), 快速排序的详细证明可参考“算法导论”。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RAND(start, end) start + (int)(end - start + 1)*(rand()/(RAND_MAX + 1))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (start == end) <span class="keyword">return</span> start;</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">int</span> index = RAND(start, end);</span><br><span class="line">swap(data[index], data[end]);</span><br><span class="line"><span class="keyword">int</span> one = start - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (index = start; index &lt; end; ++index) &#123;</span><br><span class="line"><span class="keyword">if</span> (data[index] &lt; data[end]) &#123;</span><br><span class="line">++one;</span><br><span class="line"><span class="keyword">if</span> (one != index) swap(data[one], data[index]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">++one;</span><br><span class="line">swap(data[one], data[end]);</span><br><span class="line"><span class="keyword">return</span> one;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindIt</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid = Partition(data, length, start, end);</span><br><span class="line"><span class="keyword">if</span> (mid == length &gt;&gt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mid &gt; length &gt;&gt; <span class="number">1</span>) FindIt(data, length, start, mid - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> FindIt(data, length, mid + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> *data = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; data[i];</span><br><span class="line">&#125;</span><br><span class="line">FindIt(data, n, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; data[n &gt;&gt; <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/wjh2622075127/article/details/82830683" target="_blank" rel="noopener">下一篇：算法风暴之二—最小的k个数</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现简单分类器</title>
      <link href="/2018/09/21/python-shi-xian-jian-dan-fen-lei-qi/"/>
      <url>/2018/09/21/python-shi-xian-jian-dan-fen-lei-qi/</url>
      
        <content type="html"><![CDATA[<p>今天重新开始学习机器学习，训练了一个简单的分类器。</p><p>如何工作的呢？给定一组训练数据，他们的参数有三个，x轴坐标，y轴坐标，类别。即<code>(x, y, c)</code>。如图所示<br><img src="/images/20180921_1.png" alt><br>红色的圆点代表第一类点，类别编号为1；蓝色的倒三角形代表第二类点，类别编号为0.</p><p>我们的目的，是根据这些训练数据，拟合出一条边界线，来将两种类别的数据划分开来，这个系统就叫做分类器。鉴于笔者水平尚浅，故暂时只能训练从原点出发的线性分类器。</p><p>下面就讨论这个简单分类器的具体实现，对于入门者来说，其实也可以学到不少东西。</p><hr><h2 id="第一步，导入我们需要的python库"><a href="#第一步，导入我们需要的python库" class="headerlink" title="第一步，导入我们需要的python库"></a>第一步，导入我们需要的python库</h2><p>在这份代码中，我用到了<code>numpy</code>库和<code>matplotlib</code>库，并且在<code>jupyter notebook</code>中实现了内置<code>matplotlib</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line">import numpy as np</span><br></pre></td></tr></table></figure><h2 id="第二步，获取训练数据并解析坐标"><a href="#第二步，获取训练数据并解析坐标" class="headerlink" title="第二步，获取训练数据并解析坐标"></a>第二步，获取训练数据并解析坐标</h2><p>我们的输入格式是这样的：</p><blockquote><p>1.0 3.0 1,<br>3.0 1.0 0,<br>2.0 2.0 1,<br>4.0 1.0 0,<br>2.0 4.0 1,<br>4.5 1.0 0,<br>3.0 2.5 1,<br>5.0 2.0 0</p></blockquote><p>每行代表一个坐标的信息，分别是横坐标，纵坐标，类别。每组数据间用<code>,</code> 分隔，因此可以很简单的用<code>split</code>函数将数据划分。具体到每个坐标的信息，我们可以利用<code>numpy</code>的<code>fromstring</code>函数获取一个字符串信息，并把他们转化为<code>float</code>类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">get = input(<span class="string">"请输入训练数据，第三个参数为类别"</span>)</span><br><span class="line">get = get.split(<span class="string">','</span>)</span><br><span class="line">train_data = []</span><br><span class="line">x1 = []</span><br><span class="line">y1 = []</span><br><span class="line">x0 = []</span><br><span class="line">y0 = []</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> get:</span><br><span class="line">    train_data.append(np.fromstring(each, dtype=float, sep=<span class="string">' '</span>))</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> train_data:</span><br><span class="line">    <span class="keyword">if</span> each[<span class="number">2</span>] == <span class="number">1</span>:</span><br><span class="line">        x1.append(each[<span class="number">0</span>])</span><br><span class="line">        y1.append(each[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x0.append(each[<span class="number">0</span>])</span><br><span class="line">        y0.append(each[<span class="number">1</span>])</span><br></pre></td></tr></table></figure><h2 id="第三步，随机化数据"><a href="#第三步，随机化数据" class="headerlink" title="第三步，随机化数据"></a>第三步，随机化数据</h2><p>为了使我们的数据更加准确，我们需要用到随机化数据。如果不随机化会怎么样呢？不随机化，我们的分类器就可能陷入某种极端情况，从而得出错误的解。</p><p>代码中，我们使用<code>numpy</code>的随机技术。</p><p>1、首先初始化随机种子，由于我希望每次都随机，所以我给随机种子传递的参数也是随机的<br>2、随机化排列，这样可以得到一个随机的排列，以在后续处理数据时相对公平。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(np.random.randint(<span class="number">0</span>, <span class="number">10000</span>, size=<span class="number">1</span>, dtype=int))</span><br><span class="line">order1 = np.random.permutation(len(x1))</span><br><span class="line">order0 = np.random.permutation(len(x0))</span><br></pre></td></tr></table></figure><h2 id="第四步、生成分界线斜率"><a href="#第四步、生成分界线斜率" class="headerlink" title="第四步、生成分界线斜率"></a>第四步、生成分界线斜率</h2><p>这一步是最核心的一步，我们通过输入的训练数据对直线斜率进行调整。方法就是利用预测值与期望值之间的误差进行拟合，同时使用学习率<code>learn</code>和一些调整量<code>adjust</code>，使得过去和现在的训练能同时起到作用，而不偏颇。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">slope = <span class="number">1.0</span></span><br><span class="line">adjust = <span class="number">0.0</span></span><br><span class="line">learn = <span class="number">0.5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x1)):</span><br><span class="line">    slope += (y1[order1[i]] - slope*x1[order1[i]] + adjust)/x1[order1[i]]*learn</span><br><span class="line">    slope += (y0[order0[i]] - slope*x0[order0[i]] - adjust)/x0[order0[i]]*learn</span><br><span class="line">print(slope)</span><br></pre></td></tr></table></figure><h2 id="第五步、处理测试数据"><a href="#第五步、处理测试数据" class="headerlink" title="第五步、处理测试数据"></a>第五步、处理测试数据</h2><p>对测试数据的读入，我们的处理和训练数据是一样的。<br>通过对预边界测试和实际值的对比，我们得出测试数据的类别信息，从而实现分类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">get = input(<span class="string">"请输入测试数据："</span>)</span><br><span class="line">get = get.split(<span class="string">','</span>)</span><br><span class="line">test_data = []</span><br><span class="line">x2 = []</span><br><span class="line">y2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> get:</span><br><span class="line">    test_data.append(np.fromstring(i, dtype=float, sep=<span class="string">' '</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> test_data:</span><br><span class="line">    x2.append(i[<span class="number">0</span>])</span><br><span class="line">    y2.append(i[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x2)):</span><br><span class="line">    <span class="keyword">if</span> x2[i]*slope &gt; y2[i]:</span><br><span class="line">        print(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="第六步、输出展示分类结果"><a href="#第六步、输出展示分类结果" class="headerlink" title="第六步、输出展示分类结果"></a>第六步、输出展示分类结果</h2><p>图像是最直观的，因此我们利用<code>matplotlib</code>来展示结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = np.array(range(<span class="number">7</span>))</span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    y.append(slope*i)</span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">10</span>))</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">plt.plot(x, y, linestyle=<span class="string">'-'</span>)</span><br><span class="line">plt.plot(x1, y1, <span class="string">'o'</span>, color=<span class="string">'red'</span>)</span><br><span class="line">plt.plot(x0, y0, <span class="string">'v'</span>, color=<span class="string">'blue'</span>)</span><br><span class="line">plt.plot(x2, y2, <span class="string">'x'</span>, color=<span class="string">'black'</span>)</span><br></pre></td></tr></table></figure><p>如图<br><img src="/images/20180921_2.png" alt><br>可见，我们的分类器准确度还是比较高的。</p><hr><h2 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练集</span></span><br><span class="line"><span class="number">1.0</span> <span class="number">3.0</span> <span class="number">1</span>,</span><br><span class="line"><span class="number">3.0</span> <span class="number">1.0</span> <span class="number">0</span>,</span><br><span class="line"><span class="number">2.0</span> <span class="number">2.0</span> <span class="number">1</span>,</span><br><span class="line"><span class="number">4.0</span> <span class="number">1.0</span> <span class="number">0</span>,</span><br><span class="line"><span class="number">2.0</span> <span class="number">4.0</span> <span class="number">1</span>,</span><br><span class="line"><span class="number">4.5</span> <span class="number">1.0</span> <span class="number">0</span>,</span><br><span class="line"><span class="number">3.0</span> <span class="number">2.5</span> <span class="number">1</span>,</span><br><span class="line"><span class="number">5.0</span> <span class="number">2.0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集</span></span><br><span class="line"><span class="number">4.0</span> <span class="number">3.0</span>,</span><br><span class="line"><span class="number">2.5</span> <span class="number">2.5</span>,</span><br><span class="line"><span class="number">3.6</span> <span class="number">1.5</span>,</span><br><span class="line"><span class="number">5.0</span> <span class="number">1.5</span></span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">get = input(<span class="string">"请输入训练数据，第三个参数为类别"</span>)</span><br><span class="line">get = get.split(<span class="string">','</span>)</span><br><span class="line">train_data = []</span><br><span class="line">x1 = []</span><br><span class="line">y1 = []</span><br><span class="line">x0 = []</span><br><span class="line">y0 = []</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> get:</span><br><span class="line">    train_data.append(np.fromstring(each, dtype=float, sep=<span class="string">' '</span>))</span><br><span class="line"><span class="keyword">for</span> each <span class="keyword">in</span> train_data:</span><br><span class="line">    <span class="keyword">if</span> each[<span class="number">2</span>] == <span class="number">1</span>:</span><br><span class="line">        x1.append(each[<span class="number">0</span>])</span><br><span class="line">        y1.append(each[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x0.append(each[<span class="number">0</span>])</span><br><span class="line">        y0.append(each[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">np.random.seed(np.random.randint(<span class="number">0</span>, <span class="number">10000</span>, size=<span class="number">1</span>, dtype=int))</span><br><span class="line">order1 = np.random.permutation(len(x1))</span><br><span class="line">order0 = np.random.permutation(len(x0))</span><br><span class="line"></span><br><span class="line">slope = <span class="number">1.0</span></span><br><span class="line">adjust = <span class="number">0.0</span></span><br><span class="line">learn = <span class="number">0.5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x1)):</span><br><span class="line">    slope += (y1[order1[i]] - slope*x1[order1[i]] + adjust)/x1[order1[i]]*learn</span><br><span class="line">    slope += (y0[order0[i]] - slope*x0[order0[i]] - adjust)/x0[order0[i]]*learn</span><br><span class="line">print(slope)</span><br><span class="line"></span><br><span class="line">get = input(<span class="string">"请输入测试数据："</span>)</span><br><span class="line">get = get.split(<span class="string">','</span>)</span><br><span class="line">test_data = []</span><br><span class="line">x2 = []</span><br><span class="line">y2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> get:</span><br><span class="line">    test_data.append(np.fromstring(i, dtype=float, sep=<span class="string">' '</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> test_data:</span><br><span class="line">    x2.append(i[<span class="number">0</span>])</span><br><span class="line">    y2.append(i[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(x2)):</span><br><span class="line">    <span class="keyword">if</span> x2[i]*slope &gt; y2[i]:</span><br><span class="line">        print(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">x = np.array(range(<span class="number">7</span>))</span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    y.append(slope*i)</span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">10</span>))</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">5</span>)</span><br><span class="line">plt.plot(x, y, linestyle=<span class="string">'-'</span>)</span><br><span class="line">plt.plot(x1, y1, <span class="string">'o'</span>, color=<span class="string">'red'</span>)</span><br><span class="line">plt.plot(x0, y0, <span class="string">'v'</span>, color=<span class="string">'blue'</span>)</span><br><span class="line">plt.plot(x2, y2, <span class="string">'x'</span>, color=<span class="string">'black'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chrome浏览器使用指南</title>
      <link href="/2018/09/08/chrome-liu-lan-qi-shi-yong-zhi-nan/"/>
      <url>/2018/09/08/chrome-liu-lan-qi-shi-yong-zhi-nan/</url>
      
        <content type="html"><![CDATA[<p><strong>目录</strong></p><h2 id="废话"><a href="#废话" class="headerlink" title="废话"></a>废话</h2><p>从ie到国产，从国产到火狐，最后终于到了Chrome，这条路可谓是曲折，与Chrome相见恨晚。用过这么多浏览器，对现在用的Chrome最满意。尤其是十周年更新了69版本后，配合自己搭建的梯子，越用越舒服，简直爱不释手。先放张美图<br><img src="/images/20180908_1.png" alt><br>这是浏览器打开的界面，简洁唯美，清新灵动。</p><p>Chrome 10周年之际，我打算写一篇Chrome使用指北⚘，把我使用的觉得有用的经验技巧分享出来。但由于每个人的身份不一样，所以同样的内容有的人觉得有用有的人却觉得没用，大家各自取舍吧。</p><hr><h2 id="快速进入网页"><a href="#快速进入网页" class="headerlink" title="快速进入网页"></a>快速进入网页</h2><p>我平常有记忆网站域名的习惯，所以我要进入一个网站通常不用在书签里面查找或者在搜索引擎搜索，而是直接输入域名。而<strong>配合Chrome浏览器的url自动补全功能</strong>，我通常只要输入一两个字母，即可快速进入想要进入的网站。极大地提高了工作学习效率。</p><p>如图，分别是快速进入谷歌<code>google.com</code>, 洛谷<code>luogu.org</code>,  QQ邮箱<code>mail.qq.com</code>的展示。<strong>不能更方便。</strong></p><p><img src="/images/20180908_2.png" alt></p><hr><h2 id="快速切换搜索引擎"><a href="#快速切换搜索引擎" class="headerlink" title="快速切换搜索引擎"></a>快速切换搜索引擎</h2><p>有时候我们会用百度，有时候会用谷歌，诚然在切换时我们可以直接进入他们的网站进行搜索，但是，还有更快的方法，那就是在搜索栏里输入<strong>自定义的关键字</strong>，<strong>然后按空格或tab键，实现搜索引擎的快速切换。</strong></p><p>可以用来快速网购商品，搜索豆瓣某电影，进行谷歌翻译，搜索维基百科，盘搜搜搜资源。。。</p><p>步骤是：<strong>Settings -&gt; Search engine -&gt; Manage search engines; 然后就请为所欲为吧。</strong></p><p><img src="/images/20180908_3.png" alt><br><img src="/images/20180908_1.png" alt></p><hr><h2 id="同步账号信息"><a href="#同步账号信息" class="headerlink" title="同步账号信息"></a>同步账号信息</h2><p>Chrome是多平台浏览器，它提供的同步功能使得我们更换平台或重装浏览器时非常方便。<strong>账号密码，历史纪录，书签，甚至是PC端的插件，一键同步</strong>，当然前提是你得能够FQ。如何FQ？<strong>自己动手丰衣足食，可以参考我写的一篇博客，<a href="https://blog.csdn.net/wjh2622075127/article/details/82356652" target="_blank" rel="noopener">自己动手搭建梯子</a></strong>（曾有数千访问量,被CSDN一日腰斩，重发后一直处于潜水状态）</p><hr><h2 id="Chrome插件"><a href="#Chrome插件" class="headerlink" title="Chrome插件"></a>Chrome插件</h2><p><strong>所谓无插件不Chrome，插件可谓是Chrome的灵魂所在。</strong>网上关于Chrome插件的分享有很多，我推荐几个我常用的。</p><p><a href="https://www.google.com/search?q=Chrome%E6%8F%92%E4%BB%B6&oq=Chrome%E6%8F%92%E4%BB%B6&aqs=chrome..69i57j69i60l2j69i61j0j69i65.3348j0j4&sourceid=chrome&ie=UTF-8" target="_blank" rel="noopener">Chrome插件谷歌版</a><br><a href="https://www.baidu.com/s?wd=Chrome%E6%8F%92%E4%BB%B6&rsv_spt=1&rsv_iqid=0xf4665ce000035081&issp=1&f=8&rsv_bp=0&rsv_idx=2&ie=utf-8&tn=baiduhome_pg&rsv_enter=1&rsv_sug3=14&rsv_sug1=11&rsv_sug7=100&rsv_t=b85e1xmJaoZjI8IjuqDVlrk9GZBJqNswHkySxC4IZAOiLD03%2B0Jhv2KAxsqhwCLSYN2Q&rsv_sug2=0&inputT=3609&rsv_sug4=3610" target="_blank" rel="noopener">Chrome插件百度版</a></p><h3 id="如何安装Chrome插件"><a href="#如何安装Chrome插件" class="headerlink" title="如何安装Chrome插件"></a>如何安装Chrome插件</h3><p>一般说来有两种方法</p><p>第一种最官方最正式最方便但对国内最不友好。那就是到<a href="https://chrome.google.com/webstore/category/extensions?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">Chrome Web Store</a>, 找到插件安装即可。不会FQ的童鞋只能WTF。</p><p>第二种是打开More tools -&gt; Extensions 页面，把下载好的crx扩展文件拖拽进去就好了。但是，在<code>2018-9-8</code>这一日，在<code>Version 69.0.3497.81 (Official Build) (64-bit)</code>这一版本，我是无法拖拽了，<strong>也许是谷歌提升了对插件安装来源的要求。</strong></p><p><strong>下面推荐几个插件</strong></p><h3 id="VIP看看"><a href="#VIP看看" class="headerlink" title="VIP看看"></a>VIP看看</h3><p>此插件可以看各大视频网站的vip视频，只要在视频页点击右键，会找到有个vip看看的选项，点击即可跳转，然后开心的看视频了。不过分辨率不高，会模糊。</p><p><del><a href="http://www.97kp.cc/" target="_blank" rel="noopener">给大家推荐一个看VIP视频的盗版网站</a>. 以后工作了一定要买正版VIP吖</del></p><p><img src="/images/20180908_5.png" alt></p><h3 id="Adblock-Plus屏蔽广告"><a href="#Adblock-Plus屏蔽广告" class="headerlink" title="Adblock Plus屏蔽广告"></a>Adblock Plus屏蔽广告</h3><p>屏蔽广告插件是必装的了，对比了几个屏蔽广告插件，发现Adblock Plus效果最好。体现在用它们把百度搜索页面的百度热搜屏蔽掉，这个插件最稳定而无复发。<strong>屏蔽百度热搜可以参考<a href="https://blog.csdn.net/wjh2622075127/article/details/81665240" target="_blank" rel="noopener">我写的这篇文章</a>。</strong></p><p><img src="/images/20180908_6.png" alt></p><h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p><img src="/images/20180908_7.png" alt></p><p>这是一个很好用也比较漂亮的书签插件，虽然我平时很少用书签但觉得它挺不错就推荐了。书签图片就不放出来了（有隐私吖），应该不会让大家失望的。</p><h3 id="OneTab-管理标签页"><a href="#OneTab-管理标签页" class="headerlink" title="OneTab 管理标签页"></a>OneTab 管理标签页</h3><p>打开的标签页太多又不想把他们删除怎么办？别急，OneTab来帮你。使用OneTab，你就可以一键将所有标签页合到一个OneTab标签页里面了，之后需要用哪个就点哪个，或者一键回复呀。</p><p><img src="/images/20180908_8.png" alt></p><h3 id="油猴"><a href="#油猴" class="headerlink" title="油猴"></a>油猴</h3><p>这个可是插件中的神器呀，如果说Chrome是一个有丰富插件的平台，那么油猴就是有丰富脚本的插件，对于我来说，它相当于很多个“插件”。</p><p>它有什么用呢？<strong>它里面有全网音乐下载脚本，百度网盘外链脚本，比价脚本，youtube视频下载脚本，破解VIP视频脚本，小说阅读模式脚本。。。好用的东西简直不能更多。</strong></p><p><img src="/images/20180908_9.png" alt></p><p><strong><a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">小伙伴们可以到这个网站去寻找好用的插件啦</a></strong></p><h3 id="SetupVP-N"><a href="#SetupVP-N" class="headerlink" title="SetupVP_N"></a>SetupVP_N</h3><p>这个得偷偷地说，这是一个非常好用的FQ插件，只需注册一个账号，就可以免费使用啦，不限流量不限时的哦。经过实际测试，俄罗斯结点是连的最快的，在油管上看1080P的视频都毫无压力哦。</p><p><img src="/images/20180908_10.png" alt></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p><strong>关于Chrome的使用经验就分享到这里了，希望能帮大家提高工作效率吧: &gt; 如果觉得对你有所帮助，就请点个赞吧。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tarjan算法缩点+DAG最长路(DP)</title>
      <link href="/2018/08/13/tarjan-suan-fa-suo-dian-dag-zui-chang-lu-dp/"/>
      <url>/2018/08/13/tarjan-suan-fa-suo-dian-dag-zui-chang-lu-dp/</url>
      
        <content type="html"><![CDATA[<p>我们按照复杂程度来讨论不同的Tarjan算法变形的差异.</p><h2 id="第一个问题-Tarjan算法找出一个图里面的全部强连通分量-包括单独的点"><a href="#第一个问题-Tarjan算法找出一个图里面的全部强连通分量-包括单独的点" class="headerlink" title="第一个问题: Tarjan算法找出一个图里面的全部强连通分量(包括单独的点)."></a>第一个问题: Tarjan算法找出一个图里面的全部强连通分量(包括单独的点).</h2><p>但此时只是有所区分的将所有的点划分为一个个的强连通分量, 尚且没有缩点. 上面这个功能实现起来最简单. </p><p>它的Tarjan函数内部是这样的.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++index;</span><br><span class="line"><span class="built_in">stack</span>[++top] = u;</span><br><span class="line">in_stack[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i];</span><br><span class="line"><span class="keyword">if</span> (!dfn[v]) &#123; <span class="comment">// 更新新的点.</span></span><br><span class="line">tarjan(v);</span><br><span class="line">low[u] = min(low[u], low[v]);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (in_stack[v]) &#123;</span><br><span class="line">low[u] = min(low[u], low[v]);</span><br><span class="line">&#125; <span class="comment">// 还剩下一种不在栈中但是已经访问过的情况,是其他连通分量的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">stack</span>[top] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">in_stack[<span class="built_in">stack</span>[top]] = <span class="literal">false</span>; <span class="comment">// 漏写了这一条.</span></span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">stack</span>[--top + <span class="number">1</span>] != u);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二个问题-对每个强连通分量进行缩点-使得此图变成一张DAG"><a href="#第二个问题-对每个强连通分量进行缩点-使得此图变成一张DAG" class="headerlink" title="第二个问题: 对每个强连通分量进行缩点, 使得此图变成一张DAG."></a>第二个问题: 对每个强连通分量进行缩点, 使得此图变成一张DAG.</h2><p>在Tarjan函数内部他们的主要区别是当<code>dfn[u] == low[u]</code>的这一段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (dfn[u] == low[u]) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">int now;</span><br><span class="line">do &#123;</span><br><span class="line">now = sta.top();</span><br><span class="line">sta.pop();</span><br><span class="line">in_stack[now] = false;</span><br><span class="line">to[now] = cnt;</span><br><span class="line">&#125; while (now != u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>增加了一个全局变量<code>cnt</code>, 表示当前缩点的编号.</strong></p></li><li><p><strong>增加了一个<code>to</code>数组, 用来表示原来的点在缩点之后是哪个点.</strong></p></li></ul><p>所以我们可以有下面这段代码, <strong><code>set&lt;int&gt; Now</code>代表缩点后的新图.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">for (int j = 0; j &lt; G[i].size(); ++j) &#123;</span><br><span class="line">int u = to[i], v = to[G[i][j]];</span><br><span class="line">if (u != v) Now[u].insert(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过<code>to</code>数组关联起原图和缩点后图的点, 从而建立新图.</strong></p><p>这样, 通过<code>dfn[u] == low[u]</code>处的修改, 以及结合<code>to</code>数组建立新图的过程, 就实现了Tarjan算法的缩点.</p><h2 id="第三个问题-如何快速获得新图各个结点的入度出度"><a href="#第三个问题-如何快速获得新图各个结点的入度出度" class="headerlink" title="第三个问题: 如何快速获得新图各个结点的入度出度."></a>第三个问题: 如何快速获得新图各个结点的入度出度.</h2><p>上面的<code>to</code>数组保留, 看下面这段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">for (int j = 0; j &lt; G[i].size(); ++j) &#123;</span><br><span class="line">if (to[i] != to[G[i][j]]) &#123;</span><br><span class="line">out[to[i]]++;</span><br><span class="line">in[to[G[i][j]]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一二层循环遍历之前所有的边, 里面一个条件语句, <strong>判断边的两端点是否指向同一个缩点, 如果不是, 那么他们在<code>to</code>数组中所指向的新的结点也将作为一条边</strong>. <strong>利用<code>to</code>数组可以快速方便的获取新图中的入度和出度, 这样的话要知道入度和出度就无需建立新图.</strong></p><p>##第四个问题: 缩点之后求解DAG最长路</p><p>看洛谷上的这道题 <a href="https://www.luogu.org/problemnew/show/P3387" target="_blank" rel="noopener">传送门</a></p><p>此题是以点为权值而非边, 但做法是基本差不多的. 都是DP算法.</p><p>DP函数是这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int DP(int u)</span><br><span class="line">&#123;</span><br><span class="line">if (dp[u]) return dp[u];</span><br><span class="line">set&lt;int&gt;::iterator is = Now[u].begin();</span><br><span class="line">while (is != Now[u].end()) &#123;</span><br><span class="line">dp[u] = max(dp[u], DP(*is));</span><br><span class="line">is++;</span><br><span class="line">&#125;</span><br><span class="line">dp[u] += val_now[u];</span><br><span class="line">return dp[u];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>状态转移方程: <code>dp[i] = max{dp[j] | (i, j) ∈E} + val_now[i]</code></strong><br><strong>区别于边为权值的方程:<code>dp[i] = max{dp[j]+length[i→j] | (i,j)∈E}</code></strong></p><p>AC代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;set&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 10005;</span><br><span class="line">stack&lt;int&gt; sta;</span><br><span class="line">vector&lt;int&gt; G[maxn];</span><br><span class="line">set&lt;int&gt; Now[maxn];</span><br><span class="line">int n, m, index = 0, cnt = 0, ans = 0;</span><br><span class="line">int to[maxn], dfn[maxn] = &#123;&#125;, low[maxn];</span><br><span class="line">int dp[maxn] = &#123;&#125;, val[maxn], val_now[maxn] = &#123;&#125;;</span><br><span class="line">bool in_stack[maxn] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">void tarjan(int u)</span><br><span class="line">&#123;</span><br><span class="line">dfn[u] = low[u] = ++index;</span><br><span class="line">in_stack[u] = true;</span><br><span class="line">sta.push(u);</span><br><span class="line">for (int i = 0; i &lt; G[u].size(); ++i) &#123;</span><br><span class="line">int v = G[u][i];</span><br><span class="line">if (dfn[v] == 0) &#123;</span><br><span class="line">tarjan(v);</span><br><span class="line">low[u] = min(low[u], low[v]);</span><br><span class="line">&#125; else if (in_stack[v]) low[u] = min(low[u], low[v]);</span><br><span class="line">&#125;</span><br><span class="line">if (dfn[u] == low[u]) &#123;</span><br><span class="line">cnt++;</span><br><span class="line">int now;</span><br><span class="line">do &#123;</span><br><span class="line">now = sta.top();</span><br><span class="line">sta.pop();</span><br><span class="line">in_stack[now] = false;</span><br><span class="line">to[now] = cnt;</span><br><span class="line">&#125; while (now != u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int DP(int u)</span><br><span class="line">&#123;</span><br><span class="line">if (dp[u]) return dp[u];</span><br><span class="line">set&lt;int&gt;::iterator is = Now[u].begin();</span><br><span class="line">while (is != Now[u].end()) &#123;</span><br><span class="line">dp[u] = max(dp[u], DP(*is));</span><br><span class="line">is++;</span><br><span class="line">&#125;</span><br><span class="line">dp[u] += val_now[u];</span><br><span class="line">return dp[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">cin &gt;&gt; val[i];</span><br><span class="line">for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">int u, v;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= n; ++i)</span><br><span class="line">if (dfn[i] == 0) tarjan(i);</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">for (int j = 0; j &lt; G[i].size(); ++j) &#123;</span><br><span class="line">int u = to[i], v = to[G[i][j]];</span><br><span class="line">if (u != v) Now[u].insert(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">int t = to[i];</span><br><span class="line">val_now[t] += val[i];</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= cnt; ++i)</span><br><span class="line">ans = max(ans, dp[i] = DP(i));</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><em>我认为Tarjan算法缩点的核心就是<code>to</code>数组. </em></em></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契_矩阵快速幂解法</title>
      <link href="/2018/07/26/fei-bo-na-qi-ju-zhen-kuai-su-mi-jie-fa/"/>
      <url>/2018/07/26/fei-bo-na-qi-ju-zhen-kuai-su-mi-jie-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>学过矩阵学了矩阵再看斐波那契数列, 秒懂, 结合矩阵快速幂, 加深了一个概念的理解: 矩阵也就是一个基本的计算单位.</strong></p><p>矩阵快速幂解法其实就是<strong>快速幂+矩阵.</strong> </p><p>和普通的快速幂有什么不同? 不同的是<strong>基数的类型</strong>,快速幂的过程还是一样的. 同样的,快速幂结果一般取模, 因为数据实在是太大了. 那么矩阵快速幂是否也应该取模?</p><p>那么推导一下似乎可以发现,<strong>矩阵的每个数都取模p,因为结果其实就是矩阵的某个元素</strong> </p><p>以[[1, 1], [1, 0]]的幂为n, n = 0时, 结果0, 如果我们取f0 = 0, f1 = 1, 以此类推,那么<strong>n次幂的结果就是右下角的那个数.</strong> </p><p>同时<strong>时间复杂度为O(n log n).</strong> </p><p>我们来回顾一下快速幂, <strong><em>是从一次不断进行倍增, 如果数n 的二进制形式在某一位上为1,那么就乘以这一位,否则不乘</em></strong> </p><p>先写一下快速幂代码. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, p, ans = <span class="number">1</span>, val = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; p;</span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line"><span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = ans * val % p;</span><br><span class="line">val *= val;</span><br><span class="line">n /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// OK, 就是这么简单.</span></span><br></pre></td></tr></table></figure><hr><p>那么矩阵快速幂也呼之欲出了. </p><p>然而写了代码发现计算过程有误.(划掉, 应该是推导有误,睡个午觉再来看看).<br>OK, 找出bug来了, 推导没有错误, <strong>是做矩阵乘法的时候几个下标写错了. 需要特别小心</strong></p><p>但是发现答案稍微有点问题<em><em>,看出其实now矩阵不用设置为二维单位矩阵,直接是[1, 0], 他就是答案. </em></em></p><p>但是非常悲剧的是洛谷上没有这么简单的模板题, 都<em><em>不给我辛苦学习AC一下的快感. </em></em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, p = (1 &lt;&lt; 31);</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int now[2][1] = &#123;&#123;1&#125;, &#123;0&#125;&#125;, matrix[2][2] = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;</span><br><span class="line">while (n) &#123;</span><br><span class="line">int a, b, c, d;</span><br><span class="line">if (n &amp; 1) &#123; // 矩阵相乘. </span><br><span class="line">a = matrix[0][0] * now[0][0] + matrix[0][1] * now[1][0];</span><br><span class="line">b = matrix[1][0] * now[0][0] + matrix[1][1] * now[1][0];</span><br><span class="line">now[0][0] = a % p, now[1][0] = b % p;</span><br><span class="line">&#125;</span><br><span class="line">// 下面是矩阵平方, 有点麻烦. </span><br><span class="line">a = matrix[0][0] * matrix[0][0] + matrix[0][1] * matrix[1][0];</span><br><span class="line">b = matrix[0][0] * matrix[0][1] + matrix[0][1] * matrix[1][1];</span><br><span class="line">c = matrix[1][0] * matrix[0][0] + matrix[1][1] * matrix[1][0];</span><br><span class="line">d = matrix[1][0] * matrix[0][1] + matrix[1][1] * matrix[1][1];</span><br><span class="line">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl; </span><br><span class="line">matrix[0][0] = a % p, matrix[0][1] = b % p, matrix[1][0] = c % p, matrix[1][1] = d % p;</span><br><span class="line">n /= 2;</span><br><span class="line">//cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;</span><br><span class="line">//cout &lt;&lt; matrix[0][0] &lt;&lt; &apos; &apos; &lt;&lt; matrix[0][1] &lt;&lt; endl &lt;&lt; matrix[1][0] &lt;&lt; &apos; &apos; &lt;&lt; matrix[1][1] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; now[1][0];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来串矩阵快速幂模板(不只是斐波那契矩阵)</p><p>也就是<strong>矩阵计算 + 快速幂</strong>的组合. <strong>O(n</strong>3 + log k)**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">typedef long long LL;</span><br><span class="line"></span><br><span class="line">const LL mode = 1000000007;</span><br><span class="line"></span><br><span class="line">void calc(LL ans[105][105], LL matrix[105][105], LL n)</span><br><span class="line">&#123;</span><br><span class="line">LL tmp[105][105];</span><br><span class="line">memset(tmp, 0, sizeof(tmp));</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">for (int k = 1; k &lt;= n; ++k) &#123;</span><br><span class="line">tmp[i][j] += ans[i][k] * matrix[k][j];</span><br><span class="line">tmp[i][j] %= mode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">ans[i][j] = tmp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">LL n, k, matrix[105][105], ans[105][105];</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">cin &gt;&gt; matrix[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 初始化为单位矩阵. </span><br><span class="line">memset(ans, 0, sizeof(ans));</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">ans[i][i] = 1;</span><br><span class="line">&#125;</span><br><span class="line">while (k) &#123;</span><br><span class="line">if (k &amp; 1) &#123;</span><br><span class="line">calc(ans, matrix, n);</span><br><span class="line">&#125;</span><br><span class="line">calc(matrix, matrix, n);</span><br><span class="line">k /= 2;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">cout &lt;&lt; ans[i][j] &lt;&lt; &apos; &apos;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">矩阵计算 + 快速幂</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>倍增法求Lca(最近公共祖先)</title>
      <link href="/2018/07/16/bei-zeng-fa-qiu-lca-zui-jin-gong-gong-zu-xian/"/>
      <url>/2018/07/16/bei-zeng-fa-qiu-lca-zui-jin-gong-gong-zu-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="一-明确问题"><a href="#一-明确问题" class="headerlink" title="一. 明确问题"></a>一. 明确问题</h2><p>看标题便知道了, 这篇博客力求解决的问题是<strong>求出一棵树的两个结点的最近公共祖先(LCA), 方法是倍增法.</strong></p><p>那么什么是Lca呢? </p><blockquote><p><strong>它是一棵树上两个结点向上移动, 最后交汇的第一个结点, 也就是说这两个结点祖先里离树根最远也是离他们最近的结点.</strong></p></blockquote><p>什么是倍增法呢? </p><blockquote><p><strong>此问题说的是用倍增法求解lca问题, 那么我们可以推测这种方法还可以解决其他的一些问题(不在当下讨论范围). 在学习的过程中, 我是这么理解的: 它是一种类似于二分的方法, 不过这里不是二分, 而是倍增, 以2倍, 4倍, 等等倍数增长</strong></p></blockquote><p>一下没有理解倍增法没关系, 看后面的做法, 再结合前面, 前后贯通大概可以理解的七七八八.</p><h2 id="二-思路引导"><a href="#二-思路引导" class="headerlink" title="二. 思路引导"></a>二. 思路引导</h2><p><strong>下面的思路试图把过程模块化, 如果你不知道一个地方如何实现, 还请不要纠结</strong>(比如不要纠结于树的深度怎么求, 假设我们求好了树的深度)</p><p>我们找的是任意两个结点的最近公共祖先, 那么我们可以考虑这么两种种情况:</p><ol><li>两结点的深度相同.</li><li>两结点深度不同.</li></ol><p>算法实现来说, <strong>第一种情况是第二种情况的特殊情况, 第二种情况是要转化成第一种情况的</strong></p><p>先不考虑其他, 我们思考这么一个问题: <em><em>对于两个深度不同的结点, 把深度更深的那个向其父节点迭代, 直到这个迭代结点和另一个结点深度相同, 那么这两个深度相同的结点的Lca也就是原两个结点的Lca. </em></em> 因此第二种情况转化成第一种情况来求解Lca是可行的.</p><p>现在还不知道如何把两个结点迭代到相同深度, 别急, 这里用到的是上面提到的<strong>倍增法</strong>.</p><p>那么剩下的问题事就解决第一种情况了, 两个结点深度相同了. 怎么求他们的Lca呢?</p><p>这里也是用了倍增法. 思路和上一步的倍增法是一样的, 不同之处有两点</p><ol><li>这次是两个结点一起迭代向前的.</li><li>这次迭代停止的条件和上次不一样.</li></ol><p>OK, 现在无法理解上面的几个过程没关系,<strong>只要知道我们用递增法解决了上述的两个问题.</strong> 具体细节看下面分析.</p><h2 id="三-整体框架"><a href="#三-整体框架" class="headerlink" title="三. 整体框架."></a>三. 整体框架.</h2><p>那么过了一遍上面的思路引导之后, 我们可以大概想一想怎么实现整个的问题了.</p><p>其实用求Lca这个问题可以分为两块: <strong>预处理 + 查询</strong>, 其中预处理是O(VlogV), 而一次查询是O(logV), V代表结点数量. 所以总<strong>时间复杂度为O(VlogV +ＱlogV)</strong>. Q为查询次数</p><p>其步骤是这样的: </p><ol><li>存储一棵树(邻接表法)</li><li>获取树各结点的上的深度(dfs或bfs)</li><li>获取2次幂祖先的结点, 用parents[maxn][20]数组存储, <strong>倍增法关键</strong></li><li>用倍增法查询Lca</li></ol><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p><strong>用邻接表存储一棵树, 并用from[]数组记录各结点的父节点, 其中没有父节点的就是root.</strong></p><p>parents[u][]数组存储的是u结点的祖先结点.<br>如parents[u][0], 是u结点的2⁰祖先结点, 即1祖先, 也即父节点. 在输入过程中可以直接得到.<br>parents[u][1], 是u结点的2¹祖先结点,即2祖先, 也即父亲的父亲<br>parents[u][2], 是u结点的2²祖先结点, 即4祖先, 也即(父亲的父亲)的(父亲的父亲), 也就是爷爷的爷爷. </p><p><strong>理解这个关系很重要, 这也是通过父亲结点获取整个祖先结点的关键.</strong> 现在可以先跳过.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">int</span> u, v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">parents[v][<span class="number">0</span>] = u;</span><br><span class="line">from[v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (from[i] == <span class="number">-1</span>) root = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p><strong>获取各结点的深度, 可以用DFS或这BFS方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void getDepth_dfs(int u) // DFS求深度</span><br><span class="line">&#123;</span><br><span class="line">int len = G[u].size();</span><br><span class="line">for (int i = 0; i &lt; len; ++i) &#123;</span><br><span class="line">int v = G[u][i];</span><br><span class="line">depth[v] = depth[u] + 1;</span><br><span class="line">getDepth_dfs(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getDepth_bfs(int u) // BFS求深度</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; Q;</span><br><span class="line">Q.push(u);</span><br><span class="line">while (!Q.empty()) &#123;</span><br><span class="line">int v = Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">for (int i = 0; i &lt; G[v].size(); ++i) &#123;</span><br><span class="line">depth[G[v][i]] = depth[v] + 1;</span><br><span class="line">Q.push(G[v][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h3><p><strong>求祖先</strong></p><p>在步骤一里面我们讨论了parents数组的意义, 它存的是结点u的2次幂祖先, 从父亲结点开始. 为什么要存2次幂? 这就是<strong>倍增法</strong>的思想了, 我们进行范围缩小不是一步一步的, 那样太暴力了, <strong>所以我们需要某个跨度, 让我们能够先跨越大步, 接近的时候在小步小步跨越, 这样可以大大节省时间.</strong></p><p><em><em>读者可能会疑惑, 先大步, 后小步, 可是我怎么知道什么时候该大步, 什么时候该小步呢? 难道不会不小心跨过头吗? </em></em></p><p>其实不会的, 在代码实现上, <strong>这样的跨越有条件约束, 是非常讲究的. 读者不必为此纠结, <em><em> 不过要讲解也是十分费力不讨好的事情, 所以请读者认证推敲后面Lca函数的代码, 认真琢磨为什么是那样跨越, 其中真味自会品出. </em></em>最好是自己写几个例子, 模拟跨越的过程, 在结合现实意义去理解</strong></p><p>那么我们回到当前问题. 请看下面这个公式:</p><blockquote><p><strong>parents[i][j] = parents[parents[i][j-1]][j-1]</strong></p></blockquote><p>这是构造此数组的公式. 不难理解, <em><em>父亲的父亲就是爷爷, 爷爷的爷爷就是4倍祖先. </em></em> 请读者结合现实意义去理解. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void getParents()</span><br><span class="line">&#123;</span><br><span class="line">for (int up = 1; (1 &lt;&lt; up) &lt;= n; ++up) &#123;</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">parents[i][up] = parents[parents[i][up - 1]][up - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h3><p>做完了前面<strong>O(VlogV)</strong>的预处理操作, 剩下的就是查询了, 一次查询<strong>O(logV)</strong></p><p>因此, 我们可以敏锐的想到: <strong>Lca算法适合查询次数比较多的情况, 不然, 光是预处理就花了那么多时间了</strong>. 所以说, 查询是我们享受成果的时候了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int Lca(int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">if (depth[u] &lt; depth[v]) swap(u, v); // 使满足u深度更大, 便于后面操作 </span><br><span class="line">int i = -1, j;</span><br><span class="line">// i求的是最大二分跨度 </span><br><span class="line">while ((1 &lt;&lt; (i + 1)) &lt;= depth[u]) ++i;</span><br><span class="line"></span><br><span class="line">// 下面这个循环是为了让u和v到同一深度 </span><br><span class="line">for (j = i; j &gt;= 0; --j) &#123;</span><br><span class="line">if (depth[u] - (1 &lt;&lt; j) &gt;= depth[v]) &#123; // 是&gt;=, 因为如果&lt;,代表跳过头了,跳到了上面. </span><br><span class="line">u = parents[u][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (u == v) return u; // 刚好是祖宗 </span><br><span class="line"></span><br><span class="line">// u和v一起二分找祖宗</span><br><span class="line">for (j = i; j &gt;= 0; --j) &#123;</span><br><span class="line">if (parents[u][j] != parents[v][j]) &#123;</span><br><span class="line">u = parents[u][j];</span><br><span class="line">v = parents[v][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return parents[u][0]; // 说明上个循环迭代到了Lca的子结点 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>首先把u调整到深度更大(或相同)的结点, 便于后面操作.</p></li><li><p>然后获取最大跨度i, 所有的跨越都是从i开始的.</p></li><li><p>再然后把u上升到和v一样的深度. 也就是我们前面讨论过的情况二转情况一.</p></li><li><p>最后, 两个结点同时迭代, 直到找到Lca</p></li></ul><p>至此, 我们的问题就解决了.</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn = 10005;</span><br><span class="line">int parents[maxn][20], depth[maxn];</span><br><span class="line">int n, from[maxn], root = -1;</span><br><span class="line">vector&lt;int&gt; G[maxn];</span><br><span class="line"></span><br><span class="line">void init()</span><br><span class="line">&#123;</span><br><span class="line">memset(parents, -1, sizeof(parents));</span><br><span class="line">memset(from, -1, sizeof(from));</span><br><span class="line">memset(depth, -1, sizeof(depth));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getData()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int u, v;</span><br><span class="line">for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">G[u].push_back(v);</span><br><span class="line">parents[v][0] = u;</span><br><span class="line">from[v] = 1;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">if (from[i] == -1) root = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getDepth_dfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">int len = G[u].size();</span><br><span class="line">for (int i = 0; i &lt; len; ++i) &#123;</span><br><span class="line">int v = G[u][i];</span><br><span class="line">depth[v] = depth[u] + 1;</span><br><span class="line">getDepth_dfs(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getDepth_bfs(int u)</span><br><span class="line">&#123;</span><br><span class="line">queue&lt;int&gt; Q;</span><br><span class="line">Q.push(u);</span><br><span class="line">while (!Q.empty()) &#123;</span><br><span class="line">int v = Q.front();</span><br><span class="line">Q.pop();</span><br><span class="line">for (int i = 0; i &lt; G[v].size(); ++i) &#123;</span><br><span class="line">depth[G[v][i]] = depth[v] + 1;</span><br><span class="line">Q.push(G[v][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void getParents()</span><br><span class="line">&#123;</span><br><span class="line">for (int up = 1; (1 &lt;&lt; up) &lt;= n; ++up) &#123;</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">parents[i][up] = parents[parents[i][up - 1]][up - 1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int Lca(int u, int v)</span><br><span class="line">&#123;</span><br><span class="line">if (depth[u] &lt; depth[v]) swap(u, v);</span><br><span class="line">int i = -1, j;</span><br><span class="line">while ((1 &lt;&lt; (i + 1)) &lt;= depth[u]) ++i;</span><br><span class="line">for (j = i; j &gt;= 0; --j) &#123;</span><br><span class="line">if (depth[u] - (1 &lt;&lt; j) &gt;= depth[v]) &#123;</span><br><span class="line">u = parents[u][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (u == v) return u;</span><br><span class="line">for (j = i; j &gt;= 0; --j) &#123;</span><br><span class="line">if (parents[u][j] != parents[v][j]) &#123;</span><br><span class="line">u = parents[u][j];</span><br><span class="line">v = parents[v][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return parents[u][0];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void questions()</span><br><span class="line">&#123;</span><br><span class="line">int q, u, v;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line">for (int i = 0; i &lt; q; ++i) &#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">int ans = Lca(u, v);</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">//cout &lt;&lt; u &lt;&lt; &quot; 和 &quot; &lt;&lt; v &lt;&lt; &quot; 的最近公共祖先(LCA)是: &quot; &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">getData();</span><br><span class="line">depth[root] = 1;</span><br><span class="line">getDepth_dfs(root);</span><br><span class="line">//getDepth_bfs(root);</span><br><span class="line">getParents();</span><br><span class="line">questions();</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">9</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">6 8</span><br><span class="line">7 9</span><br><span class="line">5</span><br><span class="line">1 3</span><br><span class="line">5 6</span><br><span class="line">8 9</span><br><span class="line">8 4</span><br><span class="line">5 8</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP_最长不下降子序列</title>
      <link href="/2018/07/11/dp-zui-chang-bu-xia-jiang-zi-xu-lie-lis/"/>
      <url>/2018/07/11/dp-zui-chang-bu-xia-jiang-zi-xu-lie-lis/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>同类的问题还有<em>“最长上升子序列”, “最长下降子序列”, …</em></p><p>他们的不同就在于<strong>定义的core规则不同</strong>, 有的是&gt;=, 有的是&gt;, 有的是&lt;</p><p>由此启发, 我们可以在解决其他的问题, <strong>不一定是比较数的大小的问题里面抽象出这种模型.</strong></p><p>下面介绍这种动态规划入门都会介绍的问题的思路. </p><p>首先我们从头开始分析这个问题.</p><h3 id="一-最容易想到的最暴力的方法"><a href="#一-最容易想到的最暴力的方法" class="headerlink" title="一. 最容易想到的最暴力的方法"></a>一. 最容易想到的最暴力的方法</h3><p>对这个序列中的每一个数的”有”和”无”分两种情况讨论. 代码实现上就是递归.</p><p><strong>时间复杂度就是O(2^n)</strong></p><p>代码实现上较为简单. 不展示</p><h3 id="二-第二种方法是O-n-2-的DP方法"><a href="#二-第二种方法是O-n-2-的DP方法" class="headerlink" title="二. 第二种方法是O(n^2)的DP方法"></a>二. 第二种方法是O(n^2)的DP方法</h3><p><strong>动态规划的问题是无后效性的, 每个问题都可以分解为更小的子问题, 从而求解.</strong></p><p>这道题也不例外.</p><p>这个序列的每一个数为止都有一个解, 作为子问题的解. 后面的问题的解就是从这些子问题的最优解继承过来的.</p><p>so, 给这个序列的解建立数组dp[n], 0 - n分别是截止到Ai的解.</p><blockquote><p>当下一个数要加入来的时候, 有两种情况</p><ol><li><p>前面的数都比当前数更大, 因此以这个数为止的最长不下降子序列的长度就是1. 遍历到第一个数的情况也包含在内.</p></li><li><p>前面的数有不比当前数大的, 那么这个数的结果dp[i] = max(dp[i], dp[j] + 1). 这个过程遍历前面所有数的dp[j]进行比较.</p></li></ol><p><strong>最后的答案就是所有dp[i]里面的最大值.</strong></p></blockquote><p>这种方法的<strong>时间复杂度是O(n^2)</strong>, 可以看到相比于前面暴力递归的方法有了极大的进步.</p><p>代码通过样例, 但不一定能过题, 请谨慎使用.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, x;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">v.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">int dp[(int)v.size()] = &#123;1&#125;, ans = 1;</span><br><span class="line">for (int i = 1; i &lt; (int)v.size(); ++i) &#123;</span><br><span class="line">for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">if (v[i] &gt;= v[j]) dp[i] = max(dp[i], dp[j] + 1); // 状态转移方程</span><br><span class="line">&#125;</span><br><span class="line">ans = max(ans, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">8</span><br><span class="line">1 2 3 -9 3 9 0 11</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="三-O-nlogn-方法-维护单调数组"><a href="#三-O-nlogn-方法-维护单调数组" class="headerlink" title="三. O(nlogn)方法, 维护单调数组"></a>三. O(nlogn)方法, 维护单调数组</h3><p>这个方法也是DP方法</p><p>时间复杂度可以从O(n^2)降到O(n log n).</p><p><strong>我们从最长上升子序列的角度来探讨</strong></p><p>假设对一个序列n[1…9] = {2 1 5 3 6 4 8 9 7}, 维护一个单调数组, 使得这个数组为最长上升子序列. 设这个数组为d[ ].</p><p>对n[1] = 2, 使得d[1] = 2;</p><p>对n[2] = 1, 因为1比2小, 所以修改d[1]的值, 使其为1</p><p>对n[3] = 5, 5比1大, 所以len++, d[2] = 5</p><p>对n[4] = 3, 3比1大比5小, 所以替换掉5, 使d[2] = 3</p><p>对n[5] = 6, 6比d[2]大, 所以len++, d[3] = 6</p><p>对n[6] = 4, 4比3大比6小, 所以替换掉6, 使d[3] = 4</p><p>对n[7] = 8, 8比4大, 所以len++, 使d[4] = 8</p><p>对n[8] = 9, 9比8大, 所以len++, 使d[5] = 9</p><p>对n[9] = 7, 7比4大比8小, 所以替换掉8, 使d[4] = 7.</p><p>至此这个序列遍历完了, 最小的长度也出来了. 最后的序列是1 3 4 7 9, len = 5</p><p> 仔细琢磨会觉得, <strong>如最后一步操作, 为什么后面的7反而到他前面的8, 9的前面去了.</strong> 其实仔细一想并无问题, 因为即使7出现在前面, 它并不影响最终结果, <strong>因为我们已经得出最后结果就是len</strong>, 而以7为结尾的最长序列在该题中是len - 1, 如果后面还有序列, <strong>那么这里把7替换掉8会使得当前状态更优, 因为这样的修改是不会改变当前结果的, 但是确实后续最优状态的基础. 而这道题的动态规划思想就是这样, 不断地获取最优状态.</strong></p><p>经过前面的分析我们也许会发现, 这个DP的过程无法存储中间结果, 也就是说<strong>我们只能知道最长的子序列是多长, 而无法得到是哪个序列.</strong> 可谓是有利有弊.</p><p>利用我们维护的数组的单调性, 我们可以用二分法查找这个比当前数更大数的位置, 从而方便的实现替换.</p><p>所以时间复杂度为O(n log n).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n, x;</span><br><span class="line">vector&lt;int&gt; v, vec;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">v.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; (int)v.size(); ++i) &#123;</span><br><span class="line">if (i == 0) vec.push_back(v[0]);</span><br><span class="line">else &#123;</span><br><span class="line">if (v[i] &gt;= vec[vec.size() - 1]) vec.push_back(v[i]);</span><br><span class="line">else *upper_bound(vec.begin(), vec.end(), v[i]) = v[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; (int)vec.size(); ++i) &#123;</span><br><span class="line">cout &lt;&lt; vec[i] &lt;&lt; &apos; &apos;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &quot;len == &quot; &lt;&lt; vec.size() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">9</span><br><span class="line">2 1 5 3 6 4 8 9 7</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP_最长回文子串</title>
      <link href="/2018/07/11/dp-zui-chang-hui-wen-zi-chuan/"/>
      <url>/2018/07/11/dp-zui-chang-hui-wen-zi-chuan/</url>
      
        <content type="html"><![CDATA[<p>####DP问题, 最长回文子串</p><p>最长回文子串问题指的是在一个字符串中, 是回文子串的长度的最大值. 这里的回文子串是<strong>连续的</strong>. </p><p><em>如字符串”PATZJUJZTACCBCC”, 他的最长回文子串是”ATZJUJZTA”, 长度为9, 当然它还有其他回文子串如”CCBCC”, 但是长度不够长.</em></p><p>这类问题似乎有多种解法, 复杂度从O(n^3)到O(n)不等.</p><p>下面介绍一种<strong>时间复杂度为O(n^2)</strong>的.</p><p>思路是典型的DP思路, 我们可以考量这样一个数组, dp[i][j], bool类型, 值为1代表字符串从S[i]到S[j]是回文子串, 值为0代表不是.</p><p>那么对于任意的i, j, 如何判断dp[i][j]的值呢? 讨论下面两种情况:</p><p><strong>1. s[i] = s[j]时, 如果dp[i+1][j-1] = 0, 即从s[i+1]到s[j-1]是回文子串, 那么从s[i][j]自然是回文子串, 所以dp[i][j] = dp[i+1][j-1]</strong><br><strong>2.  s[i] != s[j]时, 如论如何dp[i][j] = 0</strong></p><p>那么这样看思路就非常清晰了, 看上去非常简单, 按照这个规则判断一下就好了.</p><p>不过其实这道题是非常有技巧的, 我们可以看到要获取dp[i][j]值, 那么就需要知道dp[i+1][j-1]的值, 那么就不能从前往后遍历i了, 怎么办呢? 从后往前遍历吗? 当然也不行. 这就是这种方法的精彩所在, 两套循环,<strong>外围遍历长度, 内围遍历字符串起始点i.</strong></p><p>因为dp[i][j]的长度是j - i + 1, 而dp[i+1][j-1]的长度是j - i - 1, 长度差了两个, 如果我把长度小的结果都求解出来了, 那么长度更长的用长度更小的, 无论i是否会更大, 都是可以的. 不得不说很是精彩.</p><p>代码实现上, <strong>注意前面初始化长度 2时对ans赋恰当的值.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str; </span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">int dp[str.size() + 1][str.size() + 1] = &#123;&#125;, ans = 1;</span><br><span class="line">for (int i = 0; i &lt; int(str.size()); ++i) &#123;</span><br><span class="line">dp[i][i] = 1;</span><br><span class="line">if (str[i] == str[i + 1]) &#123;</span><br><span class="line">dp[i][i + 1] = 1;</span><br><span class="line">ans = 2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for (int len = 3; len &lt;= (int)str.size(); ++len) &#123;</span><br><span class="line">for (int i = 0; i + len - 1 &lt; (int)str.size(); ++i) &#123;</span><br><span class="line">int k = i + len - 1;</span><br><span class="line">if (str[i] == str[k]) &#123;</span><br><span class="line">dp[i][k] = dp[i + 1][k - 1];</span><br><span class="line">if (dp[i][k]) ans = len;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">PATZJUJZTACCBCC    ans = 9</span><br><span class="line"></span><br><span class="line">34567536487326483254   ans = 1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学_C++生成真值表_模拟</title>
      <link href="/2018/04/07/chi-san-shu-xue-c-sheng-cheng-zhen-zhi-biao-mo-ni/"/>
      <url>/2018/04/07/chi-san-shu-xue-c-sheng-cheng-zhen-zhi-biao-mo-ni/</url>
      
        <content type="html"><![CDATA[<p>生成真值表的代码</p><p>输入一个真值表达式, 程序自动生成它的真值表.</p><p>纯模拟思路</p><blockquote><p>合取*<br>析取|<br>单条件&gt;<br>双条件-<br>非!</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int cnt = 0, chval[26] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">void getAlpha(string str, char *chs, int &amp;cnt)  //获取真值表中的字符 </span><br><span class="line">&#123;</span><br><span class="line">int ch[26] = &#123;&#125;;</span><br><span class="line">for(int i = 0; i &lt; (int)str.length(); ++i) &#123;</span><br><span class="line">if(isalpha(str[i])) ch[str[i] - &apos;a&apos;] ++;</span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; 26; ++i) &#123;</span><br><span class="line">if(ch[i]) &#123;</span><br><span class="line">chs[cnt++] = i+97;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string shuzhitihuan(string str, int chval[26])</span><br><span class="line">&#123;</span><br><span class="line">string st = &quot;&quot;;</span><br><span class="line">for(int i = 0; i &lt; str.size(); ++i) &#123;</span><br><span class="line">if(str[i] &lt;= &apos;z&apos; &amp;&amp; str[i] &gt;= &apos;a&apos;) &#123;</span><br><span class="line">st += chval[str[i] - &apos;a&apos;] ? &quot;1&quot;:&quot;0&quot;;</span><br><span class="line">&#125; else st += str[i];</span><br><span class="line">&#125;</span><br><span class="line">return st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void qvkuohao(string &amp; str)  //需要去除两种括号()(1)(0)</span><br><span class="line">&#123;</span><br><span class="line">string st = &quot;&quot;;</span><br><span class="line">for(int i = 0; i &lt; str.size(); ++i) &#123;</span><br><span class="line">if(str[i] == &apos;(&apos; &amp;&amp; i+2 &lt; str.size() &amp;&amp; str[i+2] == &apos;)&apos;) &#123;</span><br><span class="line">st += str[i+1];</span><br><span class="line">i += 2;</span><br><span class="line">&#125; else st += str[i];</span><br><span class="line">&#125;</span><br><span class="line">str = st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void qvfei(string &amp;str) </span><br><span class="line">&#123;</span><br><span class="line">string st = &quot;&quot;;</span><br><span class="line">for(int i = 0; i &lt; str.size(); ++i) &#123;</span><br><span class="line">if(str[i] == &apos;!&apos; &amp;&amp; i+1 &lt; str.size() &amp;&amp; str[i+1] == &apos;0&apos;) &#123;</span><br><span class="line">st += &apos;1&apos;;</span><br><span class="line">i++;</span><br><span class="line">&#125; else if(str[i] == &apos;!&apos; &amp;&amp; i + 1 &lt; str.size() &amp;&amp; str[i+1] == &apos;1&apos;) &#123;</span><br><span class="line">st += &apos;0&apos;;</span><br><span class="line">i++;</span><br><span class="line">&#125; else st += str[i];</span><br><span class="line">&#125;</span><br><span class="line">str = st;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">void qvheqv(string &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">string st = &quot;&quot;;</span><br><span class="line">for(int i = 0; i &lt; str.size(); ++i) &#123;</span><br><span class="line">if(str[i] == &apos;1&apos; &amp;&amp; i+2 &lt; str.size() &amp;&amp; str[i+2] == &apos;1&apos; &amp;&amp; str[i+1] == &apos;*&apos;) &#123;</span><br><span class="line">st += &apos;1&apos;;</span><br><span class="line">i += 2;</span><br><span class="line">&#125; else if(i+2 &lt; str.size() &amp;&amp; str[i+1] == &apos;*&apos; &amp;&amp; ((str[i] == &apos;1&apos; &amp;&amp; str[i+2] == &apos;0&apos;)</span><br><span class="line">|| (str[i] == &apos;0&apos; &amp;&amp; str[i+2] == &apos;1&apos;) || (str[i] == &apos;0&apos; &amp;&amp; str[i+2] == &apos;0&apos;))) &#123;</span><br><span class="line">st += &apos;0&apos;;</span><br><span class="line">i += 2;</span><br><span class="line">&#125; else st += str[i];</span><br><span class="line">&#125;</span><br><span class="line">str = st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void qvxiqv(string &amp; str)</span><br><span class="line">&#123;</span><br><span class="line">string st = &quot;&quot;;</span><br><span class="line">for(int i = 0; i &lt; str.size(); ++i) &#123;</span><br><span class="line">if(str[i] == &apos;0&apos; &amp;&amp; i+2 &lt; str.size() &amp;&amp; str[i+2] == &apos;0&apos; &amp;&amp; str[i+1] == &apos;|&apos;) &#123;</span><br><span class="line">st += &apos;0&apos;;</span><br><span class="line">i += 2;</span><br><span class="line">&#125; else if (i+2 &lt; str.size() &amp;&amp; str[i+1] == &apos;|&apos; &amp;&amp; ((str[i] == &apos;1&apos; &amp;&amp; str[i+2] == &apos;0&apos;)</span><br><span class="line">|| (str[i] == &apos;0&apos; &amp;&amp; str[i+2] == &apos;1&apos;) || (str[i] == &apos;1&apos; &amp;&amp; str[i+2] == &apos;1&apos;))) &#123;</span><br><span class="line">st += &apos;1&apos;;</span><br><span class="line">i += 2;</span><br><span class="line">&#125; else st += str[i];</span><br><span class="line">&#125;</span><br><span class="line">str = st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void qvdantiaojian(string &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">string st = &quot;&quot;;</span><br><span class="line">for(int i = 0; i &lt; str.size(); ++i) &#123;</span><br><span class="line">if(str[i + 1] == &apos;&gt;&apos; &amp;&amp; str[i] == &apos;1&apos; &amp;&amp; str[i+2] == &apos;0&apos;) &#123;</span><br><span class="line">st += &apos;0&apos;;</span><br><span class="line">i += 2;</span><br><span class="line">&#125; else if(str[i+1] == &apos;&gt;&apos; &amp;&amp; ((str[i] == &apos;1&apos; &amp;&amp; str[i+2] == &apos;1&apos;)</span><br><span class="line">|| str[i] == &apos;0&apos; &amp;&amp;(str[i+2] == &apos;1&apos; || str[i+2] == &apos;0&apos;))) &#123;</span><br><span class="line">st += &apos;1&apos;;</span><br><span class="line">i += 2;</span><br><span class="line">&#125; else st += str[i];</span><br><span class="line">&#125;</span><br><span class="line">str = st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void qvshuangtiaojian(string &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">string st = &quot;&quot;;</span><br><span class="line">for(int i = 0; i &lt; str.size(); ++i) &#123;</span><br><span class="line">if(str[i+1] == &apos;-&apos; &amp;&amp; ((str[i] == &apos;1&apos; &amp;&amp; str[i+2] == &apos;1&apos;) || (str[i] == &apos;0&apos; &amp;&amp; str[i+2] == &apos;0&apos;))) &#123;</span><br><span class="line">st += &apos;1&apos;;</span><br><span class="line">i += 2;</span><br><span class="line">&#125; else if(str[i+1] == &apos;-&apos; &amp;&amp; ((str[i] == &apos;1&apos; &amp;&amp; str[i+2] == &apos;0&apos;) || (str[i] == &apos;0&apos; &amp;&amp; str[i+2] == &apos;1&apos;))) &#123;</span><br><span class="line">st += &apos;0&apos;;</span><br><span class="line">i += 2;</span><br><span class="line">&#125; else st += str[i]; </span><br><span class="line">&#125;</span><br><span class="line">str = st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string str, tmp;</span><br><span class="line">char chs[12];</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">getAlpha(str, chs, cnt);  //只讨论小写字母</span><br><span class="line">tmp = str;</span><br><span class="line">for(int j = 0; j &lt; cnt; ++j) &#123;</span><br><span class="line">cout &lt;&lt; chs[j] &lt;&lt; &quot;  &quot;;</span><br><span class="line">&#125; </span><br><span class="line">cout &lt;&lt; tmp;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">for(int i = 0; i &lt; pow(2, cnt); ++i) &#123;</span><br><span class="line">for(int j = 0; j &lt; cnt; ++j) &#123; //赋值过程 </span><br><span class="line">chval[chs[j] - &apos;a&apos;] = (1 &amp; (i&gt;&gt;(cnt-1-j)));</span><br><span class="line">&#125;cout &lt;&lt; endl;</span><br><span class="line">for(int j = 0; j &lt; cnt; ++j) &#123;</span><br><span class="line">cout &lt;&lt; chval[chs[j] - &apos;a&apos;] &lt;&lt; &quot;  &quot;;</span><br><span class="line">&#125;</span><br><span class="line">str = shuzhitihuan(str, chval);</span><br><span class="line">while(str.size() != 1) &#123;</span><br><span class="line">qvkuohao(str);</span><br><span class="line">qvfei(str);</span><br><span class="line">qvheqv(str);</span><br><span class="line">qvxiqv(str);</span><br><span class="line">qvdantiaojian(str);</span><br><span class="line">qvshuangtiaojian(str); </span><br><span class="line">&#125;</span><br><span class="line">for(int i = 0; i &lt; tmp.size() / 2; ++i) cout &lt;&lt; &apos; &apos;;</span><br><span class="line">cout &lt;&lt;  str &lt;&lt; endl;</span><br><span class="line">str = tmp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">((p*q)*r) </span><br><span class="line">(p*q)|(!p*!q)</span><br><span class="line">(!p|q)*(!q|p) </span><br><span class="line">(p&gt;q)*(q&gt;p)</span><br><span class="line">!(p*q)&gt;(!p*!q)</span><br><span class="line">p-q </span><br><span class="line">(!p|r)*(r&gt;q)|p*q</span><br><span class="line">p*q|r*b</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一键安装v2ray</title>
      <link href="/2018/03/10/yi-jian-an-zhuang-v2ray/"/>
      <url>/2018/03/10/yi-jian-an-zhuang-v2ray/</url>
      
        <content type="html"><![CDATA[<p>0、我的vps版本：Ubuntu 18.10 x64。 地点：东京。</p><p>1、v2ray官方给出了一键安装脚本<br><code>bash &lt;(curl -L -s https://install.direct/go.sh)</code></p><p>2、很快就可以安装好了，可以用这个命令来查看状态<br><code>service v2ray status</code></p><p>3、有以下这些命令，刚开始需要启动服务<br><code>service v2ray start|stop|status|reload|restart|force-reload</code></p><p>4、由于是一键安装，于是那些设置都是默认的，可以到<code>/etc/v2ray/config.json</code>来配置自己的服务器，也是到这里找到设置然后给我们的客户端进行设置。</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0xww85mr9j30rw0ng40a.jpg" alt="在这里插入图片描述"><br>5、延迟在90ms左右<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0xwwpt5ekj30pv038aa0.jpg" alt="在这里插入图片描述"><br>6、一键进行BBR加速</p><p><code>wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</code></p><p>7、我选择的是6<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0xwxb7ee4j30oi0jt40k.jpg" alt="在这里插入图片描述"></p><p>8、测试了一下延迟，最低居然达到了31ms，简直令人发指！！！</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0xwy4d8zcj30qf01u747.jpg" alt="在这里插入图片描述"><br>9、多试几次稳定在60ms左右，也是非常低的延迟了！<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0xwyj0jy7j30q501tq2u.jpg" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
            <tag> v2ray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主元素问题_奇妙的思维</title>
      <link href="/2018/02/13/zhu-yuan-su-wen-ti-qi-miao-de-si-wei/"/>
      <url>/2018/02/13/zhu-yuan-su-wen-ti-qi-miao-de-si-wei/</url>
      
        <content type="html"><![CDATA[<h1 id="主元素问题"><a href="#主元素问题" class="headerlink" title="主元素问题"></a>主元素问题</h1><h2 id="什么是主元素问题"><a href="#什么是主元素问题" class="headerlink" title="什么是主元素问题?"></a>什么是主元素问题?</h2><blockquote><p>已知一个数组的大小，并且其中存在一个数，出现的频率大于50%，则称其为该数组的主元素。用一个算法找出这个数，要求其时间复杂度尽可能低。</p></blockquote><p>这是一个很简单的问题, 解决的方法有很多, 思考这样一道问题的意义不在于只是把它解决, 而是找出多种解决它的方法, 感受算法的神奇.</p><p>衡量一个算法优劣的一个非常重要的尺度是<strong>时间复杂度</strong>, 我们如何让计算机用最短的时间, 解决这个问题呢?</p><h2 id="先排序-比较排序-后计数的方法"><a href="#先排序-比较排序-后计数的方法" class="headerlink" title="先排序(比较排序)后计数的方法"></a>先排序(比较排序)后计数的方法</h2><p>先排序后后比较, 这种方法是比较常规的思维.<br>排序之后将每个相同的元素计数, 再根据数量判断是哪一个元素</p><p>比较排序最快的平均时间复杂度是O(nlogn), 所以这个方法最快的时间按复杂度是O(nlogn)</p><blockquote><p><em><em>这种排序方式在所有方式中效率较低, 但它适合各种数据类型(如浮点型), 且在某些情况下空间复杂度比计数排序的方法小很多. </em></em></p></blockquote><p><strong>还可以判断是否存在这样一个主元素.</strong></p><p>代码比较简单且常规, 不写出(实际上用STL的sort()很简单, 但手写快排, 还是算了吧……)</p><h3 id="一个简单优化"><a href="#一个简单优化" class="headerlink" title="一个简单优化"></a>一个简单优化</h3><p>对于一个已经排序好了的序列, 其实不需要给每个元素计数.</p><blockquote><p><strong>因为它是主元素(&gt;50%), 所以只要取中值就可以知道它是哪个(它的值).</strong></p></blockquote><h2 id="计数排序的方法"><a href="#计数排序的方法" class="headerlink" title="计数排序的方法"></a>计数排序的方法</h2><p>计数排序也叫桶排序, 是一种非比较型排序.</p><p>时间复杂度位O(N) (N取决于数据范围)</p><p>鉴于计数排序对数据类型的限制很大, 所以比较各种排序方法的优劣时通常不把计数排序和快排这种比较排序相比较(事实上没有意义)</p><p><strong>如果数据稀松或者范围很大, 计数排序将会非常浪费空间(空间复杂度非常大)</strong></p><p>但在某些特定的条件下, 计数排序确实是一种时间复杂度位O(n)的排序算法<br>如: 数据是1-1e6之间的整数</p><p><strong>同样可以判断是否存在这样一个主元素</strong></p><p>而使用计数排序的方法觉得这道题, 不需要排序, 事实上它可以看作计数排序的一个子过程</p><h2 id="用STL中的nth-element-函数"><a href="#用STL中的nth-element-函数" class="headerlink" title="用STL中的nth_element()函数"></a>用STL中的nth_element()函数</h2><p>刚认识nth_element()函数没几天, 写这个问题的时候突然觉得可以用这个函数解决主元素问题.</p><p>思路是: </p><blockquote><p>对N个数的序列用nth_element()找到第<strong>N/2+1</strong>个元素的值.<br>这个值就是<strong>主元素的值</strong></p></blockquote><p>缺陷是:</p><blockquote><p>无法判断是否存在主元素</p></blockquote><p>这是奇数的情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 7</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a[] = &#123;1, 4, 3, 1, 1, 2, 1&#125;; //N为奇数, 从0开始 </span><br><span class="line">nth_element(a, a + N/2, a + N);</span><br><span class="line">cout &lt;&lt; a[N/2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是偶数的情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#define N 6 </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int a[] = &#123;1, 3, 1, 1, 2, 1&#125;; //N为偶数, 从0开始 </span><br><span class="line">nth_element(a, a + N/2, a + N);</span><br><span class="line">cout &lt;&lt; a[N/3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>时间复杂度为O(N)</strong><br><strong>nth_element()是STL算法库中一种O(N)的单元素排序算法函数</strong></p><h2 id="豆瓣里一种巧妙地方法"><a href="#豆瓣里一种巧妙地方法" class="headerlink" title="豆瓣里一种巧妙地方法"></a><a href="https://www.douban.com/note/505717075/" target="_blank" rel="noopener">豆瓣里一种巧妙地方法</a></h2><p>最后介绍的是一种豆瓣网友分享的巧妙算法</p><blockquote><p>其核心思想在于：<strong>对于这样一个数组，去除掉任意两个不相等的数，剩下的数中，主元素的出现频率仍然大于50%。</strong></p></blockquote><p>但又缺陷:</p><blockquote><p><strong>只能在确定存在主元素的序列中找到这个主元素.</strong><br>即无法判断是否存在主元素 </p></blockquote><blockquote><p>引自豆瓣:<br>解法：<br>声明一个变量count = 0，声明一个常量size等于数组大小。<br>假设该数组的第一个元素a(1)为主元素，让其与a(2)进行比较，若相同，则使变量count+1，若不同，则count-1。然后继续比较a(3)。以此类推。</p><p>当与a(n)比较后，count = -1时，将count重新归为0，并重新假设a(n+1)为主元素，并继续与a(n+2)作比较。</p><p>当count&gt;=(size-m)/2时，此时假设的主元素a(m)即为实际的主元素。 或遍历完整个数组后，当前假设的主元素为实际主元素。</p><p>这个算法的时间复杂度最大才O(N)，看书看到这一段时令我顿时拍案叫绝啊。其核心思想在于：对于这样一个数组，去除掉任意两个不相等的数，剩下的数中，主元素的出现频率仍然大于50%。而使用count来进行加减计数，当count=0时，必然是偶数个数与假设的主元素进行了比较，且其中有一半与假设数相同一半与假设数不同（当count=-1时，加上假设数的集合，也满足该条件）。</p></blockquote><p>下面是我写的简单代码(<strong>可能又bug</strong>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define N 7</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//int a[] = &#123;1, 4, 3, 1, 1, 2, 1&#125;;</span><br><span class="line">int a[] = &#123;1, 3, 4, 4, 5, 4, 4&#125;;</span><br><span class="line">//int a[] = &#123;1 ,5 ,6 ,8 ,7 ,9 ,4 ,2 ,7 ,5 ,2 ,2 ,2 ,2&#125;;</span><br><span class="line">int cnt = 0, tmp = a[0];</span><br><span class="line">for(int i = 1; i &lt; N; ++i) &#123;</span><br><span class="line">if(tmp == a[i]) cnt++;</span><br><span class="line">else cnt--;</span><br><span class="line">if(cnt &lt; 0) &#123;</span><br><span class="line">tmp = a[i];</span><br><span class="line">cnt = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; &quot;cnt == &quot; &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">if (cnt &gt; 0) cout &lt;&lt; tmp &lt;&lt; endl; </span><br><span class="line">else cout &lt;&lt; &quot;There is no such a number !\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###总而言之, 主元素问题是一种很简单的思维启发问题, 方法有很多, 可是你想到了最简单的方法吗?</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子段和_三种方法</title>
      <link href="/2018/02/09/zui-da-zi-duan-he-san-chong-fang-fa/"/>
      <url>/2018/02/09/zui-da-zi-duan-he-san-chong-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>今天参加了一场洛谷网的比赛, 深受打击. 寒假过了这么多天, 一直没有认真学习算法, 以至于现在的水平比两个月前还要低. </p><p>本来就没有多少底子, 又退步了许多, 感慨万分.</p><p>在洛谷上看到这么一道题<br><a href="https://www.luogu.org/problemnew/show/P1115" target="_blank" rel="noopener">最大子段和</a></p><p>如果数据小的话, <strong>用暴力枚举</strong>很简单就可以做出来了, 时间按复杂度位O(n^3)<br>可是一道算法题怎么会这么简单呢?</p><p>样例的数据是非常大的, 所以用n^3的办法一个样例都过不了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt; </span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//std::ios::sync_with_stdio(false);</span><br><span class="line">long long int n, num[22000], Max = -1e8, sum;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for( int i = 1; i &lt;= n; ++i ) &#123;</span><br><span class="line">scanf(&quot;%lld&quot;, &amp;num[i]);</span><br><span class="line">&#125;</span><br><span class="line">for( int i = 1; i &lt;= n; ++ i ) &#123;</span><br><span class="line">for( int j = 1; j &lt;= n - i + 1; ++j ) &#123;</span><br><span class="line">sum = 0;</span><br><span class="line">for(int k = j; k &lt; j + i; ++k) &#123;</span><br><span class="line">sum += num[k];</span><br><span class="line">&#125;</span><br><span class="line">//cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">Max = max(Max, sum);</span><br><span class="line">//cout &lt;&lt; Max &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; Max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微优化一下, 使用<strong>前缀和以及差分</strong>, 可以有效地将复杂度降为O(n^2), 可是, 对于这道题来说, 这个时间还是太多了. 只能通过40%的样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">long long int n, num[220000], qz[220000] = &#123;&#125;, ans = -1e9;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">//std::ios::sync_with_stdio(false);</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for( int i = 1; i &lt;= n; ++ i ) &#123;</span><br><span class="line">//cin &gt;&gt; num[i];</span><br><span class="line">scanf(&quot;%lld&quot;, &amp;num[i]);</span><br><span class="line">&#125;</span><br><span class="line">for( int i = 1; i &lt;= n; ++i ) &#123;</span><br><span class="line">qz[i] = qz[i-1] + num[i];</span><br><span class="line">&#125;</span><br><span class="line">for( int i = 1; i &lt;= n; ++i ) &#123;</span><br><span class="line">for( int j = 1; j &lt;= n-i+1; ++j ) &#123;</span><br><span class="line">ans = max(ans, qz[j+i-1] - qz[j-1]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种<strong>分治</strong>的方法做这道题, 时间复杂度为O(nlogn), 有点复杂,我还不会.</p><p>最简单的呢, <strong>使用DP的方法, 时间复杂度为O(n)</strong></p><p>这种方法凭我自己现在的水平是想不出来的, 尤其是现在状态如此之差. 看别人解释后写了代码觉得如此巧妙, 于是又惊叹算法之神奇</p><p>可怜的是, 即便别人告诉我这道题用DP解最简单, 我也解不出来, 谁叫我DP还没入门呢?</p><p>思路描述是这样的:</p><blockquote><p>a数组是储存输入的数值；c[i]表示的是a数组从头加到i的和；b[i]表示的是从头到i包括i的的最大子段和~（必须包括i！！！）；minn储存最小的前缀和（因为要减去所以要尽量小，详情见下一行） 动态转移方程式：b[i]=c[i]-minn（总和减去前缀和） 最后输出b数组最大的值（题目求最大的子段和）</p></blockquote><p>第一阶段的代码是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long int qz[220000] = &#123;&#125;, num[220000], mm[220000] = &#123;&#125;, an[220000], ans = -1e9;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for(int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">scanf(&quot;%lld&quot;, &amp;num[i]);</span><br><span class="line">qz[i] = num[i] + qz[i - 1];</span><br><span class="line">mm[i] = min(mm[i - 1], qz[i - 1]);</span><br><span class="line">ans = max(ans, qz[i] - mm[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度确实是小, 但是有一个问题就是空间复杂度太大了, 没必要这样开数组.</p><p>看了别人的题解, dalao们用的是滚动数组, 一个上面220000的数组只用两个元素循环滚动即可.</p><p>叹服!</p><p>妙哉!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long int qz[2] = &#123;&#125;, mm[2] = &#123;&#125;, ans = -1e9, m, n;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">for( int i = 1; i &lt;= n; ++i ) &#123;</span><br><span class="line">scanf(&quot;%lld&quot;, &amp;m);</span><br><span class="line">qz[i % 2] = qz[(i + 1) % 2] + m;</span><br><span class="line">mm[i % 2] = min(mm[(i + 1) % 2], qz[(i + 1) % 2]);</span><br><span class="line">ans = max(ans, qz[i % 2] - mm[i % 2]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写这道题还发现了或者说学到了或者说巩固了几个小知识</p><p>1) 取消cin的同步用这样的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::ios::sync_with_stdio(false);</span><br></pre></td></tr></table></figure><p>此为巩固</p><p>2) 使用scanf输入C++ 中long long 型的数<br>是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">long long int n;</span><br><span class="line">scanf(&quot;%lld&quot;, &amp;n);</span><br></pre></td></tr></table></figure><p>如果n的类型写为long long Dev会发出警告, 还不知道为什么</p><p>百度一下, 又网友说long long 就是long long int , 只是int省略掉了</p><p>3) 使用scanf要包含头文件cstdio</p><p>以前我是不包含的, 不过这次在洛谷上提交出现了编译错误, 这也算是发现了自己的一个小bug吧</p><p><strong><strong><strong>____</strong></strong></strong>2018-7-9补充更新<strong><strong><strong>____</strong></strong></strong></p><p>今天程序设计训练测试出了这道题, 时隔多月再次写这道入门DP, 发现实现方法略有不同.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int INF = 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int x;</span><br><span class="line">vector&lt;int&gt; v;</span><br><span class="line">while (cin &gt;&gt; x) &#123;</span><br><span class="line">v.push_back(x);</span><br><span class="line">&#125;</span><br><span class="line">int qz = 0, MAX = -INF;</span><br><span class="line">for (int i = 0; i &lt; v.size(); ++i) &#123;</span><br><span class="line">if (qz + v[i] &lt;= 0) qz = 0;</span><br><span class="line">else &#123;</span><br><span class="line">qz += v[i];</span><br><span class="line">MAX = max(MAX, qz);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; MAX;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初步数论-扩展欧几里得&amp;线性同余方程</title>
      <link href="/2018/01/04/chu-bu-shu-lun-kuo-zhan-ou-ji-li-de-xian-xing-tong-yu-fang-cheng/"/>
      <url>/2018/01/04/chu-bu-shu-lun-kuo-zhan-ou-ji-li-de-xian-xing-tong-yu-fang-cheng/</url>
      
        <content type="html"><![CDATA[<p>这篇博客我将介绍数论中的<strong>扩展欧几里得算法</strong>(extended Euclidean algorithm ),以及其在<strong>解线性同余方程(乘法逆元)</strong>中的运用.</p><p>首先要了解几个概念:<br>    <a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95/9002848?fr=aladdin" target="_blank" rel="noopener">欧几里得算法</a><br>    <a href="https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95/1053275?fr=aladdin" target="_blank" rel="noopener">扩展欧几里得算法</a><br>    <a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/5544515?fr=aladdin" target="_blank" rel="noopener">线性同余方程</a></p><p><strong>欧几里得算法</strong>是一种求解两个正整数a, b的最大公因子(一般记为gcd,gcd(a, b) )的方法,这个方法最早被记载在欧几里得的&lt;&lt;几何原本&gt;&gt;中.<br><strong>扩展欧几里得算法</strong>是在欧几里得算法的基础上扩展的一种算法.我们知道了 a 和 b 的最大公约数是 gcd ，那么，我们一定能够找到这样的 x 和 y ，使得: a<em>x + b</em>y = gcd 这是一个不定方程（一种丢番图方程）.扩展欧几里得算法就这求这样的x, y 的.<br><strong>线性同余方程</strong>是最基本的同余方程，“线性”表示方程的未知数次数是一次.它的表现形式是这样的:<br>    设x是未知整数, 形如<br>        ax ≡ b(mod m)<br>    的同余式称为一元线性同余方程.<br>    加下来我将介绍使用扩展欧几里得算法解b = 1时的同余方程, 未知数为 x ,x又称为a的乘法逆元.<br><strong>乘法逆元</strong>是当b = 1时的解 x , 可以这样理解:<br>    ax ≡ 1(mod m)<br>    我们称 x 是a关于m的乘法逆元</p><p>那么,从欧几里得算法开始.学习算法过程中,欧几里得算法大概是我接触到的第一个算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int gcd(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line">if( b==0 ) return a;</span><br><span class="line">else return gcd(b,a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数返回的是a, b的最大公约数,一般用gcd(a,b)来表示,数论中一般用(a,b)来表示a,b的最大公约数<br>由于此算法较为基础,在此不过多赘述.</p><p>但,需要了解的是,扩展欧几里算法就是在欧几里得算法的基础上加以扩展形成的.</p><p>我们首先要知道这样一个结论:<br>a 和 b 的最大公约数是 gcd ，那么，我们一定能够找到这样的 x 和 y ，使得: a<em>x + b</em>y = gcd(a,b)<br>扩展欧几里得算法的作用就是求这样的x, y的.它的解是无限的,我们可以这样表示它的通解:</p><pre><code>x = x0 + (b/gcd)*t;y = y0 - (a/gcd)*t;</code></pre><p>为什么不是：</p><pre><code>x = x0 + b*t;y = y0 - a*t;?</code></pre><p>我们要知道,这个通解中未知数的表达式的运算过程是互相抵消的.如:</p><pre><code>(b/gcd) *t *a - (a/gcd) *t *b = 0;</code></pre><p>而如果a, b不是互质的, 另一种形式那么会漏掉一些解.读者自己斟酌.(具体证明博主也不知如何是好)</p><p>如何求解呢?<br>只需要在欧几里德算法的基础上加点改动就行了。</p><p>  下面引自<a href="http://blog.csdn.net/zhjchengfeng5/article/details/7786595" target="_blank" rel="noopener"><em>一篇博客</em></a></p><blockquote><p> 我们观察到：欧几里德算法停止的状态是： a= gcd ， b = 0 ，那么，这是否能给我们求解 x y<br> 提供一种思路呢？因为，这时候，只要 a = gcd 的系数是 1 ，那么只要 b 的系数是 0 或者其他值（无所谓是多少，反正任何数乘以 0<br> 都等于 0 但是a 的系数一定要是 1），这时，我们就会有： a<em>1 + b</em>0 = gcd</p><p>  当然这是最终状态，但是我们是否可以从最终状态反推到最初的状态呢？</p><p>  假设当前我们要处理的是求出 a 和 b的最大公约数，并求出 x 和 y 使得 a<em>x + b</em>y= gcd ，而我们已经求出了下一个状态：b 和 a%b 的最大公约数，并且求出了一组x1 和y1 使得： b<em>x1 + (a%b)</em>y1 = gcd<br> ， 那么这两个相邻的状态之间是否存在一种关系呢？</p><p>  我们知道： a%b = a - (a/b)*b（这里的 “/” 指的是整除，例如 5/2=2 , 1/3=0），那么，我们可以进一步得到：</p><pre><code>gcd = b*x1 + (a-(a/b)*b)*y1    = b*x1 + a*y1 – (a/b)*b*y1    = a*y1 + b*(x1 – a/b*y1)</code></pre><p>  对比之前我们的状态：求一组 x 和 y 使得：a<em>x + b</em>y = gcd ，是否发现了什么？</p><p>  这里：</p><pre><code>x = y1y = x1 – a/b*y1</code></pre></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int ex_gcd( int a, int b, int &amp;x, int &amp;y )</span><br><span class="line">&#123;</span><br><span class="line">if( b==0 )&#123;</span><br><span class="line">x = 1, y = 0;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int ans = ex_gcd(b,a%b,x,y);</span><br><span class="line">int tmp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = tmp - a/b*y;</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欧几里得算法只能求a, b的最大公因数,而扩展欧几里得算法不仅可以求gcd(a,b),还可以求出a<em> x + b</em> y = gcd的通解只需在欧几里得算法的基础上稍加改动<br>然而,求通解有什么用呢?<br>我将介绍扩展欧几里得算法的一个应用,那就是前面提到过的解乘法逆元.</p><p>对于</p><pre><code>ax ≡ 1(mod m)</code></pre><p>我们称 x 是a关于m的乘法逆元<br>这和扩欧有什么关系呢?可以看到这个式子和a<em> x + b</em> y = gcd = 1是有些类似的<br>可以等价于这样的表达式： a<em> x + m</em> y = 1<br>a<em> x + b</em> y = gcd = 1, 说明a, b互质, 那么推广的式子a<em> x + m</em> y = 1中, a, m也是互质的<br>当gcd(a, m) != 1时,x是无解的.</p><p>乘法逆元式子中, 已知a, m, 那么就可以利用扩展欧几里得算法求解x了.<br>算法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int ex_gcd( int a, int b, int &amp;x, int &amp;y )</span><br><span class="line">&#123;</span><br><span class="line">if( b==0 )&#123;</span><br><span class="line">x = 1, y = 0;//递归到终止条件, 初始化x, y</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int ans = ex_gcd(b,a%b,x,y);//继续递归,此前不对x, y进行操作</span><br><span class="line">int temp = x;</span><br><span class="line">x = y;</span><br><span class="line">y = tmp - a/b*y;//利用推导出的两个相邻状态的代换式进行迭代</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main( )</span><br><span class="line">&#123;</span><br><span class="line">int a, b, x, y;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">if( ex_gcd(a,b,x,y)==1 )&#123;</span><br><span class="line">cout &lt;&lt; (x+b)%b; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意,在ex_gcd()中求得的x可能为负值,因此采用了　cout &lt;&lt; (x+b)%b; 这样的输出方式，输出ｘ最小的正整数解</p><p>到这里就结束了,我们讲了什么呢?</p><pre><code>欧几里得算法扩展欧几里得算法线性同余方程中一种特殊情况:乘法逆元 </code></pre><p>这是我在CSDN发表的的第一篇博客,有很多不足.如果没看懂的话,欢迎看这篇文章<br>    <a href="http://blog.csdn.net/zhjchengfeng5/article/details/7786595" target="_blank" rel="noopener">扩展欧几里德算法详解</a><br>    博主讲的很清楚, 对我启发很大.</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/01/04/hello-world/"/>
      <url>/2018/01/04/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="你好，世界！"><a href="#你好，世界！" class="headerlink" title="你好，世界！"></a>你好，世界！</h1><p>今天是本博客诞生的第一天，向世界问好！</p><p><code>hello, world!</code></p><h2 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello, world!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c"><a href="#c" class="headerlink" title="c"></a>c</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world!\n);</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'hello, world!\n'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
