<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>自编码器AutoEncoder</title>
      <link href="/2019/08/14/zi-bian-ma-qi-autoencoder/"/>
      <url>/2019/08/14/zi-bian-ma-qi-autoencoder/</url>
      
        <content type="html"><![CDATA[<h2 id="一-什么是自编码器"><a href="#一-什么是自编码器" class="headerlink" title="一. 什么是自编码器"></a>一. 什么是自编码器</h2><p>自动编码器 autoencoder, 简单表现编码器为将一组数据进行压缩编码(降维), 解码器将这组数据恢复成高维的数据. 这种编码和解码的过程不是无损的, 因此最终的输出和输入是有一些差异的, 且非常依赖于训练的数据集.</p><p>如图所示<br><img src="https://img-blog.csdnimg.cn/20190813221832515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>如上面这张图所示, 对于一个简单的三层线性神经网络组成的自编码器, 我们在进行神经网络的搭建过程中, 将(input, hidden) 这个过程叫做编码器, 将(hidden, output) 这个过程叫做解码器. 对于mnist数据集而言, 它的维度变化是 784 -&gt; x -&gt; 784, 其中, x &lt; 784, 是编码的维度.</p><hr><h2 id="二-有什么作用"><a href="#二-有什么作用" class="headerlink" title="二. 有什么作用"></a>二. 有什么作用</h2><h3 id="1-图像去噪"><a href="#1-图像去噪" class="headerlink" title="1) 图像去噪"></a>1) 图像去噪</h3><p>看上去很强啊<br><img src="https://img-blog.csdnimg.cn/20190813222525217.png" alt="在这里插入图片描述"></p><h3 id="2-可视化降维"><a href="#2-可视化降维" class="headerlink" title="2) 可视化降维"></a>2) 可视化降维</h3><hr><h2 id="三-如何实现"><a href="#三-如何实现" class="headerlink" title="三. 如何实现"></a>三. 如何实现</h2><p>训练神经网络需要定义损失函数, 那么这个自编码器的损失衡量值是什么? </p><p>衡量损失的值是由网络的输出结果和输入决定的. 也就是说, 是由这两个784维数据的差别决定的.</p><h3 id="1-全连接层实现"><a href="#1-全连接层实现" class="headerlink" title="1) 全连接层实现"></a>1) 全连接层实现</h3><p>首先定义一个神经网络</p><pre class=" language-py"><code class="language-py">class Autoencoder(nn.Module):    def __init__(self, encoding_dim):        super(Autoencoder, self).__init__()        ## encoder ##        self.encoder = nn.Linear(784, encoding_dim)        ## decoder ##        self.decoder = nn.Linear(encoding_dim, 784)    def forward(self, x):        # define feedforward behavior         # and scale the *output* layer with a sigmoid activation function#         print(x.shape)        x = x.view(-1, 784)        x = F.relu(self.encoder(x))        x = torch.sigmoid(self.decoder(x))        return x# initialize the NNencoding_dim = 128model = Autoencoder(encoding_dim)</code></pre><p>定义损失函数和优化器</p><pre class=" language-py"><code class="language-py"># specify loss functioncriterion = nn.MSELoss()# specify loss functionoptimizer = torch.optim.Adam(model.parameters(), lr=0.001)</code></pre><p>训练过程, 一共20个epochs, 话说pytorch还真慢, 这么简单的网络都要训练好一会</p><pre class=" language-py"><code class="language-py"># number of epochs to train the modeln_epochs = 20for epoch in range(1, n_epochs+1):    # monitor training loss    train_loss = 0.0    ###################    # train the model #    ###################    for data in train_loader:        # _ stands in for labels, here        images, _ = data        # flatten images        images = images.view(images.size(0), -1)        # clear the gradients of all optimized variables        optimizer.zero_grad()        # forward pass: compute predicted outputs by passing inputs to the model#         print(images.shape)        outputs = model(images)        # calculate the loss        loss = criterion(outputs, images)        # backward pass: compute gradient of the loss with respect to model parameters        loss.backward()        # perform a single optimization step (parameter update)        optimizer.step()        # update running training loss        train_loss += loss.item()*images.size(0)    # print avg training statistics     train_loss = train_loss/len(train_loader)    print('Epoch: {} \tTraining Loss: {:.6f}'.format(        epoch,         train_loss        ))</code></pre><p>训练过程的损失变化</p><pre class=" language-py"><code class="language-py">Epoch: 1     Training Loss: 0.342308Epoch: 2     Training Loss: 0.081272Epoch: 3     Training Loss: 0.058724Epoch: 4     Training Loss: 0.051274Epoch: 5     Training Loss: 0.047382Epoch: 6     Training Loss: 0.044760Epoch: 7     Training Loss: 0.043184Epoch: 8     Training Loss: 0.042066Epoch: 9     Training Loss: 0.041246Epoch: 10     Training Loss: 0.040589Epoch: 11     Training Loss: 0.040059Epoch: 12     Training Loss: 0.039646Epoch: 13     Training Loss: 0.039272Epoch: 14     Training Loss: 0.038980Epoch: 15     Training Loss: 0.038733Epoch: 16     Training Loss: 0.038524Epoch: 17     Training Loss: 0.038328Epoch: 18     Training Loss: 0.038162Epoch: 19     Training Loss: 0.038012Epoch: 20     Training Loss: 0.037874</code></pre><p>那么效果如何呢? 上面一排是输入图像, 下面一排是输出图像. 经过自编码器之后, 还原度还是很高的.</p><p><img src="https://img-blog.csdnimg.cn/2019081323064636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-测试-对有噪声图像的自编码"><a href="#2-测试-对有噪声图像的自编码" class="headerlink" title="2) 测试: 对有噪声图像的自编码"></a>2) 测试: 对有噪声图像的自编码</h3><p>首先查看一张图片</p><pre class=" language-py"><code class="language-py">a_img = np.squeeze(images[0])print(a_img.shape)print(np.max(a_img))print(np.min(a_img))plt.imshow(a_img, cmap='gray')</code></pre><p><img src="https://img-blog.csdnimg.cn/20190813232552587.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后向其中加入噪声</p><pre class=" language-py"><code class="language-py">a_img_x = a_img + 0.08 * np.random.normal(loc=0.0, scale=1.0, size=a_img.shape)plt.imshow(a_img_x, cmap='gray')</code></pre><p>这是加入噪声之后的图片, 可以看出差别还是很大的. 那么我们的编码器能还原出如何的效果呢?<br><img src="https://img-blog.csdnimg.cn/20190813232635605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><pre class=" language-py"><code class="language-py">a_img_output = model(torch.Tensor(a_img_x).view(1, -1))print(a_img_output.shape)output_img = a_img_output.view(28, 28)output_img = output_img.detach().numpy()plt.imshow(output_img, cmap='gray')</code></pre><p>这是还原后的, 说实话看到这个图片我心里也是很惊讶的. 就在于加入那么多噪声之后, 居然还可以还原的如此清晰. 当然这是对于MNIST数据集而言, 这个数据集比较简单.<br><img src="https://img-blog.csdnimg.cn/20190813232753783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-卷积层实现"><a href="#3-卷积层实现" class="headerlink" title="3) 卷积层实现"></a>3) 卷积层实现</h3><p>不同之处在于定义自编码器的神经网络结构<br>如图所示<br><img src="https://img-blog.csdnimg.cn/2019081323523769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到在decoder中经过了两个反卷积层, <del>但是由于水平有限, 这个反卷积层看着好奇怪, 不知道是怎么反卷积的. </del></p><p>pytorch实现</p><pre class=" language-py"><code class="language-py">import torch.nn as nnimport torch.nn.functional as F# define the NN architectureclass ConvAutoencoder(nn.Module):    def __init__(self):        super(ConvAutoencoder, self).__init__()        ## encoder layers ##        self.conv1 = nn.Conv2d(1, 16, 3, padding=1)        self.conv2 = nn.Conv2d(16, 4, 3, padding=1)        self.pool = nn.MaxPool2d(2, 2)                ## decoder layers ##        ## a kernel of 2 and a stride of 2 will increase the spatial dims by 2        self.t_conv1 = nn.ConvTranspose2d(4, 16, 2, stride=2)        self.t_conv2 = nn.ConvTranspose2d(16, 1, 2, stride=2)    def forward(self, x):        ## encode ##        ## decode ##        ## apply ReLu to all hidden layers *except for the output layer        ## apply a sigmoid to the output layer        x = F.relu(self.conv1(x))        x = self.pool(x)        x = F.relu(self.conv2(x))        x = self.pool(x)        x = F.relu(self.t_conv1(x))        x = torch.sigmoid(self.t_conv2(x))        return x# initialize the NNmodel = ConvAutoencoder()print(model)</code></pre><p>训练起来比全连接层的网络还要慢很多, 而损失值的降低也慢很多, 不像之前从epoch 1 到 epoch 2 直接就断崖式下跌了. 下面是损失值的变化过程, 只训练了 15个epoch. 从损失之上看这个效果好像差很多?</p><pre class=" language-py"><code class="language-py">Epoch: 1     Training Loss: 0.448799Epoch: 2     Training Loss: 0.266815Epoch: 3     Training Loss: 0.251290Epoch: 4     Training Loss: 0.240823Epoch: 5     Training Loss: 0.231836Epoch: 6     Training Loss: 0.220550Epoch: 7     Training Loss: 0.210341Epoch: 8     Training Loss: 0.202768Epoch: 9     Training Loss: 0.197010Epoch: 10     Training Loss: 0.193259Epoch: 11     Training Loss: 0.190589Epoch: 12     Training Loss: 0.188406Epoch: 13     Training Loss: 0.186529Epoch: 14     Training Loss: 0.184983Epoch: 15     Training Loss: 0.183579</code></pre><p>观察下图的数字9的话, 可以看到损失了不少.<br><img src="https://img-blog.csdnimg.cn/20190814000232600.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>再看看噪声图片的处理能力如何</strong></p><p>原图:<br><img src="https://img-blog.csdnimg.cn/20190814000948937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>加入噪声:<br><img src="https://img-blog.csdnimg.cn/20190814001018505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>经过自编码器<br><img src="https://img-blog.csdnimg.cn/20190814001040411.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>呃, 效果似乎有点不是很对, 可能是训练的epoch太少了, 毕竟我们可以前面看到训练15个epoch的损失值还是达到了0.18, 而在全连接层的简单自编码器上第二个epoch的损失值就达到了0.08</p><p>另一张图片</p><p><img src="https://img-blog.csdnimg.cn/20190814001258299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>噪声<br><img src="https://img-blog.csdnimg.cn/20190814001310217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190814002017372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dqaDI2MjIwNzUxMjc=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><hr><h2 id="四-一些小细节"><a href="#四-一些小细节" class="headerlink" title="四. 一些小细节"></a>四. 一些小细节</h2><ol><li><p>numpy 的 squeeze 函数<br><a href="https://blog.csdn.net/zenghaitao0128/article/details/78512715" target="_blank" rel="noopener">参考博客</a><br>作用：<strong>从数组的形状中删除单维度条目，即把shape中为1的维度去掉</strong></p></li><li><p>给MNIST图片加入噪声的方法</p><pre class=" language-py"><code class="language-py">test_img_x = test_img + 0.08 * np.random.normal(loc=0.0, scale=1.0, size=test_img.shape)</code></pre><p>就是加入一些随机值, 在原图的基础上进行小幅度修改.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hands-on-ml chapter2 笔记1</title>
      <link href="/2019/03/30/handson-ml-chp2/"/>
      <url>/2019/03/30/handson-ml-chp2/</url>
      
        <content type="html"><![CDATA[<p>批量学习（batch learning），一次性批量输入给学习算法，可以被形象的称为填鸭式学习。<br>在线学习（online learning），按照顺序，循序的学习，不断的去修正模型，进行优化。</p><p>batch learning 如果数据很大的话，可以使用MapReduce技术，或者使用online learning。</p><p>performance measure 使用RMSE（root mean square error），也就是均方根误差。看<a href="https://www.jianshu.com/p/9ee85fdad150" target="_blank" rel="noopener">https://www.jianshu.com/p/9ee85fdad150</a> 。学到了root 是根号的意思。</p><p>hypothesis ：假设<br>outlier ：异常值</p><p>有很多异常值（很大）的话，可能倾向于用MAE。</p><blockquote><p>RMSE 和 MAE 都是测量预测值和目标值两个向量距离的方法。有多种测量距离的方法，或范数：<br>计算对应欧几里得范数的平方和的根（RMSE）：这个距离介绍过。它也称作ℓ2范数，标记为 （或只是 ）。<br>计算对应于ℓ1（标记为 ）范数的绝对值和（MAE）。有时，也称其为曼哈顿范数，因为它测量了城市中的两点，沿着矩形的边行走的距离。<br>更一般的，包含n个元素的向量v的ℓk范数（K 阶闵氏范数），定义成</p></blockquote><blockquote><p>ℓ0（汉明范数）只显示了这个向量的基数（即，非零元素的个数），ℓ∞（切比雪夫范数）是向量中最大的绝对值。</p></blockquote><blockquote><p>范数的指数越高，就越关注大的值而忽略小的值。这就是为什么 RMSE 比 MAE 对异常值更敏感。但是当异常值是指数分布的（类似正态曲线），RMSE 就会表现很好。</p></blockquote><p>entry ：条目，entries<br>histogram ：统计直方图<br>histogram ：后端</p><p>数据可能经过预处理，这不一定会出错，但你得知道数据是怎么来的。</p><p>feature scaling ：特征缩放</p><p>如果右边的属性很长，会处理这些属性，使其变为正态分布。 </p><p>P49：生成随机排列以获得比较随机的train和test集划分。random seed控制结果。<br>P50：使用hash方法来生成稳定的train、test集，当得到新的数据时，原来的划分保持不变，新的实例同样进行划分。<br>调用的库是hashlib，可以稍微研究一下python中的hash方法。<br>增加一列索引index。<br>可以使用scikit learn提供的函数</p><p>P51：讲到要使用分层采样，因为不同层次的样本数量是不一样的，如果全都随机采样的话，误差会比较大。<br>strata：层<br>stratify：分层<br>使用sklearn提供的分层类，配合pandas的where等，分层正确可以获得较大的性能提升。<br>还可以查看分层比例。</p><p>pandas的where方法</p><blockquote><p>Series.where(cond, other=nan, inplace=False, axis=None, level=None, errors=‘raise’, try_cast=False, raise_on_error=None)<br>如果 cond 为真，保持原来的值，否则替换为other， inplace为真标识在原数据上操作，为False标识在原数据的copy上操作。</p></blockquote><p>insight：见解，洞察力<br>density：密度</p><p>分析数据，数据的可视化：可以得到数据之间的联系，哪些数据更有用，从而更加有技巧地进行训练；而且，从数据的可视化中，就可以得出一些只是看数据得不到的结论，图像能使信息暴露出来，所以matplotlib在机器学习中会有那么重要的作用，而看到的哪些讲机器学习的书、比赛的notebook，他们都有大量的数据可视化，这是呈现数据，探索数据的过程，也是：为什么此模型能够比其他人的模型更加强大的原因。但是数据分析有套路，要多看熟悉这些套路。</p><p>alpha参数的作用：它是一个设置透明度的参数。看到书上用它时，觉得没啥用啊，不是每个点都会设置一样的透明度吗？但是转念一想，存在透明度的话，点多的地方，颜色就会深，而点少的地方颜色就会浅。这就是透明度的作用啊！</p><p>correlation：相关；关联<br>median：中位数<br>coefficient：率；系数<br>correlation coefficient：相关系数</p><p>可以使用corr方法获取属性两两之间的（linear）相关性。（可以说是很强了！没想到居然还提供了这种方法。不过相关系数是怎么计算的？）<br>得到了相关性，然后呢？有什么作用吗？<br>书上说：想要移除掉相关性大的属性，避免重复。所谓数据清洗。</p><p>属性的结合，可能会获取更加有效的数据。</p><p>数据清洗：missing features<br>三种策略<br>sklearn提供了一种Imputer类来实现确实数据的填充</p><p>要设计自己的读取、划分数据函数，一种通用的方法，能够对不同的数据进行划分。</p><p>想到一个问题：如何将自己写的类，在python中import？就像numpy那样？但是numpy不是一个类而是一个包，那么如何制作自己的包？</p><p>interfeace：接口</p><p>P61讲述了sklearn的设计风格<br>评估器、转换器等的设计模式，统一性。</p><p>将文本属性转化成数字。标签编码。</p><p>sklearn.preprocessing </p><p>独热编码OneHotEncoder</p><p>sparse matrix：稀疏矩阵。书上一般说SciPy sparse matrix</p><p>text attribute -&gt; num -&gt; one hot; text -&gt; one hot; 可选scipy</p><p>设计自定义的transformers，三种method，fit，transform，fit_transform。<br>使用两个基类，提供一些功能。</p><p>feature scaling：特征缩放<br>normalization、standardization(less attected by outliers)<br>只能向数据集拟合：这样更准确。</p><p>pipelines class<br>数值属性和文本属性的特征可以分开设置pipeline，然后可以使用FeatureUnion来合并，真是方便！不过这个pipeline的设计有点麻烦。</p><p>选择模型、拟合、计算error。<br>underfitting and overfitting<br>cross validation：交叉验证。比较可靠的评估方式。<br>utility function：效用函数。越大越好<br>cost function：成本函数。越小越好</p><p>overfitting的可怕，还以为放出决策树回归出来会吊打线性回归呢，结果被吊打了，哈哈。</p><p>ensemble learning：集成学习。如random forests</p><p>把模型和训练结果保存下来，以便以后的对比。<br>可以使用pickle，或者sklearn.externals.joblib。<br>可以说是很方便了。</p><p>fine tune：微调</p><p>超参数：hyperparameter</p><blockquote><p>在机器学习的上下文中，超参数是在开始学习过程之前设置值的参数，而不是通过训练得到的参数数据。通常情况下，需要对超参数进行优化，给学习机选择一组最优超参数，以提高学习的性能和效果。<br>在机器学习的上下文中，超参数是在开始学习过程之前设置值的参数。 相反，其他参数的值通过训练得出。<br>超参数：<br>定义关于模型的更高层次的概念，如复杂性或学习能力。<br>不能直接从标准模型培训过程中的数据中学习，需要预先定义。<br>可以通过设置不同的值，训练不同的模型和选择更好的测试值来决定</p></blockquote><p>超参数的一些示例：</p><ul><li>树的数量或树的深度</li><li>矩阵分解中潜在因素的数量</li><li>学习率（多种模式）</li><li>深层神经网络隐藏层数</li><li>k均值聚类中的簇数</li></ul><p>amazing Grid Search！直译是网格搜索，但是显然不能这么理解。<br>这是sklearn提供的一种超级方便的选择hyperparameter的工具，简直是开挂啊。fine tune果然不赖。<br>还有一些分析的技巧。不过话说想要选好一组适合的超参数要训练好多组啊。<br>甚至直接获取the best estimator</p><p>Randomized Search 和 Gird相比，有几个有点。但目的和作用是一样的。</p><p>Ensemble Method 集成方法</p><p>分析最佳模型和他们的误差，可以获得更深的对问题的理解。比如可以给出每个属性对于做出准确预测的相对重要性，然后去掉某些属性，是否会使得分类更加准确。</p><p>maintain：维护</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>csapp datalab实验</title>
      <link href="/2019/03/29/csapp-datalab-shi-yan/"/>
      <url>/2019/03/29/csapp-datalab-shi-yan/</url>
      
        <content type="html"><![CDATA[<p>datalab 实验</p><p>代码如下</p><a id="more"></a><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*  * CS:APP Data Lab  *  * &lt;Please put your name and userid here> *  * bits.c - Source file with your solutions to the Lab. *          This is the file you will hand in to your instructor. * * WARNING: Do not include the &lt;stdio.h> header; it confuses the dlc * compiler. You can still use printf for debugging without including * &lt;stdio.h>, although you might get a compiler warning. In general, * it's not good practice to ignore compiler warnings, but in this * case it's OK.   */</span><span class="token macro property">#<span class="token directive keyword">if</span> 0</span><span class="token comment" spellcheck="true">/* * Instructions to Students: * * STEP 1: Read the following instructions carefully. */</span>You will provide your solution to the Data Lab byediting the collection of functions in <span class="token keyword">this</span> source file<span class="token punctuation">.</span>INTEGER CODING RULES<span class="token operator">:</span>  Replace the <span class="token string">"return"</span> statement in each function with one  <span class="token operator">or</span> more lines of C code that implements the function<span class="token punctuation">.</span> Your code   must conform to the following style<span class="token operator">:</span>  <span class="token keyword">int</span> <span class="token function">Funct</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">/* brief description of how your implementation works */</span>      <span class="token keyword">int</span> var1 <span class="token operator">=</span> Expr1<span class="token punctuation">;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      <span class="token keyword">int</span> varM <span class="token operator">=</span> ExprM<span class="token punctuation">;</span>      varJ <span class="token operator">=</span> ExprJ<span class="token punctuation">;</span>      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>      varN <span class="token operator">=</span> ExprN<span class="token punctuation">;</span>      <span class="token keyword">return</span> ExprR<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  Each <span class="token string">"Expr"</span> is an expression <span class="token keyword">using</span> ONLY the following<span class="token operator">:</span>  <span class="token number">1</span><span class="token punctuation">.</span> Integer constants <span class="token number">0</span> through <span class="token function">255</span> <span class="token punctuation">(</span><span class="token number">0xFF</span><span class="token punctuation">)</span><span class="token punctuation">,</span> inclusive<span class="token punctuation">.</span> You are      <span class="token operator">not</span> allowed to use big constants such as <span class="token number">0xffffffff</span><span class="token punctuation">.</span>  <span class="token number">2</span><span class="token punctuation">.</span> Function arguments <span class="token operator">and</span> local <span class="token function">variables</span> <span class="token punctuation">(</span>no global variables<span class="token punctuation">)</span><span class="token punctuation">.</span>  <span class="token number">3</span><span class="token punctuation">.</span> Unary integer operations <span class="token operator">!</span> <span class="token operator">~</span>  <span class="token number">4</span><span class="token punctuation">.</span> Binary integer operations <span class="token operator">&amp;</span> <span class="token operator">^</span> <span class="token operator">|</span> <span class="token operator">+</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">>></span>  Some of the problems restrict the set of allowed operators even further<span class="token punctuation">.</span>  Each <span class="token string">"Expr"</span> may consist of multiple operators<span class="token punctuation">.</span> You are <span class="token operator">not</span> restricted to  one <span class="token keyword">operator</span> per line<span class="token punctuation">.</span>  You are expressly forbidden to<span class="token operator">:</span>  <span class="token number">1</span><span class="token punctuation">.</span> Use any control constructs such as <span class="token keyword">if</span><span class="token punctuation">,</span> <span class="token keyword">do</span><span class="token punctuation">,</span> <span class="token keyword">while</span><span class="token punctuation">,</span> <span class="token keyword">for</span><span class="token punctuation">,</span> <span class="token keyword">switch</span><span class="token punctuation">,</span> etc<span class="token punctuation">.</span>  <span class="token number">2</span><span class="token punctuation">.</span> Define <span class="token operator">or</span> use any macros<span class="token punctuation">.</span>  <span class="token number">3</span><span class="token punctuation">.</span> Define any additional functions in <span class="token keyword">this</span> file<span class="token punctuation">.</span>  <span class="token number">4</span><span class="token punctuation">.</span> Call any functions<span class="token punctuation">.</span>  <span class="token number">5</span><span class="token punctuation">.</span> Use any other operations<span class="token punctuation">,</span> such as <span class="token operator">&amp;&amp;</span><span class="token punctuation">,</span> <span class="token operator">||</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">,</span> <span class="token operator">or</span> <span class="token operator">?</span><span class="token operator">:</span>  <span class="token number">6</span><span class="token punctuation">.</span> Use any form of casting<span class="token punctuation">.</span>  <span class="token number">7</span><span class="token punctuation">.</span> Use any data type other than <span class="token keyword">int</span><span class="token punctuation">.</span>  This implies that you     cannot use arrays<span class="token punctuation">,</span> structs<span class="token punctuation">,</span> <span class="token operator">or</span> unions<span class="token punctuation">.</span>  You may assume that your machine<span class="token operator">:</span>  <span class="token number">1</span><span class="token punctuation">.</span> Uses 2s complement<span class="token punctuation">,</span> <span class="token number">32</span><span class="token operator">-</span>bit representations of integers<span class="token punctuation">.</span>  <span class="token number">2</span><span class="token punctuation">.</span> Performs right shifts arithmetically<span class="token punctuation">.</span>  <span class="token number">3</span><span class="token punctuation">.</span> Has unpredictable behavior when shifting an integer by more     than the word size<span class="token punctuation">.</span>EXAMPLES OF ACCEPTABLE CODING STYLE<span class="token operator">:</span>  <span class="token comment" spellcheck="true">/*   * pow2plus1 - returns 2^x + 1, where 0 &lt;= x &lt;= 31   */</span>  <span class="token keyword">int</span> <span class="token function">pow2plus1</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/* exploit ability of shifts to compute powers of 2 */</span>     <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/*   * pow2plus4 - returns 2^x + 4, where 0 &lt;= x &lt;= 31   */</span>  <span class="token keyword">int</span> <span class="token function">pow2plus4</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/* exploit ability of shifts to compute powers of 2 */</span>     <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>     result <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> result<span class="token punctuation">;</span>  <span class="token punctuation">}</span>FLOATING POINT CODING RULESFor the problems that require you to implent floating<span class="token operator">-</span>point operations<span class="token punctuation">,</span>the coding rules are less strict<span class="token punctuation">.</span>  You are allowed to use looping <span class="token operator">and</span>conditional control<span class="token punctuation">.</span>  You are allowed to use both ints <span class="token operator">and</span> unsigneds<span class="token punctuation">.</span>You can use arbitrary integer <span class="token operator">and</span> <span class="token keyword">unsigned</span> constants<span class="token punctuation">.</span>You are expressly forbidden to<span class="token operator">:</span>  <span class="token number">1</span><span class="token punctuation">.</span> Define <span class="token operator">or</span> use any macros<span class="token punctuation">.</span>  <span class="token number">2</span><span class="token punctuation">.</span> Define any additional functions in <span class="token keyword">this</span> file<span class="token punctuation">.</span>  <span class="token number">3</span><span class="token punctuation">.</span> Call any functions<span class="token punctuation">.</span>  <span class="token number">4</span><span class="token punctuation">.</span> Use any form of casting<span class="token punctuation">.</span>  <span class="token number">5</span><span class="token punctuation">.</span> Use any data type other than <span class="token keyword">int</span> <span class="token operator">or</span> <span class="token keyword">unsigned</span><span class="token punctuation">.</span>  This means that you     cannot use arrays<span class="token punctuation">,</span> structs<span class="token punctuation">,</span> <span class="token operator">or</span> unions<span class="token punctuation">.</span>  <span class="token number">6</span><span class="token punctuation">.</span> Use any floating point data types<span class="token punctuation">,</span> operations<span class="token punctuation">,</span> <span class="token operator">or</span> constants<span class="token punctuation">.</span>NOTES<span class="token operator">:</span>  <span class="token number">1</span><span class="token punctuation">.</span> Use the <span class="token function">dlc</span> <span class="token punctuation">(</span>data lab checker<span class="token punctuation">)</span> <span class="token function">compiler</span> <span class="token punctuation">(</span>described in the handout<span class="token punctuation">)</span> to      check the legality of your solutions<span class="token punctuation">.</span>  <span class="token number">2</span><span class="token punctuation">.</span> Each function has a maximum number of <span class="token function">operators</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token operator">~</span> <span class="token operator">&amp;</span> <span class="token operator">^</span> <span class="token operator">|</span> <span class="token operator">+</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">>></span><span class="token punctuation">)</span>     that you are allowed to use <span class="token keyword">for</span> your implementation of the function<span class="token punctuation">.</span>      The max <span class="token keyword">operator</span> count is checked by dlc<span class="token punctuation">.</span> Note that <span class="token string">'='</span> is <span class="token operator">not</span>      counted<span class="token punctuation">;</span> you may use as many of these as you want without penalty<span class="token punctuation">.</span>  <span class="token number">3</span><span class="token punctuation">.</span> Use the btest test harness to check your functions <span class="token keyword">for</span> correctness<span class="token punctuation">.</span>  <span class="token number">4</span><span class="token punctuation">.</span> Use the BDD checker to formally verify your functions  <span class="token number">5</span><span class="token punctuation">.</span> The maximum number of ops <span class="token keyword">for</span> each function is given in the     header comment <span class="token keyword">for</span> each function<span class="token punctuation">.</span> If there are any inconsistencies      between the maximum ops in the writeup <span class="token operator">and</span> in <span class="token keyword">this</span> file<span class="token punctuation">,</span> consider     <span class="token keyword">this</span> file the authoritative source<span class="token punctuation">.</span><span class="token comment" spellcheck="true">/* * STEP 2: Modify the following functions according the coding rules. *  *   IMPORTANT. TO AVOID GRADING SURPRISES: *   1. Use the dlc compiler to check that your solutions conform *      to the coding rules. *   2. Use the BDD checker to formally verify that your solutions produce  *      the correct answers. */</span><span class="token macro property">#<span class="token directive keyword">endif</span></span><span class="token comment" spellcheck="true">/*  * bitAnd - x&amp;y using only ~ and |  *   Example: bitAnd(6, 5) = 4 *   Legal ops: ~ | *   Max ops: 8 *   Rating: 1 */</span><span class="token keyword">int</span> <span class="token function">bitAnd</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">~</span>x<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token operator">~</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*  * getByte - Extract byte n from word x *   Bytes numbered from 0 (LSB) to 3 (MSB) *   Examples: getByte(0x12345678,1) = 0x56 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 6 *   Rating: 2 */</span> <span class="token keyword">int</span> <span class="token function">getByte</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">~</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">24</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> tmp<span class="token operator">&amp;</span><span class="token number">0x000000ff</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*????Byte???????????????????24????????????????????n????????????????(3 - n = 3 + ~n + 1) &lt;&lt; 3????????*/</span><span class="token comment" spellcheck="true">/*  * logicalShift - shift x to the right by n, using a logical shift *   Can assume that 0 &lt;= n &lt;= 31 *   Examples: logicalShift(0x87654321,4) = 0x08765432 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 20 *   Rating: 3  */</span><span class="token keyword">int</span> <span class="token function">logicalShift</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0x1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span>n<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> n<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>t <span class="token operator">>></span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token operator">~</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*??????????????????????1???????n = 0?????????????????*/</span><span class="token comment" spellcheck="true">/* * bitCount - returns count of number of 1's in word *   Examples: bitCount(5) = 2, bitCount(7) = 3 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 40 *   Rating: 4 */</span><span class="token keyword">int</span> <span class="token function">bitCount</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ??????????????2?4?8?16?32?01??1???? </span>    <span class="token keyword">int</span> bitcount<span class="token punctuation">;</span>    <span class="token keyword">int</span> tmp1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0x55</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">0x55</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mask1 <span class="token operator">=</span> <span class="token punctuation">(</span>tmp1<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>tmp1<span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//????? 01010101��01010101</span>    <span class="token keyword">int</span> tmp2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0x33</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">0x33</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mask2 <span class="token operator">=</span> <span class="token punctuation">(</span>tmp2<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>tmp2<span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//????? 00110011��00110011</span>    <span class="token keyword">int</span> tmp3 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0x0f</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">0x0f</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mask3 <span class="token operator">=</span> <span class="token punctuation">(</span>tmp3<span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>tmp3<span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//????? 00001111��00001111</span>    <span class="token keyword">int</span> mask4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0xff</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">0xff</span><span class="token operator">&lt;&lt;</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//????? 0000 0000 1111 1111 0000 0000 1111 1111</span>    <span class="token keyword">int</span> mask5 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0xff</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span><span class="token number">0xff</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//????? 0000 0000 0000 0000 1111 1111 1111 1111</span>    bitcount <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">&amp;</span> mask1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> mask1<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//??????2??????1??????????2??????1???????? </span>    bitcount <span class="token operator">=</span> <span class="token punctuation">(</span>bitcount <span class="token operator">&amp;</span> mask2<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bitcount <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> mask2<span class="token punctuation">)</span><span class="token punctuation">;</span>    bitcount <span class="token operator">=</span> <span class="token punctuation">(</span>bitcount <span class="token operator">+</span> <span class="token punctuation">(</span>bitcount <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> mask3<span class="token punctuation">;</span>    bitcount <span class="token operator">=</span> <span class="token punctuation">(</span>bitcount <span class="token operator">+</span> <span class="token punctuation">(</span>bitcount <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> mask4<span class="token punctuation">;</span>    bitcount <span class="token operator">=</span> <span class="token punctuation">(</span>bitcount <span class="token operator">+</span> <span class="token punctuation">(</span>bitcount <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> mask5<span class="token punctuation">;</span>    <span class="token keyword">return</span> bitcount<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*  * bang - Compute !x without using ! *   Examples: bang(3) = 0, bang(0) = 1 *   Legal ops: ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 12 *   Rating: 4  */</span><span class="token keyword">int</span> <span class="token function">bang</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>t <span class="token operator">|</span> x<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//??0??+1????0?????x?0?????31???0?+1?????1. ????????????????????????????????31??????-1?+1?????0.</span><span class="token comment" spellcheck="true">/*  * tmin - return minimum two's complement integer  *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 4 *   Rating: 1 */</span><span class="token keyword">int</span> <span class="token function">tmin</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ???????????1????31??????????????????</span><span class="token comment" spellcheck="true">/*  * fitsBits - return 1 if x can be represented as an  *  n-bit, two's complement integer. *   1 &lt;= n &lt;= 32 *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 15 *   Rating: 2 */</span><span class="token keyword">int</span> <span class="token function">fitsBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// x????n???? ??32-n????32-n????????? </span>    <span class="token keyword">int</span> shift <span class="token operator">=</span> <span class="token number">32</span> <span class="token operator">+</span> <span class="token operator">~</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> t <span class="token operator">=</span> x <span class="token operator">&lt;&lt;</span> shift <span class="token operator">>></span> shift<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>t <span class="token operator">^</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// x?????n???? ??32-n????32-n????????????????</span><span class="token comment" spellcheck="true">/*  * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30 *  Round toward zero *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 15 *   Rating: 2 */</span><span class="token keyword">int</span> <span class="token function">divpwr2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ?????????????????????????????????????-5/2 = -3??? </span>    <span class="token keyword">int</span> sign <span class="token operator">=</span> x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ?? </span><span class="token comment" spellcheck="true">//    cout &lt;&lt; (1 &lt;&lt; n) + ~0 &lt;&lt; endl; </span><span class="token comment" spellcheck="true">//    cout &lt;&lt; "(sign &amp; ((1 &lt;&lt; n) + ~0)) = " &lt;&lt; (sign &amp; ((1 &lt;&lt; n) + ~0)) &lt;&lt; endl;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token punctuation">(</span>sign <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token operator">~</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">>></span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ???????0???????????????????-5/2 = -3???????0????????????????????????????????????</span><span class="token comment" spellcheck="true">/*  * negate - return -x  *   Example: negate(1) = -1. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 5 *   Rating: 2 */</span><span class="token keyword">int</span> <span class="token function">negate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ?????????+1.</span><span class="token comment" spellcheck="true">/*  * isPositive - return 1 if x > 0, return 0 otherwise  *   Example: isPositive(-1) = 0. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 8 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">isPositive</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ????????????0</span> <span class="token comment" spellcheck="true">// ????????????????</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ????????????0</span><span class="token comment" spellcheck="true">/*  * isLessOrEqual - if x &lt;= y  then return 1, else return 0  *   Example: isLessOrEqual(4,5) = 1. *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 24 *   Rating: 3 */</span><span class="token keyword">int</span> <span class="token function">isLessOrEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ??????????</span><span class="token keyword">int</span> xl <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> yl <span class="token operator">=</span> <span class="token punctuation">(</span>y <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> zl <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>xl <span class="token operator">^</span> yl<span class="token punctuation">)</span> <span class="token operator">&amp;</span> xl<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>xl <span class="token operator">^</span> yl<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>zl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ??????????????isPositive?????????????????????</span><span class="token comment" spellcheck="true">// ???????????????x&lt;0?y>=0,????????1???????????y-x???????0???x????y?</span><span class="token comment" spellcheck="true">/* * ilog2 - return floor(log base 2 of x), where x > 0 *   Example: ilog2(16) = 4 *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; >> *   Max ops: 90 *   Rating: 4 */</span><span class="token keyword">int</span> <span class="token function">ilog2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ???????1???+?????&lt;&lt;????????? </span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>    id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    id <span class="token operator">=</span> id <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token punctuation">(</span>id <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    id <span class="token operator">=</span> id <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token punctuation">(</span>id <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    id <span class="token operator">=</span> id <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token punctuation">(</span>id <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    id <span class="token operator">=</span> id <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token punctuation">(</span>id <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> id<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ??????log2?log2n?????????1???????????????1???????16?????????????????id??????id???????+?????&lt;&lt;????????? </span><span class="token comment" spellcheck="true">/*  * float_neg - Return bit-level equivalent of expression -f for *   floating point argument f. *   Both the argument and result are passed as unsigned int's, but *   they are to be interpreted as the bit-level representations of *   single-precision floating point values. *   When argument is NaN, return argument. *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 10 *   Rating: 2 */</span><span class="token keyword">unsigned</span> <span class="token function">float_neg</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> tmp <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>tmp <span class="token operator">&amp;</span> <span class="token number">0xFF000000</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0xFF000000</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tmp <span class="token operator">!=</span> <span class="token number">0xFF000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> uf<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>uf <span class="token operator">+</span> <span class="token number">0x80000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 1????????NAN??????????NAN</span><span class="token comment" spellcheck="true">// 2?????????????????????????????????????????????????+1??????????????</span><span class="token comment" spellcheck="true">/*  * float_i2f - Return bit-level equivalent of expression (float) x *   Result is returned as unsigned int, but *   it is to be interpreted as the bit-level representation of a *   single-precision floating point values. *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="token keyword">unsigned</span> <span class="token function">float_i2f</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ????????????????????????????? </span>    <span class="token keyword">int</span> sign<span class="token punctuation">,</span> id<span class="token punctuation">,</span> shr<span class="token punctuation">,</span> mid<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> tmp<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    sign <span class="token operator">=</span> x <span class="token operator">&amp;</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sign<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>    id <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    tmp <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmp <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>        id<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// x = 5, id = 2, ??????1?? </span>    <span class="token punctuation">}</span>    tmp <span class="token operator">=</span> x <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">32</span> <span class="token operator">-</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 23???????? </span>    shr <span class="token operator">=</span> <span class="token punctuation">(</span>tmp <span class="token operator">&amp;</span> <span class="token number">0x1ff</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ???? </span>    tmp <span class="token operator">=</span> tmp <span class="token operator">>></span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ?????</span>    mid <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">127</span> <span class="token operator">+</span> id<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ???</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>shr <span class="token operator">></span> <span class="token number">128</span> <span class="token operator">||</span> <span class="token punctuation">(</span>shr <span class="token operator">==</span> <span class="token number">128</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>tmp <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        tmp <span class="token operator">=</span> tmp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>tmp <span class="token operator">+</span> mid <span class="token operator">+</span> sign<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*  * float_twice - Return bit-level equivalent of expression 2*f for *   floating point argument f. *   Both the argument and result are passed as unsigned int's, but *   they are to be interfrpreted as the bit-level representation of *   single-precision floating point values. *   When argument is NaN, return argument *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while *   Max ops: 30 *   Rating: 4 */</span><span class="token keyword">unsigned</span> <span class="token function">float_twice</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> s <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> e <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7f800000</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> m <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x007fffff</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token number">0x7f800000</span><span class="token punctuation">)</span> <span class="token keyword">return</span> uf<span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> s <span class="token operator">+</span> <span class="token punctuation">(</span>m <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>  ans <span class="token operator">=</span> s <span class="token operator">+</span> e <span class="token operator">+</span> <span class="token number">0x00800000</span> <span class="token operator">+</span> m<span class="token punctuation">;</span>  <span class="token keyword">return</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ????????????M??????????</span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编与gdb调试学习</title>
      <link href="/2019/03/09/hui-bian-yu-gdb-diao-shi-xue-xi/"/>
      <url>/2019/03/09/hui-bian-yu-gdb-diao-shi-xue-xi/</url>
      
        <content type="html"><![CDATA[<h4 id="1、在gdb中如何列出汇编代码"><a href="#1、在gdb中如何列出汇编代码" class="headerlink" title="1、在gdb中如何列出汇编代码"></a>1、在gdb中如何列出汇编代码</h4><p>应该是不可以用list 命令列出汇编代码的。<br>但可以使用<code>display /i $pc</code> 命令在调试的时候出了列出一行源码，也列出相应的汇编代码<br>同时，s和si等的区别还是比较大的：si按汇编一行一行执行，有的源码一行会有很多条汇编；<br>我认为这是个学习汇编的好方法：<strong>使用gdb一步一步调试，对比汇编和源码</strong></p><h4 id="2、如何将一个可执行文件或者是-o文件得到它的汇编码或者是源码？"><a href="#2、如何将一个可执行文件或者是-o文件得到它的汇编码或者是源码？" class="headerlink" title="2、如何将一个可执行文件或者是.o文件得到它的汇编码或者是源码？"></a>2、如何将一个可执行文件或者是.o文件得到它的汇编码或者是源码？</h4><p>可以使用<code>objdump -d test.out</code> 获取汇编代码（右侧）以及机器码（左侧）；要查看但里面有很多除我写的东西之外的东西，要具体定位到自己写的东西，可根据函数名查看。</p><p>如果编译时<strong>使用了-g参数</strong>的话，使用<code>objdump -dS test</code> 就可以得到机器码，源码，汇编码一一对应了！但如果没用-g的话，可执行文件是没有源码信息的，这时需要通过特殊手段得到。</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0wz27sv1rj30s60gwjy7.jpg" alt="在这里插入图片描述"></p><h4 id="3、将c源码变成-o文件，会不会很干净，和变成可执行文件的区别？体量？"><a href="#3、将c源码变成-o文件，会不会很干净，和变成可执行文件的区别？体量？" class="headerlink" title="3、将c源码变成.o文件，会不会很干净，和变成可执行文件的区别？体量？"></a>3、将c源码变成.o文件，会不会很干净，和变成可执行文件的区别？体量？</h4><p>编译过程图，来源：<a href="https://blog.csdn.net/misskissC/article/details/38020151" target="_blank" rel="noopener">https://blog.csdn.net/misskissC/article/details/38020151</a><br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0wz3cnv22j30dk07874k.jpg" alt="在这里插入图片描述"><br>和期待的相符，没有目标文件的链接过程，.o 文件果然很干净，使用-d命令查看的话，可以只看我自己写的代码部分！但是没有 -g 的话没有源码。<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0wz3qgssaj30uu0t3dpz.jpg" alt="在这里插入图片描述"><br>同样和期待的相符，加了-g之后，成功出现源码<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz49e2xnj30r30oyq8r.jpg" alt="在这里插入图片描述"></p><h4 id="4、c代码变成-s文件，如何精确捕捉到我写的函数的内容？"><a href="#4、c代码变成-s文件，如何精确捕捉到我写的函数的内容？" class="headerlink" title="4、c代码变成.s文件，如何精确捕捉到我写的函数的内容？"></a>4、c代码变成.s文件，如何精确捕捉到我写的函数的内容？</h4><p>额，我发现.s 文件还是非常干净的，没有什么特别多的其他文件，想要找哪个函数，前面都有名字的。 尝试是由-g会有什么区别码？<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz4p1qm5j30hd0kt41y.jpg" alt="在这里插入图片描述"><br>加了-g 参数后，生成的.s 文件果然多了很多不认识的东西，仔细找了下后，发现并没有看到源码的字符串，可能是以某种特殊的方式编码了？如图是对比，左侧是加了 -g的，而右侧是没有加的。<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0wz509prej31el0k5wmu.jpg" alt="在这里插入图片描述"><br>我们来验证以下，这个加了-g的.s文件，是否真的是包含了我源码的信息？</p><p>验证通过，确实有，哈哈<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz5i91ybj30nn0scq9h.jpg" alt="在这里插入图片描述"></p><h4 id="5、各种情况的编译失败是在编译的过程是哪一步？"><a href="#5、各种情况的编译失败是在编译的过程是哪一步？" class="headerlink" title="5、各种情况的编译失败是在编译的过程是哪一步？"></a>5、各种情况的编译失败是在编译的过程是哪一步？</h4><p>在编译c语言的时候，通常是一步全编译，我们来尝试分部编译，探究不同错误的编译失败地点。<br>1、如果我只是写一个函数而没有main函数，可以进行到哪一步？<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz5u0tlsj30er05s3yw.jpg" alt="在这里插入图片描述"><br>编译成汇编代码居然就报错了！预处理的话还是可以的<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0wzcl23cbj30vx05176q.jpg" alt="在这里插入图片描述"></p><p>2、不小心没写分号 ;<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz6h56eaj30pi09kq3z.jpg" alt="在这里插入图片描述"><br>额，看来还是这个源码变成汇编的过程过程<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz6uqm52j30mu03kabl.jpg" alt="在这里插入图片描述"><br>我突然想到，整个编译的大过程分为<code>预处理-&gt;编译-&gt;汇编-&gt;链接</code>，那么可能语法问题之类的都是在<code>编译</code>这个小过程被发现的吧。</p><h4 id="6、list命令用法"><a href="#6、list命令用法" class="headerlink" title="6、list命令用法"></a>6、list命令用法</h4><p>默认显示10行，可使用<code>list 1,1000</code> 来获取更多行的代码<br>使用<code>list +/-</code> 用以继续，和查看更前的源码<br><code>set listsize 20</code> 设置显示行数<br><code>show listsize</code> 查看显示行数</p><h4 id="7、删除断点：d-b"><a href="#7、删除断点：d-b" class="headerlink" title="7、删除断点：d b"></a>7、删除断点：<code>d b</code></h4><p>查看断点：<br><code>info b</code><br><code>info watch</code></p><hr><p>查表<br><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0wz788t0zj30u30gtjsb.jpg" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> 汇编 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/03/09/hello-world/"/>
      <url>/2019/03/09/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="你好，世界！"><a href="#你好，世界！" class="headerlink" title="你好，世界！"></a>你好，世界！</h1><p>今天是本博客诞生的第一天，向世界问好！</p><p><code>hello, world!</code></p><h2 id="cpp"><a href="#cpp" class="headerlink" title="cpp"></a>cpp</h2><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello, world!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="c"><a href="#c" class="headerlink" title="c"></a>c</h2><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span>"hello<span class="token punctuation">,</span> world<span class="token operator">!</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><pre class=" language-py"><code class="language-py">print('hello, world!\n')</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数组中出现次数超过一半的数字</title>
      <link href="/2018/09/23/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi/"/>
      <url>/2018/09/23/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi/</url>
      
        <content type="html"><![CDATA[<p>用头脑风暴学算法，对于一个问题，我们不只是要解决它，还要去思考有什么好的方法，差的方法去解决，甚至是一些错误的但可以提供思想借鉴的方法。</p><p>此问题“数组中出现次数超过一半的数字”是一道非常经典的算法题，我把它放在算法风暴系列第一篇来解析，探讨学习一个算法的过程，从慢到快，从最直观的方法到脑洞大开的方法，由表面深入本质。</p><hr><p><a href="https://blog.csdn.net/wjh2622075127/article/details/82830683" target="_blank" rel="noopener">下一篇：算法风暴之二—最小的k个数</a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p><strong>给定一个数组，且已知数组中有一个数出现次数超过一半（严格），请求出这个数。</strong></p><p>问题很简单，方法也多样，但什么方法是最好的呢？为什么它最好？各种方法之间有什么优缺点？下面我们一一展开。</p><hr><h2 id="方法一：给数组排序"><a href="#方法一：给数组排序" class="headerlink" title="方法一：给数组排序"></a>方法一：给数组排序</h2><p>这大概是最直观的方法了，最容易想到，也是最多人能够想出来的。如果我们使用快排的话，只需要<code>O(nlogn)</code>的时间就可以找到这个数。</p><p>那么思考这样一个问题：给数组排序了，然后怎么找这个数呢？有两种方法</p><p>1、从小到大遍历已排序数组，同时统计每个数出现的次数（某个数和上一个数不同则计数置为1），如果出现某个计数超过一半，那么正在计数的数就是所求数。</p><p>PS：这种方法可行，相比于快排的时间复杂度是可以忽略的，但是我们还有更好的方法，直击本质。</p><p>2、对一个已排好序的序列，出现次数超过一半的数必定是中位数。因此，我们只要输出中位数即可。</p><p>复杂度分析：<br>| <strong>时间复杂度</strong> |  <strong>O(nlogn)</strong> |<br>|–|–|<br>| <strong>空间复杂度</strong> | <strong>O(n)</strong> |</p><p>手写快排代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ctime></span></span><span class="token macro property">#<span class="token directive keyword">define</span> RAND(start, end) start+(int)(end-start+1)*rand()/(RAND_MAX+1);</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">10005</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> start<span class="token punctuation">;</span>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">RAND</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> one <span class="token operator">=</span> start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> start<span class="token punctuation">;</span> index <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">++</span>one<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>one <span class="token operator">!=</span> index<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>one<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span>one<span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>one<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> one<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">QuickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> length<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">></span> start<span class="token punctuation">)</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> length<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">&lt;</span> end<span class="token punctuation">)</span>        <span class="token function">QuickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> length<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> data<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">QuickSort</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> data<span class="token punctuation">[</span>n <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="方法二：桶排序计数"><a href="#方法二：桶排序计数" class="headerlink" title="方法二：桶排序计数"></a>方法二：桶排序计数</h2><p>如果我们需要统计的数组元素都是正整数呢？那么我们就可以使用桶排序，给他们计数，然后超过数组大小一半的就是结果了。</p><p>然而桶排序看上去很简单，“复杂度也不高”，却有很多的限制。</p><p>1、首先，数组统计的数需得是可hash的，不然无法将他们在hash数组上计数。但是某些情况，如元素有负值，可进行灵活转化，使其可hash。<br>2、其次，桶排序方法空间换时间，需要消耗额外的空间，取决于数据的范围。<br>3、桶排序并非真的那么快。桶排序的时间复杂度并非是普通的<code>O(n)</code>, 它的n指的是最大数据范围，如果有这样一组数据<code>1 100 10000 1000000</code>，那么桶排序将会有至少1000000次循环，且开出1e6的空间，大大浪费资源。</p><p>桶排序方法适合数据范围不大，且数据密度较大的数据。非也，则在此问题上算不上好方法。</p><p>代码</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> max_size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        max_size <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>max_size<span class="token punctuation">,</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token operator">*</span>hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>max_size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max_size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        hash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        hash<span class="token punctuation">[</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> max_size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hash<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> n <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> i<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> hash<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="方法三：巧用栈"><a href="#方法三：巧用栈" class="headerlink" title="方法三：巧用栈"></a>方法三：巧用栈</h2><p>其实我们可以发现，上面的方法一和方法二，固然是这道题的解法之一，但<strong>不是非常具有针对性</strong>。也就是说，那两种方法是<strong>功能过剩的</strong>，而这所谓功能过剩，也正是导致它性能不是最佳的原因。</p><p><strong>那么，我们就应该思考某种算法，只针对这个问题，完全的利用好效率。那么就要从题目出发，找蕴含在问题中的本质规律了。</strong></p><p>其实这个问题的核心就是：<strong>出现次数超过一半</strong>。</p><p>我们做这样的思考：</p><p>假设k就是我们要求的那个数，那么对这个数组，删掉其中任意两个数所剩下的数组，其对应的k值会改变吗？答案是会的。<strong>但是，如果删掉任意两个不相同的数呢？答案是不会！</strong> 为什么不会？相信聪明的读者瞬间就明白原因，只需进行简单的推导就可以了。</p><p>具体的实现过程就是：<strong>每遍历一个数，就将其入栈，同时查询它和栈内前一个元素的大小，如果不同，就同时出栈，否则不变。</strong></p><p>以上，就是用栈的方法解决这个问题的核心。</p><table><thead><tr><th>时间复杂度</th><th>O(n)</th></tr></thead><tbody><tr><td><strong>空间复杂度</strong></td><td><strong>O(n)</strong></td></tr></tbody></table><p>栈实现代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> top <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        stack<span class="token punctuation">[</span><span class="token operator">++</span>top<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>top <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span> <span class="token operator">!=</span> stack<span class="token punctuation">[</span>top <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> top <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> stack<span class="token punctuation">[</span>top<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> data<span class="token punctuation">;</span>    <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> stack<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="方法四：找中位数（第n-2大数）"><a href="#方法四：找中位数（第n-2大数）" class="headerlink" title="方法四：找中位数（第n/2大数）"></a>方法四：找中位数（第n/2大数）</h2><p>从方法一的分析中我们知道，这个数组的中位数就是答案。方法一是通过给所有的数进行排序找出这个中位数，而我们思考，排序是否有些大材小用？找这个中位数的方法是否可以更简单些？</p><p>答案是有的，而且这类问题被称为<strong>找第k个数</strong>。</p><p><strong>思想是快排的思想。时间复杂度为<code>O(n)</code></strong></p><p>利用快排思想，我们可以找出第n/2大的数，同时在第n/2th数左边的数都小于它，右边的数都大于它。这个数就是数组的中位数。</p><p>快速排序简称快排，利用分治的思想，在数组中随机选择一个数，然后以这个数为基准，把大于它的数划分到它的右侧，小于它的数划分到它的左侧，并且递归的分别对左右两侧数据进行处理，直到所有的区间都按照这样的规律划分好。</p><p>那么在这个问题中，如何利用快排的方法呢？<strong>快排是对每一个区间进行分治处理，而此问题不必，我们只要找到第n/2小的数。每次随机划分得的第m个数，如果m &lt; n/2, 那么对[m + 1, n - 1]这个区间继续递归；如果m &gt; n/2，那么对[0, m - 1]这个区间进行递归；如果刚好有m = n/2，那么函数结束，区间[0, n/2 - 1]的数就是最小的n/2个数。</strong></p><p>此算法的平均时间复杂度为O(n), 快速排序的详细证明可参考“算法导论”。</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;ctime></span></span><span class="token macro property">#<span class="token directive keyword">define</span> RAND(start, end) start + (int)(end - start + 1)*(rand()/(RAND_MAX + 1))</span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">Partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>start <span class="token operator">==</span> end<span class="token punctuation">)</span> <span class="token keyword">return</span> start<span class="token punctuation">;</span>    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">RAND</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> one <span class="token operator">=</span> start <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token operator">=</span> start<span class="token punctuation">;</span> index <span class="token operator">&lt;</span> end<span class="token punctuation">;</span> <span class="token operator">++</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token operator">++</span>one<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>one <span class="token operator">!=</span> index<span class="token punctuation">)</span> <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>one<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">++</span>one<span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>one<span class="token punctuation">]</span><span class="token punctuation">,</span> data<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> one<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">FindIt</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token function">Partition</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> length<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">==</span> length <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">></span> length <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">FindIt</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> length<span class="token punctuation">,</span> start<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token function">FindIt</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> length<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cin <span class="token operator">>></span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">FindIt</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> data<span class="token punctuation">[</span>n <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><a href="https://blog.csdn.net/wjh2622075127/article/details/82830683" target="_blank" rel="noopener">下一篇：算法风暴之二—最小的k个数</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现简单分类器</title>
      <link href="/2018/09/21/python-shi-xian-jian-dan-fen-lei-qi/"/>
      <url>/2018/09/21/python-shi-xian-jian-dan-fen-lei-qi/</url>
      
        <content type="html"><![CDATA[<p>今天重新开始学习机器学习，训练了一个简单的分类器。</p><p>如何工作的呢？给定一组训练数据，他们的参数有三个，x轴坐标，y轴坐标，类别。即<code>(x, y, c)</code>。如图所示<br><img src="/images/20180921_1.png" alt><br>红色的圆点代表第一类点，类别编号为1；蓝色的倒三角形代表第二类点，类别编号为0.</p><p>我们的目的，是根据这些训练数据，拟合出一条边界线，来将两种类别的数据划分开来，这个系统就叫做分类器。鉴于笔者水平尚浅，故暂时只能训练从原点出发的线性分类器。</p><p>下面就讨论这个简单分类器的具体实现，对于入门者来说，其实也可以学到不少东西。</p><hr><h2 id="第一步，导入我们需要的python库"><a href="#第一步，导入我们需要的python库" class="headerlink" title="第一步，导入我们需要的python库"></a>第一步，导入我们需要的python库</h2><p>在这份代码中，我用到了<code>numpy</code>库和<code>matplotlib</code>库，并且在<code>jupyter notebook</code>中实现了内置<code>matplotlib</code>。</p><pre><code>%matplotlib inlineimport matplotlib.pyplot as pltimport numpy as np</code></pre><h2 id="第二步，获取训练数据并解析坐标"><a href="#第二步，获取训练数据并解析坐标" class="headerlink" title="第二步，获取训练数据并解析坐标"></a>第二步，获取训练数据并解析坐标</h2><p>我们的输入格式是这样的：</p><blockquote><p>1.0 3.0 1,<br>3.0 1.0 0,<br>2.0 2.0 1,<br>4.0 1.0 0,<br>2.0 4.0 1,<br>4.5 1.0 0,<br>3.0 2.5 1,<br>5.0 2.0 0</p></blockquote><p>每行代表一个坐标的信息，分别是横坐标，纵坐标，类别。每组数据间用<code>,</code> 分隔，因此可以很简单的用<code>split</code>函数将数据划分。具体到每个坐标的信息，我们可以利用<code>numpy</code>的<code>fromstring</code>函数获取一个字符串信息，并把他们转化为<code>float</code>类型。</p><pre class=" language-python"><code class="language-python">get <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"请输入训练数据，第三个参数为类别"</span><span class="token punctuation">)</span>get <span class="token operator">=</span> get<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>train_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>x1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>y1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>x0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>y0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> each <span class="token keyword">in</span> get<span class="token punctuation">:</span>    train_data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>fromstring<span class="token punctuation">(</span>each<span class="token punctuation">,</span> dtype<span class="token operator">=</span>float<span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> each <span class="token keyword">in</span> train_data<span class="token punctuation">:</span>    <span class="token keyword">if</span> each<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        x1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>each<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        y1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>each<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        x0<span class="token punctuation">.</span>append<span class="token punctuation">(</span>each<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        y0<span class="token punctuation">.</span>append<span class="token punctuation">(</span>each<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h2 id="第三步，随机化数据"><a href="#第三步，随机化数据" class="headerlink" title="第三步，随机化数据"></a>第三步，随机化数据</h2><p>为了使我们的数据更加准确，我们需要用到随机化数据。如果不随机化会怎么样呢？不随机化，我们的分类器就可能陷入某种极端情况，从而得出错误的解。</p><p>代码中，我们使用<code>numpy</code>的随机技术。</p><p>1、首先初始化随机种子，由于我希望每次都随机，所以我给随机种子传递的参数也是随机的<br>2、随机化排列，这样可以得到一个随机的排列，以在后续处理数据时相对公平。</p><pre class=" language-python"><code class="language-python">np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>int<span class="token punctuation">)</span><span class="token punctuation">)</span>order1 <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span>order0 <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="第四步、生成分界线斜率"><a href="#第四步、生成分界线斜率" class="headerlink" title="第四步、生成分界线斜率"></a>第四步、生成分界线斜率</h2><p>这一步是最核心的一步，我们通过输入的训练数据对直线斜率进行调整。方法就是利用预测值与期望值之间的误差进行拟合，同时使用学习率<code>learn</code>和一些调整量<code>adjust</code>，使得过去和现在的训练能同时起到作用，而不偏颇。</p><pre class=" language-python"><code class="language-python">slope <span class="token operator">=</span> <span class="token number">1.0</span>adjust <span class="token operator">=</span> <span class="token number">0.0</span>learn <span class="token operator">=</span> <span class="token number">0.5</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    slope <span class="token operator">+=</span> <span class="token punctuation">(</span>y1<span class="token punctuation">[</span>order1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> slope<span class="token operator">*</span>x1<span class="token punctuation">[</span>order1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> adjust<span class="token punctuation">)</span><span class="token operator">/</span>x1<span class="token punctuation">[</span>order1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">*</span>learn    slope <span class="token operator">+=</span> <span class="token punctuation">(</span>y0<span class="token punctuation">[</span>order0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> slope<span class="token operator">*</span>x0<span class="token punctuation">[</span>order0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> adjust<span class="token punctuation">)</span><span class="token operator">/</span>x0<span class="token punctuation">[</span>order0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">*</span>learn<span class="token keyword">print</span><span class="token punctuation">(</span>slope<span class="token punctuation">)</span></code></pre><h2 id="第五步、处理测试数据"><a href="#第五步、处理测试数据" class="headerlink" title="第五步、处理测试数据"></a>第五步、处理测试数据</h2><p>对测试数据的读入，我们的处理和训练数据是一样的。<br>通过对预边界测试和实际值的对比，我们得出测试数据的类别信息，从而实现分类。</p><pre class=" language-python"><code class="language-python">get <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"请输入测试数据："</span><span class="token punctuation">)</span>get <span class="token operator">=</span> get<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>test_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>x2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>y2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> get<span class="token punctuation">:</span>    test_data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>fromstring<span class="token punctuation">(</span>i<span class="token punctuation">,</span> dtype<span class="token operator">=</span>float<span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> test_data<span class="token punctuation">:</span>    x2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    y2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> x2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>slope <span class="token operator">></span> y2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><h2 id="第六步、输出展示分类结果"><a href="#第六步、输出展示分类结果" class="headerlink" title="第六步、输出展示分类结果"></a>第六步、输出展示分类结果</h2><p>图像是最直观的，因此我们利用<code>matplotlib</code>来展示结果。</p><pre class=" language-python"><code class="language-python">x <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> x<span class="token punctuation">:</span>    y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>slope<span class="token operator">*</span>i<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> linestyle<span class="token operator">=</span><span class="token string">'-'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x0<span class="token punctuation">,</span> y0<span class="token punctuation">,</span> <span class="token string">'v'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'blue'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'black'</span><span class="token punctuation">)</span></code></pre><p>如图<br><img src="/images/20180921_2.png" alt><br>可见，我们的分类器准确度还是比较高的。</p><hr><h2 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h2><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 训练集</span><span class="token number">1.0</span> <span class="token number">3.0</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3.0</span> <span class="token number">1.0</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2.0</span> <span class="token number">2.0</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4.0</span> <span class="token number">1.0</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2.0</span> <span class="token number">4.0</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4.5</span> <span class="token number">1.0</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3.0</span> <span class="token number">2.5</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5.0</span> <span class="token number">2.0</span> <span class="token number">0</span><span class="token comment" spellcheck="true"># 测试集</span><span class="token number">4.0</span> <span class="token number">3.0</span><span class="token punctuation">,</span><span class="token number">2.5</span> <span class="token number">2.5</span><span class="token punctuation">,</span><span class="token number">3.6</span> <span class="token number">1.5</span><span class="token punctuation">,</span><span class="token number">5.0</span> <span class="token number">1.5</span></code></pre><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre class=" language-python"><code class="language-python"><span class="token operator">%</span>matplotlib inline<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> plt<span class="token keyword">import</span> numpy <span class="token keyword">as</span> npget <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"请输入训练数据，第三个参数为类别"</span><span class="token punctuation">)</span>get <span class="token operator">=</span> get<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>train_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>x1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>y1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>x0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>y0 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> each <span class="token keyword">in</span> get<span class="token punctuation">:</span>    train_data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>fromstring<span class="token punctuation">(</span>each<span class="token punctuation">,</span> dtype<span class="token operator">=</span>float<span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> each <span class="token keyword">in</span> train_data<span class="token punctuation">:</span>    <span class="token keyword">if</span> each<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>        x1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>each<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        y1<span class="token punctuation">.</span>append<span class="token punctuation">(</span>each<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        x0<span class="token punctuation">.</span>append<span class="token punctuation">(</span>each<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        y0<span class="token punctuation">.</span>append<span class="token punctuation">(</span>each<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>seed<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10000</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>int<span class="token punctuation">)</span><span class="token punctuation">)</span>order1 <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span>order0 <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>permutation<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x0<span class="token punctuation">)</span><span class="token punctuation">)</span>slope <span class="token operator">=</span> <span class="token number">1.0</span>adjust <span class="token operator">=</span> <span class="token number">0.0</span>learn <span class="token operator">=</span> <span class="token number">0.5</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    slope <span class="token operator">+=</span> <span class="token punctuation">(</span>y1<span class="token punctuation">[</span>order1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> slope<span class="token operator">*</span>x1<span class="token punctuation">[</span>order1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> adjust<span class="token punctuation">)</span><span class="token operator">/</span>x1<span class="token punctuation">[</span>order1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">*</span>learn    slope <span class="token operator">+=</span> <span class="token punctuation">(</span>y0<span class="token punctuation">[</span>order0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> slope<span class="token operator">*</span>x0<span class="token punctuation">[</span>order0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">-</span> adjust<span class="token punctuation">)</span><span class="token operator">/</span>x0<span class="token punctuation">[</span>order0<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">*</span>learn<span class="token keyword">print</span><span class="token punctuation">(</span>slope<span class="token punctuation">)</span>get <span class="token operator">=</span> input<span class="token punctuation">(</span><span class="token string">"请输入测试数据："</span><span class="token punctuation">)</span>get <span class="token operator">=</span> get<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span>test_data <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>x2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>y2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> get<span class="token punctuation">:</span>    test_data<span class="token punctuation">.</span>append<span class="token punctuation">(</span>np<span class="token punctuation">.</span>fromstring<span class="token punctuation">(</span>i<span class="token punctuation">,</span> dtype<span class="token operator">=</span>float<span class="token punctuation">,</span> sep<span class="token operator">=</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> test_data<span class="token punctuation">:</span>    x2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    y2<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>x2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> x2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">*</span>slope <span class="token operator">></span> y2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>x <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>range<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>y <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> x<span class="token punctuation">:</span>    y<span class="token punctuation">.</span>append<span class="token punctuation">(</span>slope<span class="token operator">*</span>i<span class="token punctuation">)</span>plt<span class="token punctuation">.</span>figure<span class="token punctuation">(</span>figsize<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>xlim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>ylim<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> linestyle<span class="token operator">=</span><span class="token string">'-'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> <span class="token string">'o'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'red'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x0<span class="token punctuation">,</span> y0<span class="token punctuation">,</span> <span class="token string">'v'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'blue'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token string">'black'</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tarjan算法缩点+DAG最长路(DP)</title>
      <link href="/2018/08/13/tarjan-suan-fa-suo-dian-dag-zui-chang-lu-dp/"/>
      <url>/2018/08/13/tarjan-suan-fa-suo-dian-dag-zui-chang-lu-dp/</url>
      
        <content type="html"><![CDATA[<p>我们按照复杂程度来讨论不同的Tarjan算法变形的差异.</p><h2 id="第一个问题-Tarjan算法找出一个图里面的全部强连通分量-包括单独的点"><a href="#第一个问题-Tarjan算法找出一个图里面的全部强连通分量-包括单独的点" class="headerlink" title="第一个问题: Tarjan算法找出一个图里面的全部强连通分量(包括单独的点)."></a>第一个问题: Tarjan算法找出一个图里面的全部强连通分量(包括单独的点).</h2><p>但此时只是有所区分的将所有的点划分为一个个的强连通分量, 尚且没有缩点. 上面这个功能实现起来最简单. </p><p>它的Tarjan函数内部是这样的.</p><pre><code>void tarjan(int u){    dfn[u] = low[u] = ++index;    stack[++top] = u;    in_stack[u] = true;    for (int i = 0; i &lt; G[u].size(); ++i) {        int v = G[u][i];        if (!dfn[v]) { // 更新新的点.            tarjan(v);            low[u] = min(low[u], low[v]);        } else if (in_stack[v]) {            low[u] = min(low[u], low[v]);        } // 还剩下一种不在栈中但是已经访问过的情况,是其他连通分量的    }    if (dfn[u] == low[u]) {        do {            cout &lt;&lt; stack[top] &lt;&lt; &#39; &#39;;            in_stack[stack[top]] = false; // 漏写了这一条.        } while (stack[--top + 1] != u);        cout &lt;&lt; endl;    }}</code></pre><h2 id="第二个问题-对每个强连通分量进行缩点-使得此图变成一张DAG"><a href="#第二个问题-对每个强连通分量进行缩点-使得此图变成一张DAG" class="headerlink" title="第二个问题: 对每个强连通分量进行缩点, 使得此图变成一张DAG."></a>第二个问题: 对每个强连通分量进行缩点, 使得此图变成一张DAG.</h2><p>在Tarjan函数内部他们的主要区别是当<code>dfn[u] == low[u]</code>的这一段</p><pre><code>if (dfn[u] == low[u]) {        cnt++;        int now;        do {            now = sta.top();            sta.pop();            in_stack[now] = false;            to[now] = cnt;        } while (now != u);    }</code></pre><ul><li><p><strong>增加了一个全局变量<code>cnt</code>, 表示当前缩点的编号.</strong></p></li><li><p><strong>增加了一个<code>to</code>数组, 用来表示原来的点在缩点之后是哪个点.</strong></p></li></ul><p>所以我们可以有下面这段代码, <strong><code>set&lt;int&gt; Now</code>代表缩点后的新图.</strong></p><pre><code>for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt; G[i].size(); ++j) {            int u = to[i], v = to[G[i][j]];            if (u != v) Now[u].insert(v);        }    }</code></pre><p><strong>通过<code>to</code>数组关联起原图和缩点后图的点, 从而建立新图.</strong></p><p>这样, 通过<code>dfn[u] == low[u]</code>处的修改, 以及结合<code>to</code>数组建立新图的过程, 就实现了Tarjan算法的缩点.</p><h2 id="第三个问题-如何快速获得新图各个结点的入度出度"><a href="#第三个问题-如何快速获得新图各个结点的入度出度" class="headerlink" title="第三个问题: 如何快速获得新图各个结点的入度出度."></a>第三个问题: 如何快速获得新图各个结点的入度出度.</h2><p>上面的<code>to</code>数组保留, 看下面这段代码</p><pre><code>for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt; G[i].size(); ++j) {            if (to[i] != to[G[i][j]]) {                out[to[i]]++;                in[to[G[i][j]]]++;            }        }    }</code></pre><p>一二层循环遍历之前所有的边, 里面一个条件语句, <strong>判断边的两端点是否指向同一个缩点, 如果不是, 那么他们在<code>to</code>数组中所指向的新的结点也将作为一条边</strong>. <strong>利用<code>to</code>数组可以快速方便的获取新图中的入度和出度, 这样的话要知道入度和出度就无需建立新图.</strong></p><p>##第四个问题: 缩点之后求解DAG最长路</p><p>看洛谷上的这道题 <a href="https://www.luogu.org/problemnew/show/P3387" target="_blank" rel="noopener">传送门</a></p><p>此题是以点为权值而非边, 但做法是基本差不多的. 都是DP算法.</p><p>DP函数是这样</p><pre><code>int DP(int u){    if (dp[u]) return dp[u];    set&lt;int&gt;::iterator is = Now[u].begin();    while (is != Now[u].end()) {        dp[u] = max(dp[u], DP(*is));        is++;    }    dp[u] += val_now[u];    return dp[u];}</code></pre><p><strong>状态转移方程: <code>dp[i] = max{dp[j] | (i, j) ∈E} + val_now[i]</code></strong><br><strong>区别于边为权值的方程:<code>dp[i] = max{dp[j]+length[i→j] | (i,j)∈E}</code></strong></p><p>AC代码</p><pre><code>#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;set&gt;using namespace std;const int maxn = 10005;stack&lt;int&gt; sta;vector&lt;int&gt; G[maxn];set&lt;int&gt; Now[maxn];int n, m, index = 0, cnt = 0, ans = 0;int to[maxn], dfn[maxn] = {}, low[maxn];int dp[maxn] = {}, val[maxn], val_now[maxn] = {};bool in_stack[maxn] = {};void tarjan(int u){    dfn[u] = low[u] = ++index;    in_stack[u] = true;    sta.push(u);    for (int i = 0; i &lt; G[u].size(); ++i) {        int v = G[u][i];        if (dfn[v] == 0) {            tarjan(v);            low[u] = min(low[u], low[v]);        } else if (in_stack[v]) low[u] = min(low[u], low[v]);    }    if (dfn[u] == low[u]) {        cnt++;        int now;        do {            now = sta.top();            sta.pop();            in_stack[now] = false;            to[now] = cnt;        } while (now != u);    }}int DP(int u){    if (dp[u]) return dp[u];    set&lt;int&gt;::iterator is = Now[u].begin();    while (is != Now[u].end()) {        dp[u] = max(dp[u], DP(*is));        is++;    }    dp[u] += val_now[u];    return dp[u];}int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; ++i)        cin &gt;&gt; val[i];    for (int i = 0; i &lt; m; ++i) {        int u, v;        cin &gt;&gt; u &gt;&gt; v;        G[u].push_back(v);    }    for (int i = 1; i &lt;= n; ++i)        if (dfn[i] == 0) tarjan(i);    for (int i = 1; i &lt;= n; ++i) {        for (int j = 0; j &lt; G[i].size(); ++j) {            int u = to[i], v = to[G[i][j]];            if (u != v) Now[u].insert(v);        }    }    for (int i = 1; i &lt;= n; ++i) {        int t = to[i];        val_now[t] += val[i];    }    for (int i = 1; i &lt;= cnt; ++i)        ans = max(ans, dp[i] = DP(i));    cout &lt;&lt; ans;}</code></pre><p><em><em>我认为Tarjan算法缩点的核心就是<code>to</code>数组. </em></em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契_矩阵快速幂解法</title>
      <link href="/2018/07/26/fei-bo-na-qi-ju-zhen-kuai-su-mi-jie-fa/"/>
      <url>/2018/07/26/fei-bo-na-qi-ju-zhen-kuai-su-mi-jie-fa/</url>
      
        <content type="html"><![CDATA[<p><strong>学过矩阵学了矩阵再看斐波那契数列, 秒懂, 结合矩阵快速幂, 加深了一个概念的理解: 矩阵也就是一个基本的计算单位.</strong></p><p>矩阵快速幂解法其实就是<strong>快速幂+矩阵.</strong> </p><p>和普通的快速幂有什么不同? 不同的是<strong>基数的类型</strong>,快速幂的过程还是一样的. 同样的,快速幂结果一般取模, 因为数据实在是太大了. 那么矩阵快速幂是否也应该取模?</p><p>那么推导一下似乎可以发现,<strong>矩阵的每个数都取模p,因为结果其实就是矩阵的某个元素</strong> </p><p>以[[1, 1], [1, 0]]的幂为n, n = 0时, 结果0, 如果我们取f0 = 0, f1 = 1, 以此类推,那么<strong>n次幂的结果就是右下角的那个数.</strong> </p><p>同时<strong>时间复杂度为O(n log n).</strong> </p><p>我们来回顾一下快速幂, <strong><em>是从一次不断进行倍增, 如果数n 的二进制形式在某一位上为1,那么就乘以这一位,否则不乘</em></strong> </p><p>先写一下快速幂代码. </p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> p<span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> val <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    cin <span class="token operator">>></span> n <span class="token operator">>></span> p<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> ans <span class="token operator">*</span> val <span class="token operator">%</span> p<span class="token punctuation">;</span>        val <span class="token operator">*</span><span class="token operator">=</span> val<span class="token punctuation">;</span>        n <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// OK, 就是这么简单.</span></code></pre><hr><p>那么矩阵快速幂也呼之欲出了. </p><p>然而写了代码发现计算过程有误.(划掉, 应该是推导有误,睡个午觉再来看看).<br>OK, 找出bug来了, 推导没有错误, <strong>是做矩阵乘法的时候几个下标写错了. 需要特别小心</strong></p><p>但是发现答案稍微有点问题<em><em>,看出其实now矩阵不用设置为二维单位矩阵,直接是[1, 0], 他就是答案. </em></em></p><p>但是非常悲剧的是洛谷上没有这么简单的模板题, 都<em><em>不给我辛苦学习AC一下的快感. </em></em></p><pre><code>#include &lt;iostream&gt;using namespace std;int main(){    int n, p = (1 &lt;&lt; 31);    cin &gt;&gt; n;    int now[2][1] = {{1}, {0}}, matrix[2][2] = {{1, 1}, {1, 0}};    while (n) {        int a, b, c, d;        if (n &amp; 1) { // 矩阵相乘.             a = matrix[0][0] * now[0][0] + matrix[0][1] * now[1][0];            b = matrix[1][0] * now[0][0] + matrix[1][1] * now[1][0];            now[0][0] = a % p, now[1][0] = b % p;        }        // 下面是矩阵平方, 有点麻烦.         a = matrix[0][0] * matrix[0][0] + matrix[0][1] * matrix[1][0];        b = matrix[0][0] * matrix[0][1] + matrix[0][1] * matrix[1][1];        c = matrix[1][0] * matrix[0][0] + matrix[1][1] * matrix[1][0];        d = matrix[1][0] * matrix[0][1] + matrix[1][1] * matrix[1][1];        //cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;         matrix[0][0] = a % p, matrix[0][1] = b % p, matrix[1][0] = c % p, matrix[1][1] = d % p;        n /= 2;        //cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;        //cout &lt;&lt; matrix[0][0] &lt;&lt; &#39; &#39; &lt;&lt; matrix[0][1] &lt;&lt; endl &lt;&lt; matrix[1][0] &lt;&lt; &#39; &#39; &lt;&lt; matrix[1][1] &lt;&lt; endl;    }    cout &lt;&lt; now[1][0];}</code></pre><p>再来串矩阵快速幂模板(不只是斐波那契矩阵)</p><p>也就是<strong>矩阵计算 + 快速幂</strong>的组合. <strong>O(n</strong>3 + log k)**</p><pre><code>#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const LL mode = 1000000007;void calc(LL ans[105][105], LL matrix[105][105], LL n){    LL tmp[105][105];    memset(tmp, 0, sizeof(tmp));    for (int i = 1; i &lt;= n; ++i) {        for (int j = 1; j &lt;= n; ++j) {            for (int k = 1; k &lt;= n; ++k) {                tmp[i][j] += ans[i][k] * matrix[k][j];                tmp[i][j] %= mode;            }        }    }    for (int i = 1; i &lt;= n; ++i) {        for (int j = 1; j &lt;= n; ++j) {            ans[i][j] = tmp[i][j];        }    }}int main(){    LL n, k, matrix[105][105], ans[105][105];    cin &gt;&gt; n &gt;&gt; k;    for (int i = 1; i &lt;= n; ++i) {        for (int j = 1; j &lt;= n; ++j) {            cin &gt;&gt; matrix[i][j];        }    }    // 初始化为单位矩阵.     memset(ans, 0, sizeof(ans));    for (int i = 1; i &lt;= n; ++i) {        ans[i][i] = 1;    }    while (k) {        if (k &amp; 1) {            calc(ans, matrix, n);        }        calc(matrix, matrix, n);        k /= 2;    }    for (int i = 1; i &lt;= n; ++i) {        for (int j = 1; j &lt;= n; ++j) {            cout &lt;&lt; ans[i][j] &lt;&lt; &#39; &#39;;        }        cout &lt;&lt; endl;    }}/*矩阵计算 + 快速幂*/ </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>倍增法求Lca(最近公共祖先)</title>
      <link href="/2018/07/16/bei-zeng-fa-qiu-lca-zui-jin-gong-gong-zu-xian/"/>
      <url>/2018/07/16/bei-zeng-fa-qiu-lca-zui-jin-gong-gong-zu-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="一-明确问题"><a href="#一-明确问题" class="headerlink" title="一. 明确问题"></a>一. 明确问题</h2><p>看标题便知道了, 这篇博客力求解决的问题是<strong>求出一棵树的两个结点的最近公共祖先(LCA), 方法是倍增法.</strong></p><p>那么什么是Lca呢? </p><blockquote><p><strong>它是一棵树上两个结点向上移动, 最后交汇的第一个结点, 也就是说这两个结点祖先里离树根最远也是离他们最近的结点.</strong></p></blockquote><p>什么是倍增法呢? </p><blockquote><p><strong>此问题说的是用倍增法求解lca问题, 那么我们可以推测这种方法还可以解决其他的一些问题(不在当下讨论范围). 在学习的过程中, 我是这么理解的: 它是一种类似于二分的方法, 不过这里不是二分, 而是倍增, 以2倍, 4倍, 等等倍数增长</strong></p></blockquote><p>一下没有理解倍增法没关系, 看后面的做法, 再结合前面, 前后贯通大概可以理解的七七八八.</p><h2 id="二-思路引导"><a href="#二-思路引导" class="headerlink" title="二. 思路引导"></a>二. 思路引导</h2><p><strong>下面的思路试图把过程模块化, 如果你不知道一个地方如何实现, 还请不要纠结</strong>(比如不要纠结于树的深度怎么求, 假设我们求好了树的深度)</p><p>我们找的是任意两个结点的最近公共祖先, 那么我们可以考虑这么两种种情况:</p><ol><li>两结点的深度相同.</li><li>两结点深度不同.</li></ol><p>算法实现来说, <strong>第一种情况是第二种情况的特殊情况, 第二种情况是要转化成第一种情况的</strong></p><p>先不考虑其他, 我们思考这么一个问题: <em><em>对于两个深度不同的结点, 把深度更深的那个向其父节点迭代, 直到这个迭代结点和另一个结点深度相同, 那么这两个深度相同的结点的Lca也就是原两个结点的Lca. </em></em> 因此第二种情况转化成第一种情况来求解Lca是可行的.</p><p>现在还不知道如何把两个结点迭代到相同深度, 别急, 这里用到的是上面提到的<strong>倍增法</strong>.</p><p>那么剩下的问题事就解决第一种情况了, 两个结点深度相同了. 怎么求他们的Lca呢?</p><p>这里也是用了倍增法. 思路和上一步的倍增法是一样的, 不同之处有两点</p><ol><li>这次是两个结点一起迭代向前的.</li><li>这次迭代停止的条件和上次不一样.</li></ol><p>OK, 现在无法理解上面的几个过程没关系,<strong>只要知道我们用递增法解决了上述的两个问题.</strong> 具体细节看下面分析.</p><h2 id="三-整体框架"><a href="#三-整体框架" class="headerlink" title="三. 整体框架."></a>三. 整体框架.</h2><p>那么过了一遍上面的思路引导之后, 我们可以大概想一想怎么实现整个的问题了.</p><p>其实用求Lca这个问题可以分为两块: <strong>预处理 + 查询</strong>, 其中预处理是O(VlogV), 而一次查询是O(logV), V代表结点数量. 所以总<strong>时间复杂度为O(VlogV +ＱlogV)</strong>. Q为查询次数</p><p>其步骤是这样的: </p><ol><li>存储一棵树(邻接表法)</li><li>获取树各结点的上的深度(dfs或bfs)</li><li>获取2次幂祖先的结点, 用parents[maxn][20]数组存储, <strong>倍增法关键</strong></li><li>用倍增法查询Lca</li></ol><h3 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h3><p><strong>用邻接表存储一棵树, 并用from[]数组记录各结点的父节点, 其中没有父节点的就是root.</strong></p><p>parents[u][]数组存储的是u结点的祖先结点.<br>如parents[u][0], 是u结点的2⁰祖先结点, 即1祖先, 也即父节点. 在输入过程中可以直接得到.<br>parents[u][1], 是u结点的2¹祖先结点,即2祖先, 也即父亲的父亲<br>parents[u][2], 是u结点的2²祖先结点, 即4祖先, 也即(父亲的父亲)的(父亲的父亲), 也就是爷爷的爷爷. </p><p><strong>理解这个关系很重要, 这也是通过父亲结点获取整个祖先结点的关键.</strong> 现在可以先跳过.</p><pre><code>void getData(){    cin &gt;&gt; n;    int u, v;    for (int i = 1; i &lt; n; ++i) {        cin &gt;&gt; u &gt;&gt; v;        G[u].push_back(v);        parents[v][0] = u;        from[v] = 1;    }    for (int i = 1; i &lt;= n; ++i) {        if (from[i] == -1) root = i;    }}</code></pre><h3 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h3><p><strong>获取各结点的深度, 可以用DFS或这BFS方法</strong></p><pre><code>void getDepth_dfs(int u) // DFS求深度{    int len = G[u].size();    for (int i = 0; i &lt; len; ++i) {        int v = G[u][i];        depth[v] = depth[u] + 1;        getDepth_dfs(v);    }}void getDepth_bfs(int u) // BFS求深度{    queue&lt;int&gt; Q;    Q.push(u);    while (!Q.empty()) {        int v = Q.front();        Q.pop();        for (int i = 0; i &lt; G[v].size(); ++i) {            depth[G[v][i]] = depth[v] + 1;            Q.push(G[v][i]);        }    }}</code></pre><h3 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h3><p><strong>求祖先</strong></p><p>在步骤一里面我们讨论了parents数组的意义, 它存的是结点u的2次幂祖先, 从父亲结点开始. 为什么要存2次幂? 这就是<strong>倍增法</strong>的思想了, 我们进行范围缩小不是一步一步的, 那样太暴力了, <strong>所以我们需要某个跨度, 让我们能够先跨越大步, 接近的时候在小步小步跨越, 这样可以大大节省时间.</strong></p><p><em><em>读者可能会疑惑, 先大步, 后小步, 可是我怎么知道什么时候该大步, 什么时候该小步呢? 难道不会不小心跨过头吗? </em></em></p><p>其实不会的, 在代码实现上, <strong>这样的跨越有条件约束, 是非常讲究的. 读者不必为此纠结, <em><em> 不过要讲解也是十分费力不讨好的事情, 所以请读者认证推敲后面Lca函数的代码, 认真琢磨为什么是那样跨越, 其中真味自会品出. </em></em>最好是自己写几个例子, 模拟跨越的过程, 在结合现实意义去理解</strong></p><p>那么我们回到当前问题. 请看下面这个公式:</p><blockquote><p><strong>parents[i][j] = parents[parents[i][j-1]][j-1]</strong></p></blockquote><p>这是构造此数组的公式. 不难理解, <em><em>父亲的父亲就是爷爷, 爷爷的爷爷就是4倍祖先. </em></em> 请读者结合现实意义去理解. </p><pre><code>void getParents(){    for (int up = 1; (1 &lt;&lt; up) &lt;= n; ++up) {        for (int i = 1; i &lt;= n; ++i) {            parents[i][up] = parents[parents[i][up - 1]][up - 1];        }    }}</code></pre><h3 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h3><p>做完了前面<strong>O(VlogV)</strong>的预处理操作, 剩下的就是查询了, 一次查询<strong>O(logV)</strong></p><p>因此, 我们可以敏锐的想到: <strong>Lca算法适合查询次数比较多的情况, 不然, 光是预处理就花了那么多时间了</strong>. 所以说, 查询是我们享受成果的时候了.</p><pre><code>int Lca(int u, int v){    if (depth[u] &lt; depth[v]) swap(u, v); // 使满足u深度更大, 便于后面操作     int i = -1, j;    // i求的是最大二分跨度     while ((1 &lt;&lt; (i + 1)) &lt;= depth[u]) ++i;    // 下面这个循环是为了让u和v到同一深度     for (j = i; j &gt;= 0; --j) {        if (depth[u] - (1 &lt;&lt; j) &gt;= depth[v]) { // 是&gt;=, 因为如果&lt;,代表跳过头了,跳到了上面.             u = parents[u][j];        }    }    if (u == v) return u; // 刚好是祖宗     // u和v一起二分找祖宗    for (j = i; j &gt;= 0; --j) {        if (parents[u][j] != parents[v][j]) {            u = parents[u][j];            v = parents[v][j];        }    }    return parents[u][0]; // 说明上个循环迭代到了Lca的子结点 }</code></pre><ul><li><p>首先把u调整到深度更大(或相同)的结点, 便于后面操作.</p></li><li><p>然后获取最大跨度i, 所有的跨越都是从i开始的.</p></li><li><p>再然后把u上升到和v一样的深度. 也就是我们前面讨论过的情况二转情况一.</p></li><li><p>最后, 两个结点同时迭代, 直到找到Lca</p></li></ul><p>至此, 我们的问题就解决了.</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;const int maxn = 10005;int parents[maxn][20], depth[maxn];int n, from[maxn], root = -1;vector&lt;int&gt; G[maxn];void init(){    memset(parents, -1, sizeof(parents));    memset(from, -1, sizeof(from));    memset(depth, -1, sizeof(depth));}void getData(){    cin &gt;&gt; n;    int u, v;    for (int i = 1; i &lt; n; ++i) {        cin &gt;&gt; u &gt;&gt; v;        G[u].push_back(v);        parents[v][0] = u;        from[v] = 1;    }    for (int i = 1; i &lt;= n; ++i) {        if (from[i] == -1) root = i;    }}void getDepth_dfs(int u){    int len = G[u].size();    for (int i = 0; i &lt; len; ++i) {        int v = G[u][i];        depth[v] = depth[u] + 1;        getDepth_dfs(v);    }}void getDepth_bfs(int u){    queue&lt;int&gt; Q;    Q.push(u);    while (!Q.empty()) {        int v = Q.front();        Q.pop();        for (int i = 0; i &lt; G[v].size(); ++i) {            depth[G[v][i]] = depth[v] + 1;            Q.push(G[v][i]);        }    }}void getParents(){    for (int up = 1; (1 &lt;&lt; up) &lt;= n; ++up) {        for (int i = 1; i &lt;= n; ++i) {            parents[i][up] = parents[parents[i][up - 1]][up - 1];        }    }}int Lca(int u, int v){    if (depth[u] &lt; depth[v]) swap(u, v);    int i = -1, j;    while ((1 &lt;&lt; (i + 1)) &lt;= depth[u]) ++i;    for (j = i; j &gt;= 0; --j) {        if (depth[u] - (1 &lt;&lt; j) &gt;= depth[v]) {            u = parents[u][j];        }    }    if (u == v) return u;    for (j = i; j &gt;= 0; --j) {        if (parents[u][j] != parents[v][j]) {            u = parents[u][j];            v = parents[v][j];        }    }    return parents[u][0];}void questions(){    int q, u, v;    cin &gt;&gt; q;    for (int i = 0; i &lt; q; ++i) {        cin &gt;&gt; u &gt;&gt; v;        int ans = Lca(u, v);        cout &lt;&lt; ans &lt;&lt; endl;        //cout &lt;&lt; u &lt;&lt; &quot; 和 &quot; &lt;&lt; v &lt;&lt; &quot; 的最近公共祖先(LCA)是: &quot; &lt;&lt; ans &lt;&lt; endl;     }}int main(){    init();    getData();    depth[root] = 1;    getDepth_dfs(root);    //getDepth_bfs(root);    getParents();    questions();}/*91 21 31 42 52 63 76 87 951 35 68 98 45 8*/</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP_最长不下降子序列</title>
      <link href="/2018/07/11/dp-zui-chang-bu-xia-jiang-zi-xu-lie-lis/"/>
      <url>/2018/07/11/dp-zui-chang-bu-xia-jiang-zi-xu-lie-lis/</url>
      
        <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>同类的问题还有<em>“最长上升子序列”, “最长下降子序列”, …</em></p><p>他们的不同就在于<strong>定义的core规则不同</strong>, 有的是&gt;=, 有的是&gt;, 有的是&lt;</p><p>由此启发, 我们可以在解决其他的问题, <strong>不一定是比较数的大小的问题里面抽象出这种模型.</strong></p><p>下面介绍这种动态规划入门都会介绍的问题的思路. </p><p>首先我们从头开始分析这个问题.</p><h3 id="一-最容易想到的最暴力的方法"><a href="#一-最容易想到的最暴力的方法" class="headerlink" title="一. 最容易想到的最暴力的方法"></a>一. 最容易想到的最暴力的方法</h3><p>对这个序列中的每一个数的”有”和”无”分两种情况讨论. 代码实现上就是递归.</p><p><strong>时间复杂度就是O(2^n)</strong></p><p>代码实现上较为简单. 不展示</p><h3 id="二-第二种方法是O-n-2-的DP方法"><a href="#二-第二种方法是O-n-2-的DP方法" class="headerlink" title="二. 第二种方法是O(n^2)的DP方法"></a>二. 第二种方法是O(n^2)的DP方法</h3><p><strong>动态规划的问题是无后效性的, 每个问题都可以分解为更小的子问题, 从而求解.</strong></p><p>这道题也不例外.</p><p>这个序列的每一个数为止都有一个解, 作为子问题的解. 后面的问题的解就是从这些子问题的最优解继承过来的.</p><p>so, 给这个序列的解建立数组dp[n], 0 - n分别是截止到Ai的解.</p><blockquote><p>当下一个数要加入来的时候, 有两种情况</p><ol><li><p>前面的数都比当前数更大, 因此以这个数为止的最长不下降子序列的长度就是1. 遍历到第一个数的情况也包含在内.</p></li><li><p>前面的数有不比当前数大的, 那么这个数的结果dp[i] = max(dp[i], dp[j] + 1). 这个过程遍历前面所有数的dp[j]进行比较.</p></li></ol><p><strong>最后的答案就是所有dp[i]里面的最大值.</strong></p></blockquote><p>这种方法的<strong>时间复杂度是O(n^2)</strong>, 可以看到相比于前面暴力递归的方法有了极大的进步.</p><p>代码通过样例, 但不一定能过题, 请谨慎使用.</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main(){    int n, x;    vector&lt;int&gt; v;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; ++i) {        cin &gt;&gt; x;        v.push_back(x);    }    int dp[(int)v.size()] = {1}, ans = 1;    for (int i = 1; i &lt; (int)v.size(); ++i) {        for (int j = 0; j &lt; i; ++j) {            if (v[i] &gt;= v[j]) dp[i] = max(dp[i], dp[j] + 1); // 状态转移方程        }        ans = max(ans, dp[i]);    }    cout &lt;&lt; ans;}/*81 2 3 -9 3 9 0 11*/</code></pre><h3 id="三-O-nlogn-方法-维护单调数组"><a href="#三-O-nlogn-方法-维护单调数组" class="headerlink" title="三. O(nlogn)方法, 维护单调数组"></a>三. O(nlogn)方法, 维护单调数组</h3><p>这个方法也是DP方法</p><p>时间复杂度可以从O(n^2)降到O(n log n).</p><p><strong>我们从最长上升子序列的角度来探讨</strong></p><p>假设对一个序列n[1…9] = {2 1 5 3 6 4 8 9 7}, 维护一个单调数组, 使得这个数组为最长上升子序列. 设这个数组为d[ ].</p><p>对n[1] = 2, 使得d[1] = 2;</p><p>对n[2] = 1, 因为1比2小, 所以修改d[1]的值, 使其为1</p><p>对n[3] = 5, 5比1大, 所以len++, d[2] = 5</p><p>对n[4] = 3, 3比1大比5小, 所以替换掉5, 使d[2] = 3</p><p>对n[5] = 6, 6比d[2]大, 所以len++, d[3] = 6</p><p>对n[6] = 4, 4比3大比6小, 所以替换掉6, 使d[3] = 4</p><p>对n[7] = 8, 8比4大, 所以len++, 使d[4] = 8</p><p>对n[8] = 9, 9比8大, 所以len++, 使d[5] = 9</p><p>对n[9] = 7, 7比4大比8小, 所以替换掉8, 使d[4] = 7.</p><p>至此这个序列遍历完了, 最小的长度也出来了. 最后的序列是1 3 4 7 9, len = 5</p><p> 仔细琢磨会觉得, <strong>如最后一步操作, 为什么后面的7反而到他前面的8, 9的前面去了.</strong> 其实仔细一想并无问题, 因为即使7出现在前面, 它并不影响最终结果, <strong>因为我们已经得出最后结果就是len</strong>, 而以7为结尾的最长序列在该题中是len - 1, 如果后面还有序列, <strong>那么这里把7替换掉8会使得当前状态更优, 因为这样的修改是不会改变当前结果的, 但是确实后续最优状态的基础. 而这道题的动态规划思想就是这样, 不断地获取最优状态.</strong></p><p>经过前面的分析我们也许会发现, 这个DP的过程无法存储中间结果, 也就是说<strong>我们只能知道最长的子序列是多长, 而无法得到是哪个序列.</strong> 可谓是有利有弊.</p><p>利用我们维护的数组的单调性, 我们可以用二分法查找这个比当前数更大数的位置, 从而方便的实现替换.</p><p>所以时间复杂度为O(n log n).</p><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main(){    int n, x;    vector&lt;int&gt; v, vec;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; ++i) {        cin &gt;&gt; x;        v.push_back(x);    }    for (int i = 0; i &lt; (int)v.size(); ++i) {        if (i == 0) vec.push_back(v[0]);        else {            if (v[i] &gt;= vec[vec.size() - 1]) vec.push_back(v[i]);            else *upper_bound(vec.begin(), vec.end(), v[i]) = v[i];        }    }    for (int i = 0; i &lt; (int)vec.size(); ++i) {        cout &lt;&lt; vec[i] &lt;&lt; &#39; &#39;;    }    cout &lt;&lt; endl;    cout &lt;&lt; &quot;len == &quot; &lt;&lt; vec.size() &lt;&lt; endl;}/*92 1 5 3 6 4 8 9 7*/</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP_最长回文子串</title>
      <link href="/2018/07/11/dp-zui-chang-hui-wen-zi-chuan/"/>
      <url>/2018/07/11/dp-zui-chang-hui-wen-zi-chuan/</url>
      
        <content type="html"><![CDATA[<p>####DP问题, 最长回文子串</p><p>最长回文子串问题指的是在一个字符串中, 是回文子串的长度的最大值. 这里的回文子串是<strong>连续的</strong>. </p><p><em>如字符串”PATZJUJZTACCBCC”, 他的最长回文子串是”ATZJUJZTA”, 长度为9, 当然它还有其他回文子串如”CCBCC”, 但是长度不够长.</em></p><p>这类问题似乎有多种解法, 复杂度从O(n^3)到O(n)不等.</p><p>下面介绍一种<strong>时间复杂度为O(n^2)</strong>的.</p><p>思路是典型的DP思路, 我们可以考量这样一个数组, dp[i][j], bool类型, 值为1代表字符串从S[i]到S[j]是回文子串, 值为0代表不是.</p><p>那么对于任意的i, j, 如何判断dp[i][j]的值呢? 讨论下面两种情况:</p><p><strong>1. s[i] = s[j]时, 如果dp[i+1][j-1] = 0, 即从s[i+1]到s[j-1]是回文子串, 那么从s[i][j]自然是回文子串, 所以dp[i][j] = dp[i+1][j-1]</strong><br><strong>2.  s[i] != s[j]时, 如论如何dp[i][j] = 0</strong></p><p>那么这样看思路就非常清晰了, 看上去非常简单, 按照这个规则判断一下就好了.</p><p>不过其实这道题是非常有技巧的, 我们可以看到要获取dp[i][j]值, 那么就需要知道dp[i+1][j-1]的值, 那么就不能从前往后遍历i了, 怎么办呢? 从后往前遍历吗? 当然也不行. 这就是这种方法的精彩所在, 两套循环,<strong>外围遍历长度, 内围遍历字符串起始点i.</strong></p><p>因为dp[i][j]的长度是j - i + 1, 而dp[i+1][j-1]的长度是j - i - 1, 长度差了两个, 如果我把长度小的结果都求解出来了, 那么长度更长的用长度更小的, 无论i是否会更大, 都是可以的. 不得不说很是精彩.</p><p>代码实现上, <strong>注意前面初始化长度 2时对ans赋恰当的值.</strong></p><pre><code>#include &lt;iostream&gt;using namespace std;int main(){    string str;     cin &gt;&gt; str;    int dp[str.size() + 1][str.size() + 1] = {}, ans = 1;    for (int i = 0; i &lt; int(str.size()); ++i) {        dp[i][i] = 1;        if (str[i] == str[i + 1]) {            dp[i][i + 1] = 1;            ans = 2;        }    }    for (int len = 3; len &lt;= (int)str.size(); ++len) {        for (int i = 0; i + len - 1 &lt; (int)str.size(); ++i) {            int k = i + len - 1;            if (str[i] == str[k]) {                dp[i][k] = dp[i + 1][k - 1];                if (dp[i][k]) ans = len;            }        }    }    cout &lt;&lt; ans;}/*PATZJUJZTACCBCC    ans = 934567536487326483254   ans = 1*/ </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>离散数学_C++生成真值表_模拟</title>
      <link href="/2018/04/07/chi-san-shu-xue-c-sheng-cheng-zhen-zhi-biao-mo-ni/"/>
      <url>/2018/04/07/chi-san-shu-xue-c-sheng-cheng-zhen-zhi-biao-mo-ni/</url>
      
        <content type="html"><![CDATA[<p>生成真值表的代码</p><p>输入一个真值表达式, 程序自动生成它的真值表.</p><p>纯模拟思路</p><blockquote><p>合取*<br>析取|<br>单条件&gt;<br>双条件-<br>非!</p></blockquote><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;int cnt = 0, chval[26] = {};void getAlpha(string str, char *chs, int &amp;cnt)  //获取真值表中的字符 {    int ch[26] = {};    for(int i = 0; i &lt; (int)str.length(); ++i) {        if(isalpha(str[i])) ch[str[i] - &#39;a&#39;] ++;    }    for(int i = 0; i &lt; 26; ++i) {        if(ch[i]) {            chs[cnt++] = i+97;        }    }}string shuzhitihuan(string str, int chval[26]){    string st = &quot;&quot;;    for(int i = 0; i &lt; str.size(); ++i) {        if(str[i] &lt;= &#39;z&#39; &amp;&amp; str[i] &gt;= &#39;a&#39;) {            st += chval[str[i] - &#39;a&#39;] ? &quot;1&quot;:&quot;0&quot;;        } else st += str[i];    }    return st;}void qvkuohao(string &amp; str)  //需要去除两种括号()(1)(0){    string st = &quot;&quot;;    for(int i = 0; i &lt; str.size(); ++i) {        if(str[i] == &#39;(&#39; &amp;&amp; i+2 &lt; str.size() &amp;&amp; str[i+2] == &#39;)&#39;) {            st += str[i+1];            i += 2;        } else st += str[i];    }    str = st;}void qvfei(string &amp;str) {    string st = &quot;&quot;;    for(int i = 0; i &lt; str.size(); ++i) {        if(str[i] == &#39;!&#39; &amp;&amp; i+1 &lt; str.size() &amp;&amp; str[i+1] == &#39;0&#39;) {            st += &#39;1&#39;;            i++;        } else if(str[i] == &#39;!&#39; &amp;&amp; i + 1 &lt; str.size() &amp;&amp; str[i+1] == &#39;1&#39;) {            st += &#39;0&#39;;            i++;        } else st += str[i];    }    str = st;} void qvheqv(string &amp;str){    string st = &quot;&quot;;    for(int i = 0; i &lt; str.size(); ++i) {        if(str[i] == &#39;1&#39; &amp;&amp; i+2 &lt; str.size() &amp;&amp; str[i+2] == &#39;1&#39; &amp;&amp; str[i+1] == &#39;*&#39;) {            st += &#39;1&#39;;            i += 2;        } else if(i+2 &lt; str.size() &amp;&amp; str[i+1] == &#39;*&#39; &amp;&amp; ((str[i] == &#39;1&#39; &amp;&amp; str[i+2] == &#39;0&#39;)        || (str[i] == &#39;0&#39; &amp;&amp; str[i+2] == &#39;1&#39;) || (str[i] == &#39;0&#39; &amp;&amp; str[i+2] == &#39;0&#39;))) {            st += &#39;0&#39;;            i += 2;        } else st += str[i];    }    str = st;}void qvxiqv(string &amp; str){    string st = &quot;&quot;;    for(int i = 0; i &lt; str.size(); ++i) {        if(str[i] == &#39;0&#39; &amp;&amp; i+2 &lt; str.size() &amp;&amp; str[i+2] == &#39;0&#39; &amp;&amp; str[i+1] == &#39;|&#39;) {            st += &#39;0&#39;;            i += 2;        } else if (i+2 &lt; str.size() &amp;&amp; str[i+1] == &#39;|&#39; &amp;&amp; ((str[i] == &#39;1&#39; &amp;&amp; str[i+2] == &#39;0&#39;)        || (str[i] == &#39;0&#39; &amp;&amp; str[i+2] == &#39;1&#39;) || (str[i] == &#39;1&#39; &amp;&amp; str[i+2] == &#39;1&#39;))) {            st += &#39;1&#39;;            i += 2;        } else st += str[i];    }    str = st;}void qvdantiaojian(string &amp;str){    string st = &quot;&quot;;    for(int i = 0; i &lt; str.size(); ++i) {        if(str[i + 1] == &#39;&gt;&#39; &amp;&amp; str[i] == &#39;1&#39; &amp;&amp; str[i+2] == &#39;0&#39;) {            st += &#39;0&#39;;            i += 2;        } else if(str[i+1] == &#39;&gt;&#39; &amp;&amp; ((str[i] == &#39;1&#39; &amp;&amp; str[i+2] == &#39;1&#39;)        || str[i] == &#39;0&#39; &amp;&amp;(str[i+2] == &#39;1&#39; || str[i+2] == &#39;0&#39;))) {            st += &#39;1&#39;;            i += 2;        } else st += str[i];    }    str = st;}void qvshuangtiaojian(string &amp;str){    string st = &quot;&quot;;    for(int i = 0; i &lt; str.size(); ++i) {        if(str[i+1] == &#39;-&#39; &amp;&amp; ((str[i] == &#39;1&#39; &amp;&amp; str[i+2] == &#39;1&#39;) || (str[i] == &#39;0&#39; &amp;&amp; str[i+2] == &#39;0&#39;))) {            st += &#39;1&#39;;            i += 2;        } else if(str[i+1] == &#39;-&#39; &amp;&amp; ((str[i] == &#39;1&#39; &amp;&amp; str[i+2] == &#39;0&#39;) || (str[i] == &#39;0&#39; &amp;&amp; str[i+2] == &#39;1&#39;))) {            st += &#39;0&#39;;            i += 2;        } else st += str[i];     }    str = st;}int main(){    string str, tmp;    char chs[12];    cin &gt;&gt; str;    getAlpha(str, chs, cnt);  //只讨论小写字母    tmp = str;    for(int j = 0; j &lt; cnt; ++j) {        cout &lt;&lt; chs[j] &lt;&lt; &quot;  &quot;;    }     cout &lt;&lt; tmp;    cout &lt;&lt; endl;    for(int i = 0; i &lt; pow(2, cnt); ++i) {        for(int j = 0; j &lt; cnt; ++j) { //赋值过程             chval[chs[j] - &#39;a&#39;] = (1 &amp; (i&gt;&gt;(cnt-1-j)));        }    cout &lt;&lt; endl;        for(int j = 0; j &lt; cnt; ++j) {            cout &lt;&lt; chval[chs[j] - &#39;a&#39;] &lt;&lt; &quot;  &quot;;        }        str = shuzhitihuan(str, chval);        while(str.size() != 1) {            qvkuohao(str);            qvfei(str);            qvheqv(str);            qvxiqv(str);            qvdantiaojian(str);            qvshuangtiaojian(str);         }        for(int i = 0; i &lt; tmp.size() / 2; ++i) cout &lt;&lt; &#39; &#39;;        cout &lt;&lt;  str &lt;&lt; endl;        str = tmp;    }}/*((p*q)*r) (p*q)|(!p*!q)(!p|q)*(!q|p) (p&gt;q)*(q&gt;p)!(p*q)&gt;(!p*!q)p-q (!p|r)*(r&gt;q)|p*qp*q|r*b*/</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一键安装v2ray</title>
      <link href="/2018/03/10/yi-jian-an-zhuang-v2ray/"/>
      <url>/2018/03/10/yi-jian-an-zhuang-v2ray/</url>
      
        <content type="html"><![CDATA[<p>0、我的vps版本：Ubuntu 18.10 x64。 地点：东京。</p><p>1、v2ray官方给出了一键安装脚本<br><code>bash &lt;(curl -L -s https://install.direct/go.sh)</code></p><p>2、很快就可以安装好了，可以用这个命令来查看状态<br><code>service v2ray status</code></p><p>3、有以下这些命令，刚开始需要启动服务<br><code>service v2ray start|stop|status|reload|restart|force-reload</code></p><p>4、由于是一键安装，于是那些设置都是默认的，可以到<code>/etc/v2ray/config.json</code>来配置自己的服务器，也是到这里找到设置然后给我们的客户端进行设置。</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpgly1g0xww85mr9j30rw0ng40a.jpg" alt="在这里插入图片描述"><br>5、延迟在90ms左右<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0xwwpt5ekj30pv038aa0.jpg" alt="在这里插入图片描述"><br>6、一键进行BBR加速</p><p><code>wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</code></p><p>7、我选择的是6<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0xwxb7ee4j30oi0jt40k.jpg" alt="在这里插入图片描述"></p><p>8、测试了一下延迟，最低居然达到了31ms，简直令人发指！！！</p><p><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0xwy4d8zcj30qf01u747.jpg" alt="在这里插入图片描述"><br>9、多试几次稳定在60ms左右，也是非常低的延迟了！<br><img src="https://ws3.sinaimg.cn/large/005BYqpggy1g0xwyj0jy7j30q501tq2u.jpg" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 科学上网 </tag>
            
            <tag> v2ray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主元素问题_奇妙的思维</title>
      <link href="/2018/02/13/zhu-yuan-su-wen-ti-qi-miao-de-si-wei/"/>
      <url>/2018/02/13/zhu-yuan-su-wen-ti-qi-miao-de-si-wei/</url>
      
        <content type="html"><![CDATA[<h1 id="主元素问题"><a href="#主元素问题" class="headerlink" title="主元素问题"></a>主元素问题</h1><h2 id="什么是主元素问题"><a href="#什么是主元素问题" class="headerlink" title="什么是主元素问题?"></a>什么是主元素问题?</h2><blockquote><p>已知一个数组的大小，并且其中存在一个数，出现的频率大于50%，则称其为该数组的主元素。用一个算法找出这个数，要求其时间复杂度尽可能低。</p></blockquote><p>这是一个很简单的问题, 解决的方法有很多, 思考这样一道问题的意义不在于只是把它解决, 而是找出多种解决它的方法, 感受算法的神奇.</p><p>衡量一个算法优劣的一个非常重要的尺度是<strong>时间复杂度</strong>, 我们如何让计算机用最短的时间, 解决这个问题呢?</p><h2 id="先排序-比较排序-后计数的方法"><a href="#先排序-比较排序-后计数的方法" class="headerlink" title="先排序(比较排序)后计数的方法"></a>先排序(比较排序)后计数的方法</h2><p>先排序后后比较, 这种方法是比较常规的思维.<br>排序之后将每个相同的元素计数, 再根据数量判断是哪一个元素</p><p>比较排序最快的平均时间复杂度是O(nlogn), 所以这个方法最快的时间按复杂度是O(nlogn)</p><blockquote><p><em><em>这种排序方式在所有方式中效率较低, 但它适合各种数据类型(如浮点型), 且在某些情况下空间复杂度比计数排序的方法小很多. </em></em></p></blockquote><p><strong>还可以判断是否存在这样一个主元素.</strong></p><p>代码比较简单且常规, 不写出(实际上用STL的sort()很简单, 但手写快排, 还是算了吧……)</p><h3 id="一个简单优化"><a href="#一个简单优化" class="headerlink" title="一个简单优化"></a>一个简单优化</h3><p>对于一个已经排序好了的序列, 其实不需要给每个元素计数.</p><blockquote><p><strong>因为它是主元素(&gt;50%), 所以只要取中值就可以知道它是哪个(它的值).</strong></p></blockquote><h2 id="计数排序的方法"><a href="#计数排序的方法" class="headerlink" title="计数排序的方法"></a>计数排序的方法</h2><p>计数排序也叫桶排序, 是一种非比较型排序.</p><p>时间复杂度位O(N) (N取决于数据范围)</p><p>鉴于计数排序对数据类型的限制很大, 所以比较各种排序方法的优劣时通常不把计数排序和快排这种比较排序相比较(事实上没有意义)</p><p><strong>如果数据稀松或者范围很大, 计数排序将会非常浪费空间(空间复杂度非常大)</strong></p><p>但在某些特定的条件下, 计数排序确实是一种时间复杂度位O(n)的排序算法<br>如: 数据是1-1e6之间的整数</p><p><strong>同样可以判断是否存在这样一个主元素</strong></p><p>而使用计数排序的方法觉得这道题, 不需要排序, 事实上它可以看作计数排序的一个子过程</p><h2 id="用STL中的nth-element-函数"><a href="#用STL中的nth-element-函数" class="headerlink" title="用STL中的nth_element()函数"></a>用STL中的nth_element()函数</h2><p>刚认识nth_element()函数没几天, 写这个问题的时候突然觉得可以用这个函数解决主元素问题.</p><p>思路是: </p><blockquote><p>对N个数的序列用nth_element()找到第<strong>N/2+1</strong>个元素的值.<br>这个值就是<strong>主元素的值</strong></p></blockquote><p>缺陷是:</p><blockquote><p>无法判断是否存在主元素</p></blockquote><p>这是奇数的情况:</p><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;#define N 7using namespace std;int main(){    int a[] = {1, 4, 3, 1, 1, 2, 1}; //N为奇数, 从0开始     nth_element(a, a + N/2, a + N);    cout &lt;&lt; a[N/2];}</code></pre><p>这是偶数的情况:</p><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;#define N 6 using namespace std;int main(){    int a[] = {1, 3, 1, 1, 2, 1}; //N为偶数, 从0开始     nth_element(a, a + N/2, a + N);    cout &lt;&lt; a[N/3];}</code></pre><p><strong>时间复杂度为O(N)</strong><br><strong>nth_element()是STL算法库中一种O(N)的单元素排序算法函数</strong></p><h2 id="豆瓣里一种巧妙地方法"><a href="#豆瓣里一种巧妙地方法" class="headerlink" title="豆瓣里一种巧妙地方法"></a><a href="https://www.douban.com/note/505717075/" target="_blank" rel="noopener">豆瓣里一种巧妙地方法</a></h2><p>最后介绍的是一种豆瓣网友分享的巧妙算法</p><blockquote><p>其核心思想在于：<strong>对于这样一个数组，去除掉任意两个不相等的数，剩下的数中，主元素的出现频率仍然大于50%。</strong></p></blockquote><p>但又缺陷:</p><blockquote><p><strong>只能在确定存在主元素的序列中找到这个主元素.</strong><br>即无法判断是否存在主元素 </p></blockquote><blockquote><p>引自豆瓣:<br>解法：<br>声明一个变量count = 0，声明一个常量size等于数组大小。<br>假设该数组的第一个元素a(1)为主元素，让其与a(2)进行比较，若相同，则使变量count+1，若不同，则count-1。然后继续比较a(3)。以此类推。</p><p>当与a(n)比较后，count = -1时，将count重新归为0，并重新假设a(n+1)为主元素，并继续与a(n+2)作比较。</p><p>当count&gt;=(size-m)/2时，此时假设的主元素a(m)即为实际的主元素。 或遍历完整个数组后，当前假设的主元素为实际主元素。</p><p>这个算法的时间复杂度最大才O(N)，看书看到这一段时令我顿时拍案叫绝啊。其核心思想在于：对于这样一个数组，去除掉任意两个不相等的数，剩下的数中，主元素的出现频率仍然大于50%。而使用count来进行加减计数，当count=0时，必然是偶数个数与假设的主元素进行了比较，且其中有一半与假设数相同一半与假设数不同（当count=-1时，加上假设数的集合，也满足该条件）。</p></blockquote><p>下面是我写的简单代码(<strong>可能又bug</strong>)</p><pre><code>#include &lt;iostream&gt;#define N 7using namespace std;int main(){//    int a[] = {1, 4, 3, 1, 1, 2, 1};    int a[] = {1, 3, 4, 4, 5, 4, 4};//    int a[] = {1 ,5 ,6 ,8 ,7 ,9 ,4 ,2 ,7 ,5 ,2 ,2 ,2 ,2};    int cnt = 0, tmp = a[0];    for(int i = 1; i &lt; N; ++i) {        if(tmp == a[i]) cnt++;        else cnt--;        if(cnt &lt; 0) {            tmp = a[i];            cnt = 0;        }    }    cout &lt;&lt; &quot;cnt == &quot; &lt;&lt; cnt &lt;&lt; endl;    if (cnt &gt; 0) cout &lt;&lt; tmp &lt;&lt; endl;     else cout &lt;&lt; &quot;There is no such a number !\n&quot;;}</code></pre><p>###总而言之, 主元素问题是一种很简单的思维启发问题, 方法有很多, 可是你想到了最简单的方法吗?</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大子段和_三种方法</title>
      <link href="/2018/02/09/zui-da-zi-duan-he-san-chong-fang-fa/"/>
      <url>/2018/02/09/zui-da-zi-duan-he-san-chong-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>今天参加了一场洛谷网的比赛, 深受打击. 寒假过了这么多天, 一直没有认真学习算法, 以至于现在的水平比两个月前还要低. </p><p>本来就没有多少底子, 又退步了许多, 感慨万分.</p><p>在洛谷上看到这么一道题<br><a href="https://www.luogu.org/problemnew/show/P1115" target="_blank" rel="noopener">最大子段和</a></p><p>如果数据小的话, <strong>用暴力枚举</strong>很简单就可以做出来了, 时间按复杂度位O(n^3)<br>可是一道算法题怎么会这么简单呢?</p><p>样例的数据是非常大的, 所以用n^3的办法一个样例都过不了</p><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt; using namespace std;int main(){    //std::ios::sync_with_stdio(false);    long long int n, num[22000], Max = -1e8, sum;    cin &gt;&gt; n;    for( int i = 1; i &lt;= n; ++i ) {        scanf(&quot;%lld&quot;, &amp;num[i]);    }    for( int i = 1; i &lt;= n; ++ i ) {        for( int j = 1; j &lt;= n - i + 1; ++j ) {            sum = 0;            for(int k = j; k &lt; j + i; ++k) {                sum += num[k];            }            //cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum &lt;&lt; endl;            Max = max(Max, sum);            //cout &lt;&lt; Max &lt;&lt; endl;        }    }    cout &lt;&lt; Max;}</code></pre><p>稍微优化一下, 使用<strong>前缀和以及差分</strong>, 可以有效地将复杂度降为O(n^2), 可是, 对于这道题来说, 这个时间还是太多了. 只能通过40%的样例</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;long long int n, num[220000], qz[220000] = {}, ans = -1e9;using namespace std;int main(){    //std::ios::sync_with_stdio(false);    cin &gt;&gt; n;    for( int i = 1; i &lt;= n; ++ i ) {        //cin &gt;&gt; num[i];        scanf(&quot;%lld&quot;, &amp;num[i]);    }    for( int i = 1; i &lt;= n; ++i ) {        qz[i] = qz[i-1] + num[i];    }    for( int i = 1; i &lt;= n; ++i ) {        for( int j = 1; j &lt;= n-i+1; ++j ) {            ans = max(ans, qz[j+i-1] - qz[j-1]);        }    }    cout &lt;&lt; ans &lt;&lt; endl;}</code></pre><p>还有一种<strong>分治</strong>的方法做这道题, 时间复杂度为O(nlogn), 有点复杂,我还不会.</p><p>最简单的呢, <strong>使用DP的方法, 时间复杂度为O(n)</strong></p><p>这种方法凭我自己现在的水平是想不出来的, 尤其是现在状态如此之差. 看别人解释后写了代码觉得如此巧妙, 于是又惊叹算法之神奇</p><p>可怜的是, 即便别人告诉我这道题用DP解最简单, 我也解不出来, 谁叫我DP还没入门呢?</p><p>思路描述是这样的:</p><blockquote><p>a数组是储存输入的数值；c[i]表示的是a数组从头加到i的和；b[i]表示的是从头到i包括i的的最大子段和~（必须包括i！！！）；minn储存最小的前缀和（因为要减去所以要尽量小，详情见下一行） 动态转移方程式：b[i]=c[i]-minn（总和减去前缀和） 最后输出b数组最大的值（题目求最大的子段和）</p></blockquote><p>第一阶段的代码是这样的</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;long long int qz[220000] = {}, num[220000], mm[220000] = {}, an[220000], ans = -1e9;int main(){    int n;    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; ++i) {        scanf(&quot;%lld&quot;, &amp;num[i]);        qz[i] = num[i] + qz[i - 1];        mm[i] = min(mm[i - 1], qz[i - 1]);        ans = max(ans, qz[i] - mm[i]);    }    cout &lt;&lt; ans;}</code></pre><p>时间复杂度确实是小, 但是有一个问题就是空间复杂度太大了, 没必要这样开数组.</p><p>看了别人的题解, dalao们用的是滚动数组, 一个上面220000的数组只用两个元素循环滚动即可.</p><p>叹服!</p><p>妙哉!</p><pre><code>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;long long int qz[2] = {}, mm[2] = {}, ans = -1e9, m, n;int main(){    cin &gt;&gt; n;    for( int i = 1; i &lt;= n; ++i ) {        scanf(&quot;%lld&quot;, &amp;m);        qz[i % 2] = qz[(i + 1) % 2] + m;        mm[i % 2] = min(mm[(i + 1) % 2], qz[(i + 1) % 2]);        ans = max(ans, qz[i % 2] - mm[i % 2]);    }    cout &lt;&lt; ans;}</code></pre><p>写这道题还发现了或者说学到了或者说巩固了几个小知识</p><p>1) 取消cin的同步用这样的代码</p><pre><code>std::ios::sync_with_stdio(false);</code></pre><p>此为巩固</p><p>2) 使用scanf输入C++ 中long long 型的数<br>是这样的</p><pre><code>long long int n;scanf(&quot;%lld&quot;, &amp;n);</code></pre><p>如果n的类型写为long long Dev会发出警告, 还不知道为什么</p><p>百度一下, 又网友说long long 就是long long int , 只是int省略掉了</p><p>3) 使用scanf要包含头文件cstdio</p><p>以前我是不包含的, 不过这次在洛谷上提交出现了编译错误, 这也算是发现了自己的一个小bug吧</p><p><strong><strong><strong>____</strong></strong></strong>2018-7-9补充更新<strong><strong><strong>____</strong></strong></strong></p><p>今天程序设计训练测试出了这道题, 时隔多月再次写这道入门DP, 发现实现方法略有不同.</p><pre><code>#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int INF = 0x3f3f3f3f;int main(){    int x;    vector&lt;int&gt; v;    while (cin &gt;&gt; x) {        v.push_back(x);    }    int qz = 0, MAX = -INF;    for (int i = 0; i &lt; v.size(); ++i) {        if (qz + v[i] &lt;= 0) qz = 0;        else {            qz += v[i];            MAX = max(MAX, qz);        }    }    cout &lt;&lt; MAX;}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初步数论-扩展欧几里得&amp;线性同余方程</title>
      <link href="/2018/01/04/chu-bu-shu-lun-kuo-zhan-ou-ji-li-de-xian-xing-tong-yu-fang-cheng/"/>
      <url>/2018/01/04/chu-bu-shu-lun-kuo-zhan-ou-ji-li-de-xian-xing-tong-yu-fang-cheng/</url>
      
        <content type="html"><![CDATA[<p>这篇博客我将介绍数论中的<strong>扩展欧几里得算法</strong>(extended Euclidean algorithm ),以及其在<strong>解线性同余方程(乘法逆元)</strong>中的运用.</p><p>首先要了解几个概念:<br>    <a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95/9002848?fr=aladdin" target="_blank" rel="noopener">欧几里得算法</a><br>    <a href="https://baike.baidu.com/item/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7%E7%AE%97%E6%B3%95/1053275?fr=aladdin" target="_blank" rel="noopener">扩展欧几里得算法</a><br>    <a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E5%90%8C%E4%BD%99%E6%96%B9%E7%A8%8B/5544515?fr=aladdin" target="_blank" rel="noopener">线性同余方程</a></p><p><strong>欧几里得算法</strong>是一种求解两个正整数a, b的最大公因子(一般记为gcd,gcd(a, b) )的方法,这个方法最早被记载在欧几里得的&lt;&lt;几何原本&gt;&gt;中.<br><strong>扩展欧几里得算法</strong>是在欧几里得算法的基础上扩展的一种算法.我们知道了 a 和 b 的最大公约数是 gcd ，那么，我们一定能够找到这样的 x 和 y ，使得: a<em>x + b</em>y = gcd 这是一个不定方程（一种丢番图方程）.扩展欧几里得算法就这求这样的x, y 的.<br><strong>线性同余方程</strong>是最基本的同余方程，“线性”表示方程的未知数次数是一次.它的表现形式是这样的:<br>    设x是未知整数, 形如<br>        ax ≡ b(mod m)<br>    的同余式称为一元线性同余方程.<br>    加下来我将介绍使用扩展欧几里得算法解b = 1时的同余方程, 未知数为 x ,x又称为a的乘法逆元.<br><strong>乘法逆元</strong>是当b = 1时的解 x , 可以这样理解:<br>    ax ≡ 1(mod m)<br>    我们称 x 是a关于m的乘法逆元</p><p>那么,从欧几里得算法开始.学习算法过程中,欧几里得算法大概是我接触到的第一个算法</p><pre><code>int gcd(int a, int b){    if( b==0 ) return a;    else return gcd(b,a%b);}</code></pre><p>函数返回的是a, b的最大公约数,一般用gcd(a,b)来表示,数论中一般用(a,b)来表示a,b的最大公约数<br>由于此算法较为基础,在此不过多赘述.</p><p>但,需要了解的是,扩展欧几里算法就是在欧几里得算法的基础上加以扩展形成的.</p><p>我们首先要知道这样一个结论:<br>a 和 b 的最大公约数是 gcd ，那么，我们一定能够找到这样的 x 和 y ，使得: a<em>x + b</em>y = gcd(a,b)<br>扩展欧几里得算法的作用就是求这样的x, y的.它的解是无限的,我们可以这样表示它的通解:</p><pre><code> x = x0 + (b/gcd)*t; y = y0 - (a/gcd)*t;</code></pre><p>为什么不是：</p><pre><code>x = x0 + b*t;y = y0 - a*t;?</code></pre><p>我们要知道,这个通解中未知数的表达式的运算过程是互相抵消的.如:</p><pre><code>    (b/gcd) *t *a - (a/gcd) *t *b = 0;</code></pre><p>而如果a, b不是互质的, 另一种形式那么会漏掉一些解.读者自己斟酌.(具体证明博主也不知如何是好)</p><p>如何求解呢?<br>只需要在欧几里德算法的基础上加点改动就行了。</p><p>  下面引自<a href="http://blog.csdn.net/zhjchengfeng5/article/details/7786595" target="_blank" rel="noopener"><em>一篇博客</em></a></p><blockquote><p> 我们观察到：欧几里德算法停止的状态是： a= gcd ， b = 0 ，那么，这是否能给我们求解 x y<br> 提供一种思路呢？因为，这时候，只要 a = gcd 的系数是 1 ，那么只要 b 的系数是 0 或者其他值（无所谓是多少，反正任何数乘以 0<br> 都等于 0 但是a 的系数一定要是 1），这时，我们就会有： a<em>1 + b</em>0 = gcd</p><p>  当然这是最终状态，但是我们是否可以从最终状态反推到最初的状态呢？</p><p>  假设当前我们要处理的是求出 a 和 b的最大公约数，并求出 x 和 y 使得 a<em>x + b</em>y= gcd ，而我们已经求出了下一个状态：b 和 a%b 的最大公约数，并且求出了一组x1 和y1 使得： b<em>x1 + (a%b)</em>y1 = gcd<br> ， 那么这两个相邻的状态之间是否存在一种关系呢？</p><p>  我们知道： a%b = a - (a/b)*b（这里的 “/” 指的是整除，例如 5/2=2 , 1/3=0），那么，我们可以进一步得到：</p><pre><code>  gcd = b*x1 + (a-(a/b)*b)*y1      = b*x1 + a*y1 – (a/b)*b*y1      = a*y1 + b*(x1 – a/b*y1)</code></pre><p>  对比之前我们的状态：求一组 x 和 y 使得：a<em>x + b</em>y = gcd ，是否发现了什么？</p><p>  这里：</p><pre><code>  x = y1  y = x1 – a/b*y1</code></pre></blockquote><pre><code>int ex_gcd( int a, int b, int &amp;x, int &amp;y ){    if( b==0 ){        x = 1, y = 0;        return a;    }    int ans = ex_gcd(b,a%b,x,y);    int tmp = x;    x = y;    y = tmp - a/b*y;    return ans;}</code></pre><p>欧几里得算法只能求a, b的最大公因数,而扩展欧几里得算法不仅可以求gcd(a,b),还可以求出a<em> x + b</em> y = gcd的通解只需在欧几里得算法的基础上稍加改动<br>然而,求通解有什么用呢?<br>我将介绍扩展欧几里得算法的一个应用,那就是前面提到过的解乘法逆元.</p><p>对于</p><pre><code>ax ≡ 1(mod m)</code></pre><p>我们称 x 是a关于m的乘法逆元<br>这和扩欧有什么关系呢?可以看到这个式子和a<em> x + b</em> y = gcd = 1是有些类似的<br>可以等价于这样的表达式： a<em> x + m</em> y = 1<br>a<em> x + b</em> y = gcd = 1, 说明a, b互质, 那么推广的式子a<em> x + m</em> y = 1中, a, m也是互质的<br>当gcd(a, m) != 1时,x是无解的.</p><p>乘法逆元式子中, 已知a, m, 那么就可以利用扩展欧几里得算法求解x了.<br>算法如下:</p><pre><code>#include &lt;iostream&gt;using namespace std;int ex_gcd( int a, int b, int &amp;x, int &amp;y ){    if( b==0 ){        x = 1, y = 0;//递归到终止条件, 初始化x, y        return a;    }    int ans = ex_gcd(b,a%b,x,y);//继续递归,此前不对x, y进行操作    int temp = x;    x = y;    y = tmp - a/b*y;//利用推导出的两个相邻状态的代换式进行迭代    return ans;}int main( ){    int a, b, x, y;    cin &gt;&gt; a &gt;&gt; b;    if( ex_gcd(a,b,x,y)==1 ){        cout &lt;&lt; (x+b)%b;     }}</code></pre><p>注意,在ex_gcd()中求得的x可能为负值,因此采用了　cout &lt;&lt; (x+b)%b; 这样的输出方式，输出ｘ最小的正整数解</p><p>到这里就结束了,我们讲了什么呢?</p><pre><code>欧几里得算法扩展欧几里得算法线性同余方程中一种特殊情况:乘法逆元 </code></pre><p>这是我在CSDN发表的的第一篇博客,有很多不足.如果没看懂的话,欢迎看这篇文章<br>    <a href="http://blog.csdn.net/zhjchengfeng5/article/details/7786595" target="_blank" rel="noopener">扩展欧几里德算法详解</a><br>    博主讲的很清楚, 对我启发很大.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
